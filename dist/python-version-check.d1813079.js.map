{"mappings":"A,O,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,S,C,K,M,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,ECEM,IAAA,EAAA,EAAA,MAAA,CACA,EAAA,EAAA,YAAA,CACA,EAAA,EAAA,aAAA,CACA,EAAA,EAAA,eAAA,CACA,EAAA,EAAA,yBAAA,CAAA,EAAA,sDAAA,MAAA,CAAA,EAAA,sDAAA,OAAA,CAAA,EAAA,qDAAA,WAAA,CACA,EAAA,EAAA,aAAA,CAAA,EAAA,sDAAA,WAAA,CAAA,EAAA,sDAAA,WAAA,CAAA,EAAA,qDAAA,WAAA,CAAA,EAAA,sDAAA,SAAA,CAAA,EAAA,sDAAA,UAAA,CAAA,EAAA,sDAAA,WAAA,CASA,EAAA,sDAAA,aAAA,CAAA,EAAA,sDAAA,SAAA,CAAA,EAAA,EAAA,kBAAA,CAAA,EAAA,qDAAA,uBAAA,CAAA,EAAA,sDAAA,SAAA,CACA,EAAA,EAAA,4BAAA,CACA,EAAA,EAAA,kBAAA,CACA,EAAA,EAAA,UAAA,CACA,EAAA,EAAA,mBAAA,CAAA,EAAA,qDAAA,UAAA,CACA,EAAA,EAAA,mBAAA,CAGN,IAAI,EAAqB,CAAA,CAGzB,OAAM,UAAkB,YACtB,CAAA,CAAO,CAAG,CACR,KAAM,KACN,MAAO,KACP,MAAO,KACP,QAAS,IACX,CAAC,AAED,EAAA,CAAe,CAAG,CAAC,AACnB,EAAA,CAAS,CAAG,EAAE,AACd,EAAA,CAAW,CAAG,EAAE,AAMhB,aAAa,CAAG,CAAE,EAAY,EAAE,CAAE,KAqB5B,EApBJ,KAAK,GAEL,EAAO,mBAAmB,CAAC,UAAW,EAAG,CAAE,OAAQ,uBAAwB,GA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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/websocket.js"],"sourcesContent":["import $6i7JP$pythonversioncheck801bb0f1js from \"./python-version-check.801bb0f1.js\";\nimport $6i7JP$pythonversioncheck863e006ejs from \"./python-version-check.863e006e.js\";\nimport $6i7JP$pythonversioncheck685b5bb2js from \"./python-version-check.685b5bb2.js\";\nimport $6i7JP$pythonversioncheckb40ebe18js from \"./python-version-check.b40ebe18.js\";\nimport $6i7JP$pythonversioncheck64bbae24js3 from \"./python-version-check.64bbae24.js\";\nimport $6i7JP$pythonversioncheckf95b0f32js6 from \"./python-version-check.f95b0f32.js\";\nimport $6i7JP$pythonversioncheck92967d43js4 from \"./python-version-check.92967d43.js\";\nimport $6i7JP$pythonversioncheck7703870ejs from \"./python-version-check.7703870e.js\";\nimport $6i7JP$pythonversioncheck1bc0acd6js from \"./python-version-check.1bc0acd6.js\";\nimport $6i7JP$pythonversioncheck98655e43js from \"./python-version-check.98655e43.js\";\nimport $6i7JP$pythonversioncheck7ed1514ejs1 from \"./python-version-check.7ed1514e.js\";\nimport $6i7JP$pythonversioncheck2f8c5fadjs from \"./python-version-check.2f8c5fad.js\";\nimport {types as $6i7JP$types} from \"util\";\n\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5a65\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5a65\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"2KKrI\", function(module, exports) {\n'use strict';\n\nvar $2013e7e199fee74d$require$webidl = $6i7JP$pythonversioncheck801bb0f1js.webidl;\n\nvar $2013e7e199fee74d$require$DOMException = $6i7JP$pythonversioncheck863e006ejs.DOMException;\n\nvar $2013e7e199fee74d$require$URLSerializer = $6i7JP$pythonversioncheck685b5bb2js.URLSerializer;\n\nvar $2013e7e199fee74d$require$getGlobalOrigin = $6i7JP$pythonversioncheckb40ebe18js.getGlobalOrigin;\n\nvar $2013e7e199fee74d$require$staticPropertyDescriptors = $6i7JP$pythonversioncheck64bbae24js3.staticPropertyDescriptors;\nvar $2013e7e199fee74d$require$states = $6i7JP$pythonversioncheck64bbae24js2.states;\nvar $2013e7e199fee74d$require$opcodes = $6i7JP$pythonversioncheck64bbae24js1.opcodes;\nvar $2013e7e199fee74d$require$emptyBuffer = $6i7JP$pythonversioncheck64bbae24js.emptyBuffer;\n\nvar $2013e7e199fee74d$require$kWebSocketURL = $6i7JP$pythonversioncheckf95b0f32js6.kWebSocketURL;\nvar $2013e7e199fee74d$require$kReadyState = $6i7JP$pythonversioncheckf95b0f32js3.kReadyState;\nvar $2013e7e199fee74d$require$kController = $6i7JP$pythonversioncheckf95b0f32js2.kController;\nvar $2013e7e199fee74d$require$kBinaryType = $6i7JP$pythonversioncheckf95b0f32js.kBinaryType;\nvar $2013e7e199fee74d$require$kResponse = $6i7JP$pythonversioncheckf95b0f32js4.kResponse;\nvar $2013e7e199fee74d$require$kSentClose = $6i7JP$pythonversioncheckf95b0f32js5.kSentClose;\nvar $2013e7e199fee74d$require$kByteParser = $6i7JP$pythonversioncheckf95b0f32js1.kByteParser;\n\nvar $2013e7e199fee74d$require$isEstablished = $6i7JP$pythonversioncheck92967d43js3.isEstablished;\nvar $2013e7e199fee74d$require$isClosing = $6i7JP$pythonversioncheck92967d43js2.isClosing;\nvar $2013e7e199fee74d$require$isValidSubprotocol = $6i7JP$pythonversioncheck92967d43js4.isValidSubprotocol;\nvar $2013e7e199fee74d$require$failWebsocketConnection = $6i7JP$pythonversioncheck92967d43js.failWebsocketConnection;\nvar $2013e7e199fee74d$require$fireEvent = $6i7JP$pythonversioncheck92967d43js1.fireEvent;\n\nvar $2013e7e199fee74d$require$establishWebSocketConnection = $6i7JP$pythonversioncheck7703870ejs.establishWebSocketConnection;\n\nvar $2013e7e199fee74d$require$WebsocketFrameSend = $6i7JP$pythonversioncheck1bc0acd6js.WebsocketFrameSend;\n\nvar $2013e7e199fee74d$require$ByteParser = $6i7JP$pythonversioncheck98655e43js.ByteParser;\n\nvar $2013e7e199fee74d$require$kEnumerableProperty = $6i7JP$pythonversioncheck7ed1514ejs1.kEnumerableProperty;\nvar $2013e7e199fee74d$require$isBlobLike = $6i7JP$pythonversioncheck7ed1514ejs.isBlobLike;\n\nvar $2013e7e199fee74d$require$getGlobalDispatcher = $6i7JP$pythonversioncheck2f8c5fadjs.getGlobalDispatcher;\n\nvar $2013e7e199fee74d$require$types = $6i7JP$types;\nlet $2013e7e199fee74d$var$experimentalWarned = false;\n// https://websockets.spec.whatwg.org/#interface-definition\nclass $2013e7e199fee74d$var$WebSocket extends EventTarget {\n    #events = {\n        open: null,\n        error: null,\n        close: null,\n        message: null\n    };\n    #bufferedAmount = 0;\n    #protocol = '';\n    #extensions = '';\n    /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */ constructor(url, protocols = []){\n        super();\n        $2013e7e199fee74d$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'WebSocket constructor'\n        });\n        if (!$2013e7e199fee74d$var$experimentalWarned) {\n            $2013e7e199fee74d$var$experimentalWarned = true;\n            process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n                code: 'UNDICI-WS'\n            });\n        }\n        const options = $2013e7e199fee74d$require$webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols);\n        url = $2013e7e199fee74d$require$webidl.converters.USVString(url);\n        protocols = options.protocols;\n        // 1. Let baseURL be this's relevant settings object's API base URL.\n        const baseURL = $2013e7e199fee74d$require$getGlobalOrigin();\n        // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n        let urlRecord;\n        try {\n            urlRecord = new URL(url, baseURL);\n        } catch (e) {\n            // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n            throw new $2013e7e199fee74d$require$DOMException(e, 'SyntaxError');\n        }\n        // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n        if (urlRecord.protocol === 'http:') urlRecord.protocol = 'ws:';\n        else if (urlRecord.protocol === 'https:') // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n        urlRecord.protocol = 'wss:';\n        // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n        if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') throw new $2013e7e199fee74d$require$DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');\n        // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n        //    DOMException.\n        if (urlRecord.hash || urlRecord.href.endsWith('#')) throw new $2013e7e199fee74d$require$DOMException('Got fragment', 'SyntaxError');\n        // 8. If protocols is a string, set protocols to a sequence consisting\n        //    of just that string.\n        if (typeof protocols === 'string') protocols = [\n            protocols\n        ];\n        // 9. If any of the values in protocols occur more than once or otherwise\n        //    fail to match the requirements for elements that comprise the value\n        //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n        //    protocol, then throw a \"SyntaxError\" DOMException.\n        if (protocols.length !== new Set(protocols.map((p)=>p.toLowerCase())).size) throw new $2013e7e199fee74d$require$DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n        if (protocols.length > 0 && !protocols.every((p)=>$2013e7e199fee74d$require$isValidSubprotocol(p))) throw new $2013e7e199fee74d$require$DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n        // 10. Set this's url to urlRecord.\n        this[$2013e7e199fee74d$require$kWebSocketURL] = new URL(urlRecord.href);\n        // 11. Let client be this's relevant settings object.\n        // 12. Run this step in parallel:\n        //    1. Establish a WebSocket connection given urlRecord, protocols,\n        //       and client.\n        this[$2013e7e199fee74d$require$kController] = $2013e7e199fee74d$require$establishWebSocketConnection(urlRecord, protocols, this, (response)=>this.#onConnectionEstablished(response), options);\n        // Each WebSocket object has an associated ready state, which is a\n        // number representing the state of the connection. Initially it must\n        // be CONNECTING (0).\n        this[$2013e7e199fee74d$require$kReadyState] = $2013e7e199fee74d$var$WebSocket.CONNECTING;\n        // The extensions attribute must initially return the empty string.\n        // The protocol attribute must initially return the empty string.\n        // Each WebSocket object has an associated binary type, which is a\n        // BinaryType. Initially it must be \"blob\".\n        this[$2013e7e199fee74d$require$kBinaryType] = 'blob';\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */ close(code, reason) {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        if (code !== undefined) code = $2013e7e199fee74d$require$webidl.converters['unsigned short'](code, {\n            clamp: true\n        });\n        if (reason !== undefined) reason = $2013e7e199fee74d$require$webidl.converters.USVString(reason);\n        // 1. If code is present, but is neither an integer equal to 1000 nor an\n        //    integer in the range 3000 to 4999, inclusive, throw an\n        //    \"InvalidAccessError\" DOMException.\n        if (code !== undefined) {\n            if (code !== 1000 && (code < 3000 || code > 4999)) throw new $2013e7e199fee74d$require$DOMException('invalid code', 'InvalidAccessError');\n        }\n        let reasonByteLength = 0;\n        // 2. If reason is present, then run these substeps:\n        if (reason !== undefined) {\n            // 1. Let reasonBytes be the result of encoding reason.\n            // 2. If reasonBytes is longer than 123 bytes, then throw a\n            //    \"SyntaxError\" DOMException.\n            reasonByteLength = Buffer.byteLength(reason);\n            if (reasonByteLength > 123) throw new $2013e7e199fee74d$require$DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');\n        }\n        // 3. Run the first matching steps from the following list:\n        if (this[$2013e7e199fee74d$require$kReadyState] === $2013e7e199fee74d$var$WebSocket.CLOSING || this[$2013e7e199fee74d$require$kReadyState] === $2013e7e199fee74d$var$WebSocket.CLOSED) ;\n        else if (!$2013e7e199fee74d$require$isEstablished(this)) {\n            // If the WebSocket connection is not yet established\n            // Fail the WebSocket connection and set this's ready state\n            // to CLOSING (2).\n            $2013e7e199fee74d$require$failWebsocketConnection(this, 'Connection was closed before it was established.');\n            this[$2013e7e199fee74d$require$kReadyState] = $2013e7e199fee74d$var$WebSocket.CLOSING;\n        } else if (!$2013e7e199fee74d$require$isClosing(this)) {\n            // If the WebSocket closing handshake has not yet been started\n            // Start the WebSocket closing handshake and set this's ready\n            // state to CLOSING (2).\n            // - If neither code nor reason is present, the WebSocket Close\n            //   message must not have a body.\n            // - If code is present, then the status code to use in the\n            //   WebSocket Close message must be the integer given by code.\n            // - If reason is also present, then reasonBytes must be\n            //   provided in the Close message after the status code.\n            const frame = new $2013e7e199fee74d$require$WebsocketFrameSend();\n            // If neither code nor reason is present, the WebSocket Close\n            // message must not have a body.\n            // If code is present, then the status code to use in the\n            // WebSocket Close message must be the integer given by code.\n            if (code !== undefined && reason === undefined) {\n                frame.frameData = Buffer.allocUnsafe(2);\n                frame.frameData.writeUInt16BE(code, 0);\n            } else if (code !== undefined && reason !== undefined) {\n                // If reason is also present, then reasonBytes must be\n                // provided in the Close message after the status code.\n                frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n                frame.frameData.writeUInt16BE(code, 0);\n                // the body MAY contain UTF-8-encoded data with value /reason/\n                frame.frameData.write(reason, 2, 'utf-8');\n            } else frame.frameData = $2013e7e199fee74d$require$emptyBuffer;\n            /** @type {import('stream').Duplex} */ const socket = this[$2013e7e199fee74d$require$kResponse].socket;\n            socket.write(frame.createFrame($2013e7e199fee74d$require$opcodes.CLOSE), (err)=>{\n                if (!err) this[$2013e7e199fee74d$require$kSentClose] = true;\n            });\n            // Upon either sending or receiving a Close control frame, it is said\n            // that _The WebSocket Closing Handshake is Started_ and that the\n            // WebSocket connection is in the CLOSING state.\n            this[$2013e7e199fee74d$require$kReadyState] = $2013e7e199fee74d$require$states.CLOSING;\n        } else // Otherwise\n        // Set this's ready state to CLOSING (2).\n        this[$2013e7e199fee74d$require$kReadyState] = $2013e7e199fee74d$var$WebSocket.CLOSING;\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */ send(data) {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        $2013e7e199fee74d$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'WebSocket.send'\n        });\n        data = $2013e7e199fee74d$require$webidl.converters.WebSocketSendData(data);\n        // 1. If this's ready state is CONNECTING, then throw an\n        //    \"InvalidStateError\" DOMException.\n        if (this[$2013e7e199fee74d$require$kReadyState] === $2013e7e199fee74d$var$WebSocket.CONNECTING) throw new $2013e7e199fee74d$require$DOMException('Sent before connected.', 'InvalidStateError');\n        // 2. Run the appropriate set of steps from the following list:\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n        if (!$2013e7e199fee74d$require$isEstablished(this) || $2013e7e199fee74d$require$isClosing(this)) return;\n        /** @type {import('stream').Duplex} */ const socket = this[$2013e7e199fee74d$require$kResponse].socket;\n        // If data is a string\n        if (typeof data === 'string') {\n            // If the WebSocket connection is established and the WebSocket\n            // closing handshake has not yet started, then the user agent\n            // must send a WebSocket Message comprised of the data argument\n            // using a text frame opcode; if the data cannot be sent, e.g.\n            // because it would need to be buffered but the buffer is full,\n            // the user agent must flag the WebSocket as full and then close\n            // the WebSocket connection. Any invocation of this method with a\n            // string argument that does not throw an exception must increase\n            // the bufferedAmount attribute by the number of bytes needed to\n            // express the argument as UTF-8.\n            const value = Buffer.from(data);\n            const frame = new $2013e7e199fee74d$require$WebsocketFrameSend(value);\n            const buffer = frame.createFrame($2013e7e199fee74d$require$opcodes.TEXT);\n            this.#bufferedAmount += value.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= value.byteLength;\n            });\n        } else if ($2013e7e199fee74d$require$types.isArrayBuffer(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need\n            // to be buffered but the buffer is full, the user agent must flag\n            // the WebSocket as full and then close the WebSocket connection.\n            // The data to be sent is the data stored in the buffer described\n            // by the ArrayBuffer object. Any invocation of this method with an\n            // ArrayBuffer argument that does not throw an exception must\n            // increase the bufferedAmount attribute by the length of the\n            // ArrayBuffer in bytes.\n            const value = Buffer.from(data);\n            const frame = new $2013e7e199fee74d$require$WebsocketFrameSend(value);\n            const buffer = frame.createFrame($2013e7e199fee74d$require$opcodes.BINARY);\n            this.#bufferedAmount += value.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= value.byteLength;\n            });\n        } else if (ArrayBuffer.isView(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The\n            // data to be sent is the data stored in the section of the buffer\n            // described by the ArrayBuffer object that data references. Any\n            // invocation of this method with this kind of argument that does\n            // not throw an exception must increase the bufferedAmount attribute\n            // by the length of data’s buffer in bytes.\n            const ab = Buffer.from(data, data.byteOffset, data.byteLength);\n            const frame = new $2013e7e199fee74d$require$WebsocketFrameSend(ab);\n            const buffer = frame.createFrame($2013e7e199fee74d$require$opcodes.BINARY);\n            this.#bufferedAmount += ab.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= ab.byteLength;\n            });\n        } else if ($2013e7e199fee74d$require$isBlobLike(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The data\n            // to be sent is the raw data represented by the Blob object. Any\n            // invocation of this method with a Blob argument that does not throw\n            // an exception must increase the bufferedAmount attribute by the size\n            // of the Blob object’s raw data, in bytes.\n            const frame = new $2013e7e199fee74d$require$WebsocketFrameSend();\n            data.arrayBuffer().then((ab)=>{\n                const value = Buffer.from(ab);\n                frame.frameData = value;\n                const buffer = frame.createFrame($2013e7e199fee74d$require$opcodes.BINARY);\n                this.#bufferedAmount += value.byteLength;\n                socket.write(buffer, ()=>{\n                    this.#bufferedAmount -= value.byteLength;\n                });\n            });\n        }\n    }\n    get readyState() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        // The readyState getter steps are to return this's ready state.\n        return this[$2013e7e199fee74d$require$kReadyState];\n    }\n    get bufferedAmount() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        return this.#bufferedAmount;\n    }\n    get url() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        // The url getter steps are to return this's url, serialized.\n        return $2013e7e199fee74d$require$URLSerializer(this[$2013e7e199fee74d$require$kWebSocketURL]);\n    }\n    get extensions() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        return this.#extensions;\n    }\n    get protocol() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        return this.#protocol;\n    }\n    get onopen() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        return this.#events.open;\n    }\n    set onopen(fn) {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        if (this.#events.open) this.removeEventListener('open', this.#events.open);\n        if (typeof fn === 'function') {\n            this.#events.open = fn;\n            this.addEventListener('open', fn);\n        } else this.#events.open = null;\n    }\n    get onerror() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        return this.#events.error;\n    }\n    set onerror(fn) {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        if (this.#events.error) this.removeEventListener('error', this.#events.error);\n        if (typeof fn === 'function') {\n            this.#events.error = fn;\n            this.addEventListener('error', fn);\n        } else this.#events.error = null;\n    }\n    get onclose() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        return this.#events.close;\n    }\n    set onclose(fn) {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        if (this.#events.close) this.removeEventListener('close', this.#events.close);\n        if (typeof fn === 'function') {\n            this.#events.close = fn;\n            this.addEventListener('close', fn);\n        } else this.#events.close = null;\n    }\n    get onmessage() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        return this.#events.message;\n    }\n    set onmessage(fn) {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        if (this.#events.message) this.removeEventListener('message', this.#events.message);\n        if (typeof fn === 'function') {\n            this.#events.message = fn;\n            this.addEventListener('message', fn);\n        } else this.#events.message = null;\n    }\n    get binaryType() {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        return this[$2013e7e199fee74d$require$kBinaryType];\n    }\n    set binaryType(type) {\n        $2013e7e199fee74d$require$webidl.brandCheck(this, $2013e7e199fee74d$var$WebSocket);\n        if (type !== 'blob' && type !== 'arraybuffer') this[$2013e7e199fee74d$require$kBinaryType] = 'blob';\n        else this[$2013e7e199fee74d$require$kBinaryType] = type;\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */ #onConnectionEstablished(response) {\n        // processResponse is called when the \"response’s header list has been received and initialized.\"\n        // once this happens, the connection is open\n        this[$2013e7e199fee74d$require$kResponse] = response;\n        const parser = new $2013e7e199fee74d$require$ByteParser(this);\n        parser.on('drain', function onParserDrain() {\n            this.ws[$2013e7e199fee74d$require$kResponse].socket.resume();\n        });\n        response.socket.ws = this;\n        this[$2013e7e199fee74d$require$kByteParser] = parser;\n        // 1. Change the ready state to OPEN (1).\n        this[$2013e7e199fee74d$require$kReadyState] = $2013e7e199fee74d$require$states.OPEN;\n        // 2. Change the extensions attribute’s value to the extensions in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n        const extensions = response.headersList.get('sec-websocket-extensions');\n        if (extensions !== null) this.#extensions = extensions;\n        // 3. Change the protocol attribute’s value to the subprotocol in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n        const protocol = response.headersList.get('sec-websocket-protocol');\n        if (protocol !== null) this.#protocol = protocol;\n        // 4. Fire an event named open at the WebSocket object.\n        $2013e7e199fee74d$require$fireEvent('open', this);\n    }\n}\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\n$2013e7e199fee74d$var$WebSocket.CONNECTING = $2013e7e199fee74d$var$WebSocket.prototype.CONNECTING = $2013e7e199fee74d$require$states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\n$2013e7e199fee74d$var$WebSocket.OPEN = $2013e7e199fee74d$var$WebSocket.prototype.OPEN = $2013e7e199fee74d$require$states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\n$2013e7e199fee74d$var$WebSocket.CLOSING = $2013e7e199fee74d$var$WebSocket.prototype.CLOSING = $2013e7e199fee74d$require$states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\n$2013e7e199fee74d$var$WebSocket.CLOSED = $2013e7e199fee74d$var$WebSocket.prototype.CLOSED = $2013e7e199fee74d$require$states.CLOSED;\nObject.defineProperties($2013e7e199fee74d$var$WebSocket.prototype, {\n    CONNECTING: $2013e7e199fee74d$require$staticPropertyDescriptors,\n    OPEN: $2013e7e199fee74d$require$staticPropertyDescriptors,\n    CLOSING: $2013e7e199fee74d$require$staticPropertyDescriptors,\n    CLOSED: $2013e7e199fee74d$require$staticPropertyDescriptors,\n    url: $2013e7e199fee74d$require$kEnumerableProperty,\n    readyState: $2013e7e199fee74d$require$kEnumerableProperty,\n    bufferedAmount: $2013e7e199fee74d$require$kEnumerableProperty,\n    onopen: $2013e7e199fee74d$require$kEnumerableProperty,\n    onerror: $2013e7e199fee74d$require$kEnumerableProperty,\n    onclose: $2013e7e199fee74d$require$kEnumerableProperty,\n    close: $2013e7e199fee74d$require$kEnumerableProperty,\n    onmessage: $2013e7e199fee74d$require$kEnumerableProperty,\n    binaryType: $2013e7e199fee74d$require$kEnumerableProperty,\n    send: $2013e7e199fee74d$require$kEnumerableProperty,\n    extensions: $2013e7e199fee74d$require$kEnumerableProperty,\n    protocol: $2013e7e199fee74d$require$kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: 'WebSocket',\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties($2013e7e199fee74d$var$WebSocket, {\n    CONNECTING: $2013e7e199fee74d$require$staticPropertyDescriptors,\n    OPEN: $2013e7e199fee74d$require$staticPropertyDescriptors,\n    CLOSING: $2013e7e199fee74d$require$staticPropertyDescriptors,\n    CLOSED: $2013e7e199fee74d$require$staticPropertyDescriptors\n});\n$2013e7e199fee74d$require$webidl.converters['sequence<DOMString>'] = $2013e7e199fee74d$require$webidl.sequenceConverter($2013e7e199fee74d$require$webidl.converters.DOMString);\n$2013e7e199fee74d$require$webidl.converters['DOMString or sequence<DOMString>'] = function(V) {\n    if ($2013e7e199fee74d$require$webidl.util.Type(V) === 'Object' && Symbol.iterator in V) return $2013e7e199fee74d$require$webidl.converters['sequence<DOMString>'](V);\n    return $2013e7e199fee74d$require$webidl.converters.DOMString(V);\n};\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\n$2013e7e199fee74d$require$webidl.converters.WebSocketInit = $2013e7e199fee74d$require$webidl.dictionaryConverter([\n    {\n        key: 'protocols',\n        converter: $2013e7e199fee74d$require$webidl.converters['DOMString or sequence<DOMString>'],\n        get defaultValue () {\n            return [];\n        }\n    },\n    {\n        key: 'dispatcher',\n        converter: (V)=>V,\n        get defaultValue () {\n            return $2013e7e199fee74d$require$getGlobalDispatcher();\n        }\n    },\n    {\n        key: 'headers',\n        converter: $2013e7e199fee74d$require$webidl.nullableConverter($2013e7e199fee74d$require$webidl.converters.HeadersInit)\n    }\n]);\n$2013e7e199fee74d$require$webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function(V) {\n    if ($2013e7e199fee74d$require$webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) return $2013e7e199fee74d$require$webidl.converters.WebSocketInit(V);\n    return {\n        protocols: $2013e7e199fee74d$require$webidl.converters['DOMString or sequence<DOMString>'](V)\n    };\n};\n$2013e7e199fee74d$require$webidl.converters.WebSocketSendData = function(V) {\n    if ($2013e7e199fee74d$require$webidl.util.Type(V) === 'Object') {\n        if ($2013e7e199fee74d$require$isBlobLike(V)) return $2013e7e199fee74d$require$webidl.converters.Blob(V, {\n            strict: false\n        });\n        if (ArrayBuffer.isView(V) || $2013e7e199fee74d$require$types.isAnyArrayBuffer(V)) return $2013e7e199fee74d$require$webidl.converters.BufferSource(V);\n    }\n    return $2013e7e199fee74d$require$webidl.converters.USVString(V);\n};\nmodule.exports = {\n    WebSocket: $2013e7e199fee74d$var$WebSocket\n};\n\n});\n\n\nparcelRequire(\"2KKrI\");\n\n//# sourceMappingURL=python-version-check.d1813079.js.map\n","'use strict'\n\nconst { webidl } = require('../fetch/webidl')\nconst { DOMException } = require('../fetch/constants')\nconst { URLSerializer } = require('../fetch/dataURL')\nconst { getGlobalOrigin } = require('../fetch/global')\nconst { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require('./constants')\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = require('./symbols')\nconst { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require('./util')\nconst { establishWebSocketConnection } = require('./connection')\nconst { WebsocketFrameSend } = require('./frame')\nconst { ByteParser } = require('./receiver')\nconst { kEnumerableProperty, isBlobLike } = require('../core/util')\nconst { getGlobalDispatcher } = require('../global')\nconst { types } = require('util')\n\nlet experimentalWarned = false\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' })\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n        code: 'UNDICI-WS'\n      })\n    }\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols)\n\n    url = webidl.converters.USVString(url)\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = getGlobalOrigin()\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url, baseURL)\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:'\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n      urlRecord.protocol = 'wss:'\n    }\n\n    // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href)\n\n    // 11. Let client be this's relevant settings object.\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      this,\n      (response) => this.#onConnectionEstablished(response),\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason)\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n      // If this's ready state is CLOSING (2) or CLOSED (3)\n      // Do nothing.\n    } else if (!isEstablished(this)) {\n      // If the WebSocket connection is not yet established\n      // Fail the WebSocket connection and set this's ready state\n      // to CLOSING (2).\n      failWebsocketConnection(this, 'Connection was closed before it was established.')\n      this[kReadyState] = WebSocket.CLOSING\n    } else if (!isClosing(this)) {\n      // If the WebSocket closing handshake has not yet been started\n      // Start the WebSocket closing handshake and set this's ready\n      // state to CLOSING (2).\n      // - If neither code nor reason is present, the WebSocket Close\n      //   message must not have a body.\n      // - If code is present, then the status code to use in the\n      //   WebSocket Close message must be the integer given by code.\n      // - If reason is also present, then reasonBytes must be\n      //   provided in the Close message after the status code.\n\n      const frame = new WebsocketFrameSend()\n\n      // If neither code nor reason is present, the WebSocket Close\n      // message must not have a body.\n\n      // If code is present, then the status code to use in the\n      // WebSocket Close message must be the integer given by code.\n      if (code !== undefined && reason === undefined) {\n        frame.frameData = Buffer.allocUnsafe(2)\n        frame.frameData.writeUInt16BE(code, 0)\n      } else if (code !== undefined && reason !== undefined) {\n        // If reason is also present, then reasonBytes must be\n        // provided in the Close message after the status code.\n        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n        frame.frameData.writeUInt16BE(code, 0)\n        // the body MAY contain UTF-8-encoded data with value /reason/\n        frame.frameData.write(reason, 2, 'utf-8')\n      } else {\n        frame.frameData = emptyBuffer\n      }\n\n      /** @type {import('stream').Duplex} */\n      const socket = this[kResponse].socket\n\n      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {\n        if (!err) {\n          this[kSentClose] = true\n        }\n      })\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this[kReadyState] = states.CLOSING\n    } else {\n      // Otherwise\n      // Set this's ready state to CLOSING (2).\n      this[kReadyState] = WebSocket.CLOSING\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' })\n\n    data = webidl.converters.WebSocketSendData(data)\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (this[kReadyState] === WebSocket.CONNECTING) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = this[kResponse].socket\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.TEXT)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      const ab = Buffer.from(data, data.byteOffset, data.byteLength)\n\n      const frame = new WebsocketFrameSend(ab)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += ab.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= ab.byteLength\n      })\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      const frame = new WebsocketFrameSend()\n\n      data.arrayBuffer().then((ab) => {\n        const value = Buffer.from(ab)\n        frame.frameData = value\n        const buffer = frame.createFrame(opcodes.BINARY)\n\n        this.#bufferedAmount += value.byteLength\n        socket.write(buffer, () => {\n          this.#bufferedAmount -= value.byteLength\n        })\n      })\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response\n\n    const parser = new ByteParser(this)\n    parser.on('drain', function onParserDrain () {\n      this.ws[kResponse].socket.resume()\n    })\n\n    response.socket.ws = this\n    this[kByteParser] = parser\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    get defaultValue () {\n      return []\n    }\n  },\n  {\n    key: 'dispatcher',\n    converter: (V) => V,\n    get defaultValue () {\n      return getGlobalDispatcher()\n    }\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nmodule.exports = {\n  WebSocket\n}\n"],"names":["$6i7JP$pythonversioncheck801bb0f1js","$6i7JP$pythonversioncheck863e006ejs","$6i7JP$pythonversioncheck685b5bb2js","$6i7JP$pythonversioncheckb40ebe18js","$6i7JP$pythonversioncheck64bbae24js3","$6i7JP$pythonversioncheckf95b0f32js6","$6i7JP$pythonversioncheck92967d43js4","$6i7JP$pythonversioncheck7703870ejs","$6i7JP$pythonversioncheck1bc0acd6js","$6i7JP$pythonversioncheck98655e43js","$6i7JP$pythonversioncheck7ed1514ejs1","$6i7JP$pythonversioncheck2f8c5fadjs","types","$6i7JP$types","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$2013e7e199fee74d$require$webidl","webidl","$2013e7e199fee74d$require$DOMException","DOMException","$2013e7e199fee74d$require$URLSerializer","URLSerializer","$2013e7e199fee74d$require$getGlobalOrigin","getGlobalOrigin","$2013e7e199fee74d$require$staticPropertyDescriptors","staticPropertyDescriptors","$2013e7e199fee74d$require$states","$6i7JP$pythonversioncheck64bbae24js2","states","$2013e7e199fee74d$require$opcodes","$6i7JP$pythonversioncheck64bbae24js1","opcodes","$2013e7e199fee74d$require$emptyBuffer","$6i7JP$pythonversioncheck64bbae24js","emptyBuffer","$2013e7e199fee74d$require$kWebSocketURL","kWebSocketURL","$2013e7e199fee74d$require$kReadyState","$6i7JP$pythonversioncheckf95b0f32js3","kReadyState","$2013e7e199fee74d$require$kController","$6i7JP$pythonversioncheckf95b0f32js2","kController","$2013e7e199fee74d$require$kBinaryType","$6i7JP$pythonversioncheckf95b0f32js","kBinaryType","$2013e7e199fee74d$require$kResponse","$6i7JP$pythonversioncheckf95b0f32js4","kResponse","$2013e7e199fee74d$require$kSentClose","$6i7JP$pythonversioncheckf95b0f32js5","kSentClose","$2013e7e199fee74d$require$kByteParser","$6i7JP$pythonversioncheckf95b0f32js1","kByteParser","$2013e7e199fee74d$require$isEstablished","$6i7JP$pythonversioncheck92967d43js3","isEstablished","$2013e7e199fee74d$require$isClosing","$6i7JP$pythonversioncheck92967d43js2","isClosing","$2013e7e199fee74d$require$isValidSubprotocol","isValidSubprotocol","$2013e7e199fee74d$require$failWebsocketConnection","$6i7JP$pythonversioncheck92967d43js","failWebsocketConnection","$2013e7e199fee74d$require$fireEvent","$6i7JP$pythonversioncheck92967d43js1","fireEvent","$2013e7e199fee74d$require$establishWebSocketConnection","establishWebSocketConnection","$2013e7e199fee74d$require$WebsocketFrameSend","WebsocketFrameSend","$2013e7e199fee74d$require$ByteParser","ByteParser","$2013e7e199fee74d$require$kEnumerableProperty","kEnumerableProperty","$2013e7e199fee74d$require$isBlobLike","$6i7JP$pythonversioncheck7ed1514ejs","isBlobLike","$2013e7e199fee74d$require$getGlobalDispatcher","getGlobalDispatcher","$2013e7e199fee74d$var$experimentalWarned","$2013e7e199fee74d$var$WebSocket","EventTarget","open","error","close","message","url","protocols","urlRecord","argumentLengthCheck","arguments","header","process","emitWarning","options","converters","USVString","baseURL","URL","e","protocol","hash","href","endsWith","length","Set","map","p","toLowerCase","size","every","response","CONNECTING","reason","brandCheck","undefined","clamp","reasonByteLength","Buffer","byteLength","CLOSING","CLOSED","frame","frameData","allocUnsafe","writeUInt16BE","write","socket","createFrame","CLOSE","send","data","WebSocketSendData","value","from","buffer","TEXT","$2013e7e199fee74d$require$types","isArrayBuffer","BINARY","ArrayBuffer","isView","ab","byteOffset","arrayBuffer","then","readyState","bufferedAmount","extensions","onopen","fn","removeEventListener","addEventListener","onerror","onclose","onmessage","binaryType","type","parser","on","ws","resume","OPEN","headersList","get","prototype","Object","defineProperties","Symbol","toStringTag","writable","enumerable","configurable","sequenceConverter","DOMString","V","util","Type","iterator","WebSocketInit","dictionaryConverter","key","converter","defaultValue","nullableConverter","HeadersInit","Blob","strict","isAnyArrayBuffer","BufferSource","WebSocket"],"version":3,"file":"python-version-check.d1813079.js.map","sourceRoot":"../"}