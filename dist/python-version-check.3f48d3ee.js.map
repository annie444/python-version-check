{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js"],"sourcesContent":["import $asCiI$pythonversioncheck863e006ejs2 from \"./python-version-check.863e006e.js\";\nimport $asCiI$pythonversioncheckb40ebe18js from \"./python-version-check.b40ebe18.js\";\nimport $asCiI$pythonversioncheck7ed1514ejs2 from \"./python-version-check.7ed1514e.js\";\nimport {performance as $asCiI$performance} from \"perf_hooks\";\nimport * as $asCiI$assert from \"assert\";\nimport {isUint8Array as $asCiI$isUint8Array} from \"util/types\";\nimport {ReadableStream as $asCiI$ReadableStream} from \"stream/web\";\n\nvar $d95f1312d796a183$exports = {};\n'use strict';\n\nvar $d95f1312d796a183$require$redirectStatusSet = $asCiI$pythonversioncheck863e006ejs1.redirectStatusSet;\nvar $d95f1312d796a183$require$referrerPolicyTokens = $asCiI$pythonversioncheck863e006ejs2.referrerPolicySet;\nvar $d95f1312d796a183$require$badPortsSet = $asCiI$pythonversioncheck863e006ejs.badPortsSet;\n\nvar $d95f1312d796a183$require$getGlobalOrigin = $asCiI$pythonversioncheckb40ebe18js.getGlobalOrigin;\n\nvar $d95f1312d796a183$require$performance = $asCiI$performance;\n\nvar $d95f1312d796a183$require$isBlobLike = $asCiI$pythonversioncheck7ed1514ejs.isBlobLike;\nvar $d95f1312d796a183$require$toUSVString = $asCiI$pythonversioncheck7ed1514ejs2.toUSVString;\nvar $d95f1312d796a183$require$ReadableStreamFrom = $asCiI$pythonversioncheck7ed1514ejs1.ReadableStreamFrom;\n\n\nvar $d95f1312d796a183$require$isUint8Array = $asCiI$isUint8Array;\nlet $d95f1312d796a183$var$supportedHashes = [];\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */ let $d95f1312d796a183$var$crypto;\n\ntry {\n    $d95f1312d796a183$var$crypto = $d95f1312d796a183$import$2ba574d69762f442;\n    const possibleRelevantHashes = [\n        'sha256',\n        'sha384',\n        'sha512'\n    ];\n    $d95f1312d796a183$var$supportedHashes = $d95f1312d796a183$var$crypto.getHashes().filter((hash)=>possibleRelevantHashes.includes(hash));\n/* c8 ignore next 3 */ } catch  {}\nfunction $d95f1312d796a183$var$responseURL(response) {\n    // https://fetch.spec.whatwg.org/#responses\n    // A response has an associated URL. It is a pointer to the last URL\n    // in response’s URL list and null if response’s URL list is empty.\n    const urlList = response.urlList;\n    const length = urlList.length;\n    return length === 0 ? null : urlList[length - 1].toString();\n}\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction $d95f1312d796a183$var$responseLocationURL(response, requestFragment) {\n    // 1. If response’s status is not a redirect status, then return null.\n    if (!$d95f1312d796a183$require$redirectStatusSet.has(response.status)) return null;\n    // 2. Let location be the result of extracting header list values given\n    // `Location` and response’s header list.\n    let location = response.headersList.get('location');\n    // 3. If location is a header value, then set location to the result of\n    //    parsing location with response’s URL.\n    if (location !== null && $d95f1312d796a183$var$isValidHeaderValue(location)) location = new URL(location, $d95f1312d796a183$var$responseURL(response));\n    // 4. If location is a URL whose fragment is null, then set location’s\n    // fragment to requestFragment.\n    if (location && !location.hash) location.hash = requestFragment;\n    // 5. Return location.\n    return location;\n}\n/** @returns {URL} */ function $d95f1312d796a183$var$requestCurrentURL(request) {\n    return request.urlList[request.urlList.length - 1];\n}\nfunction $d95f1312d796a183$var$requestBadPort(request) {\n    // 1. Let url be request’s current URL.\n    const url = $d95f1312d796a183$var$requestCurrentURL(request);\n    // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n    // then return blocked.\n    if ($d95f1312d796a183$var$urlIsHttpHttpsScheme(url) && $d95f1312d796a183$require$badPortsSet.has(url.port)) return 'blocked';\n    // 3. Return allowed.\n    return 'allowed';\n}\nfunction $d95f1312d796a183$var$isErrorLike(object) {\n    return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';\n}\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction $d95f1312d796a183$var$isValidReasonPhrase(statusText) {\n    for(let i = 0; i < statusText.length; ++i){\n        const c = statusText.charCodeAt(i);\n        if (!(c === 0x09 || // HTAB\n        c >= 0x20 && c <= 0x7e || // SP / VCHAR\n        c >= 0x80 && c <= 0xff // obs-text\n        )) return false;\n    }\n    return true;\n}\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */ function $d95f1312d796a183$var$isTokenCharCode(c) {\n    switch(c){\n        case 0x22:\n        case 0x28:\n        case 0x29:\n        case 0x2c:\n        case 0x2f:\n        case 0x3a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x5b:\n        case 0x5c:\n        case 0x5d:\n        case 0x7b:\n        case 0x7d:\n            // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n            return false;\n        default:\n            // VCHAR %x21-7E\n            return c >= 0x21 && c <= 0x7e;\n    }\n}\n/**\n * @param {string} characters\n */ function $d95f1312d796a183$var$isValidHTTPToken(characters) {\n    if (characters.length === 0) return false;\n    for(let i = 0; i < characters.length; ++i){\n        if (!$d95f1312d796a183$var$isTokenCharCode(characters.charCodeAt(i))) return false;\n    }\n    return true;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */ function $d95f1312d796a183$var$isValidHeaderName(potentialValue) {\n    return $d95f1312d796a183$var$isValidHTTPToken(potentialValue);\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */ function $d95f1312d796a183$var$isValidHeaderValue(potentialValue) {\n    // - Has no leading or trailing HTTP tab or space bytes.\n    // - Contains no 0x00 (NUL) or HTTP newline bytes.\n    if (potentialValue.startsWith('\\t') || potentialValue.startsWith(' ') || potentialValue.endsWith('\\t') || potentialValue.endsWith(' ')) return false;\n    if (potentialValue.includes('\\0') || potentialValue.includes('\\r') || potentialValue.includes('\\n')) return false;\n    return true;\n}\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction $d95f1312d796a183$var$setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n    //  Given a request request and a response actualResponse, this algorithm\n    //  updates request’s referrer policy according to the Referrer-Policy\n    //  header (if any) in actualResponse.\n    // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n    // from a Referrer-Policy header on actualResponse.\n    // 8.1 Parse a referrer policy from a Referrer-Policy header\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n    const { headersList: headersList } = actualResponse;\n    // 2. Let policy be the empty string.\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n    // 4. Return policy.\n    const policyHeader = (headersList.get('referrer-policy') ?? '').split(',');\n    // Note: As the referrer-policy can contain multiple policies\n    // separated by comma, we need to loop through all of them\n    // and pick the first valid one.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n    let policy = '';\n    if (policyHeader.length > 0) // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for(let i = policyHeader.length; i !== 0; i--){\n        const token = policyHeader[i - 1].trim();\n        if ($d95f1312d796a183$require$referrerPolicyTokens.has(token)) {\n            policy = token;\n            break;\n        }\n    }\n    // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n    if (policy !== '') request.referrerPolicy = policy;\n}\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction $d95f1312d796a183$var$crossOriginResourcePolicyCheck() {\n    // TODO\n    return 'allowed';\n}\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction $d95f1312d796a183$var$corsCheck() {\n    // TODO\n    return 'success';\n}\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction $d95f1312d796a183$var$TAOCheck() {\n    // TODO\n    return 'success';\n}\nfunction $d95f1312d796a183$var$appendFetchMetadata(httpRequest) {\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n    //  TODO\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n    //  1. Assert: r’s url is a potentially trustworthy URL.\n    //  TODO\n    //  2. Let header be a Structured Header whose value is a token.\n    let header = null;\n    //  3. Set header’s value to r’s mode.\n    header = httpRequest.mode;\n    //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n    httpRequest.headersList.set('sec-fetch-mode', header);\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n//  TODO\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n//  TODO\n}\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction $d95f1312d796a183$var$appendRequestOriginHeader(request) {\n    // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n    let serializedOrigin = request.origin;\n    // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n    if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n        if (serializedOrigin) request.headersList.append('origin', serializedOrigin);\n    } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n        // 1. Switch on request’s referrer policy:\n        switch(request.referrerPolicy){\n            case 'no-referrer':\n                // Set serializedOrigin to `null`.\n                serializedOrigin = null;\n                break;\n            case 'no-referrer-when-downgrade':\n            case 'strict-origin':\n            case 'strict-origin-when-cross-origin':\n                // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n                if (request.origin && $d95f1312d796a183$var$urlHasHttpsScheme(request.origin) && !$d95f1312d796a183$var$urlHasHttpsScheme($d95f1312d796a183$var$requestCurrentURL(request))) serializedOrigin = null;\n                break;\n            case 'same-origin':\n                // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n                if (!$d95f1312d796a183$var$sameOrigin(request, $d95f1312d796a183$var$requestCurrentURL(request))) serializedOrigin = null;\n                break;\n            default:\n        }\n        if (serializedOrigin) // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n        request.headersList.append('origin', serializedOrigin);\n    }\n}\nfunction $d95f1312d796a183$var$coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n    // TODO\n    return $d95f1312d796a183$require$performance.now();\n}\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction $d95f1312d796a183$var$createOpaqueTimingInfo(timingInfo) {\n    return {\n        startTime: timingInfo.startTime ?? 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: timingInfo.startTime ?? 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction $d95f1312d796a183$var$makePolicyContainer() {\n    // Note: the fetch spec doesn't make use of embedder policy or CSP list\n    return {\n        referrerPolicy: 'strict-origin-when-cross-origin'\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction $d95f1312d796a183$var$clonePolicyContainer(policyContainer) {\n    return {\n        referrerPolicy: policyContainer.referrerPolicy\n    };\n}\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction $d95f1312d796a183$var$determineRequestsReferrer(request) {\n    // 1. Let policy be request's referrer policy.\n    const policy = request.referrerPolicy;\n    // Note: policy cannot (shouldn't) be null or an empty string.\n    $asCiI$assert(policy);\n    // 2. Let environment be request’s client.\n    let referrerSource = null;\n    // 3. Switch on request’s referrer:\n    if (request.referrer === 'client') {\n        // Note: node isn't a browser and doesn't implement document/iframes,\n        // so we bypass this step and replace it with our own.\n        const globalOrigin = $d95f1312d796a183$require$getGlobalOrigin();\n        if (!globalOrigin || globalOrigin.origin === 'null') return 'no-referrer';\n        // note: we need to clone it as it's mutated\n        referrerSource = new URL(globalOrigin);\n    } else if (request.referrer instanceof URL) // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer;\n    // 4. Let request’s referrerURL be the result of stripping referrerSource for\n    //    use as a referrer.\n    let referrerURL = $d95f1312d796a183$var$stripURLForReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n    //    a referrer, with the origin-only flag set to true.\n    const referrerOrigin = $d95f1312d796a183$var$stripURLForReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is\n    //    greater than 4096, set referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;\n    const areSameOrigin = $d95f1312d796a183$var$sameOrigin(request, referrerURL);\n    const isNonPotentiallyTrustWorthy = $d95f1312d796a183$var$isURLPotentiallyTrustworthy(referrerURL) && !$d95f1312d796a183$var$isURLPotentiallyTrustworthy(request.url);\n    // 8. Execute the switch statements corresponding to the value of policy:\n    switch(policy){\n        case 'origin':\n            return referrerOrigin != null ? referrerOrigin : $d95f1312d796a183$var$stripURLForReferrer(referrerSource, true);\n        case 'unsafe-url':\n            return referrerURL;\n        case 'same-origin':\n            return areSameOrigin ? referrerOrigin : 'no-referrer';\n        case 'origin-when-cross-origin':\n            return areSameOrigin ? referrerURL : referrerOrigin;\n        case 'strict-origin-when-cross-origin':\n            {\n                const currentURL = $d95f1312d796a183$var$requestCurrentURL(request);\n                // 1. If the origin of referrerURL and the origin of request’s current\n                //    URL are the same, then return referrerURL.\n                if ($d95f1312d796a183$var$sameOrigin(referrerURL, currentURL)) return referrerURL;\n                // 2. If referrerURL is a potentially trustworthy URL and request’s\n                //    current URL is not a potentially trustworthy URL, then return no\n                //    referrer.\n                if ($d95f1312d796a183$var$isURLPotentiallyTrustworthy(referrerURL) && !$d95f1312d796a183$var$isURLPotentiallyTrustworthy(currentURL)) return 'no-referrer';\n                // 3. Return referrerOrigin.\n                return referrerOrigin;\n            }\n        case 'strict-origin':\n        /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */ case 'no-referrer-when-downgrade':\n        /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */ default:\n            return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */ function $d95f1312d796a183$var$stripURLForReferrer(url, originOnly) {\n    // 1. Assert: url is a URL.\n    $asCiI$assert(url instanceof URL);\n    // 2. If url’s scheme is a local scheme, then return no referrer.\n    if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') return 'no-referrer';\n    // 3. Set url’s username to the empty string.\n    url.username = '';\n    // 4. Set url’s password to the empty string.\n    url.password = '';\n    // 5. Set url’s fragment to null.\n    url.hash = '';\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 1. Set url’s path to « the empty string ».\n        url.pathname = '';\n        // 2. Set url’s query to null.\n        url.search = '';\n    }\n    // 7. Return url.\n    return url;\n}\nfunction $d95f1312d796a183$var$isURLPotentiallyTrustworthy(url) {\n    if (!(url instanceof URL)) return false;\n    // If child of about, return true\n    if (url.href === 'about:blank' || url.href === 'about:srcdoc') return true;\n    // If scheme is data, return true\n    if (url.protocol === 'data:') return true;\n    // If file, return true\n    if (url.protocol === 'file:') return true;\n    return isOriginPotentiallyTrustworthy(url.origin);\n    function isOriginPotentiallyTrustworthy(origin) {\n        // If origin is explicitly null, return false\n        if (origin == null || origin === 'null') return false;\n        const originAsURL = new URL(origin);\n        // If secure, return true\n        if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') return true;\n        // If localhost or variants, return true\n        if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) return true;\n        // If any other, return false\n        return false;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */ function $d95f1312d796a183$var$bytesMatch(bytes, metadataList) {\n    // If node is not built with OpenSSL support, we cannot check\n    // a request's integrity, so allow it by default (the spec will\n    // allow requests if an invalid hash is given, as precedence).\n    /* istanbul ignore if: only if node is built with --without-ssl */ if ($d95f1312d796a183$var$crypto === undefined) return true;\n    // 1. Let parsedMetadata be the result of parsing metadataList.\n    const parsedMetadata = $d95f1312d796a183$var$parseMetadata(metadataList);\n    // 2. If parsedMetadata is no metadata, return true.\n    if (parsedMetadata === 'no metadata') return true;\n    // 3. If response is not eligible for integrity validation, return false.\n    // TODO\n    // 4. If parsedMetadata is the empty set, return true.\n    if (parsedMetadata.length === 0) return true;\n    // 5. Let metadata be the result of getting the strongest\n    //    metadata from parsedMetadata.\n    const strongest = $d95f1312d796a183$var$getStrongestMetadata(parsedMetadata);\n    const metadata = $d95f1312d796a183$var$filterMetadataListByAlgorithm(parsedMetadata, strongest);\n    // 6. For each item in metadata:\n    for (const item of metadata){\n        // 1. Let algorithm be the alg component of item.\n        const algorithm = item.algo;\n        // 2. Let expectedValue be the val component of item.\n        const expectedValue = item.hash;\n        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n        // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n        // 3. Let actualValue be the result of applying algorithm to bytes.\n        let actualValue = $d95f1312d796a183$var$crypto.createHash(algorithm).update(bytes).digest('base64');\n        if (actualValue[actualValue.length - 1] === '=') {\n            if (actualValue[actualValue.length - 2] === '=') actualValue = actualValue.slice(0, -2);\n            else actualValue = actualValue.slice(0, -1);\n        }\n        // 4. If actualValue is a case-sensitive match for expectedValue,\n        //    return true.\n        if ($d95f1312d796a183$var$compareBase64Mixed(actualValue, expectedValue)) return true;\n    }\n    // 7. Return false.\n    return false;\n}\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst $d95f1312d796a183$var$parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i;\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */ function $d95f1312d796a183$var$parseMetadata(metadata) {\n    // 1. Let result be the empty set.\n    /** @type {{ algo: string, hash: string }[]} */ const result = [];\n    // 2. Let empty be equal to true.\n    let empty = true;\n    // 3. For each token returned by splitting metadata on spaces:\n    for (const token of metadata.split(' ')){\n        // 1. Set empty to false.\n        empty = false;\n        // 2. Parse token as a hash-with-options.\n        const parsedToken = $d95f1312d796a183$var$parseHashWithOptions.exec(token);\n        // 3. If token does not parse, continue to the next token.\n        if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) continue;\n        // 4. Let algorithm be the hash-algo component of token.\n        const algorithm = parsedToken.groups.algo.toLowerCase();\n        // 5. If algorithm is a hash function recognized by the user\n        //    agent, add the parsed token to result.\n        if ($d95f1312d796a183$var$supportedHashes.includes(algorithm)) result.push(parsedToken.groups);\n    }\n    // 4. Return no metadata if empty is true, otherwise return result.\n    if (empty === true) return 'no metadata';\n    return result;\n}\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */ function $d95f1312d796a183$var$getStrongestMetadata(metadataList) {\n    // Let algorithm be the algo component of the first item in metadataList.\n    // Can be sha256\n    let algorithm = metadataList[0].algo;\n    // If the algorithm is sha512, then it is the strongest\n    // and we can return immediately\n    if (algorithm[3] === '5') return algorithm;\n    for(let i = 1; i < metadataList.length; ++i){\n        const metadata = metadataList[i];\n        // If the algorithm is sha512, then it is the strongest\n        // and we can break the loop immediately\n        if (metadata.algo[3] === '5') {\n            algorithm = 'sha512';\n            break;\n        // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n        } else if (algorithm[3] === '3') continue;\n        else if (metadata.algo[3] === '3') algorithm = 'sha384';\n    }\n    return algorithm;\n}\nfunction $d95f1312d796a183$var$filterMetadataListByAlgorithm(metadataList, algorithm) {\n    if (metadataList.length === 1) return metadataList;\n    let pos = 0;\n    for(let i = 0; i < metadataList.length; ++i)if (metadataList[i].algo === algorithm) metadataList[pos++] = metadataList[i];\n    metadataList.length = pos;\n    return metadataList;\n}\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */ function $d95f1312d796a183$var$compareBase64Mixed(actualValue, expectedValue) {\n    if (actualValue.length !== expectedValue.length) return false;\n    for(let i = 0; i < actualValue.length; ++i)if (actualValue[i] !== expectedValue[i]) {\n        if (actualValue[i] === '+' && expectedValue[i] === '-' || actualValue[i] === '/' && expectedValue[i] === '_') continue;\n        return false;\n    }\n    return true;\n}\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction $d95f1312d796a183$var$tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n// TODO\n}\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */ function $d95f1312d796a183$var$sameOrigin(A, B) {\n    // 1. If A and B are the same opaque origin, then return true.\n    if (A.origin === B.origin && A.origin === 'null') return true;\n    // 2. If A and B are both tuple origins and their schemes,\n    //    hosts, and port are identical, then return true.\n    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) return true;\n    // 3. Return false.\n    return false;\n}\nfunction $d95f1312d796a183$var$createDeferredPromise() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    return {\n        promise: promise,\n        resolve: res,\n        reject: rej\n    };\n}\nfunction $d95f1312d796a183$var$isAborted(fetchParams) {\n    return fetchParams.controller.state === 'aborted';\n}\nfunction $d95f1312d796a183$var$isCancelled(fetchParams) {\n    return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';\n}\nconst $d95f1312d796a183$var$normalizeMethodRecord = {\n    delete: 'DELETE',\n    DELETE: 'DELETE',\n    get: 'GET',\n    GET: 'GET',\n    head: 'HEAD',\n    HEAD: 'HEAD',\n    options: 'OPTIONS',\n    OPTIONS: 'OPTIONS',\n    post: 'POST',\n    POST: 'POST',\n    put: 'PUT',\n    PUT: 'PUT'\n};\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf($d95f1312d796a183$var$normalizeMethodRecord, null);\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */ function $d95f1312d796a183$var$normalizeMethod(method) {\n    return $d95f1312d796a183$var$normalizeMethodRecord[method.toLowerCase()] ?? method;\n}\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction $d95f1312d796a183$var$serializeJavascriptValueToJSONString(value) {\n    // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n    const result = JSON.stringify(value);\n    // 2. If result is undefined, then throw a TypeError.\n    if (result === undefined) throw new TypeError('Value is not JSON serializable');\n    // 3. Assert: result is a string.\n    $asCiI$assert(typeof result === 'string');\n    // 4. Return result.\n    return result;\n}\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst $d95f1312d796a183$var$esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */ function $d95f1312d796a183$var$makeIterator(iterator, name, kind) {\n    const object = {\n        index: 0,\n        kind: kind,\n        target: iterator\n    };\n    const i = {\n        next () {\n            // 1. Let interface be the interface for which the iterator prototype object exists.\n            // 2. Let thisValue be the this value.\n            // 3. Let object be ? ToObject(thisValue).\n            // 4. If object is a platform object, then perform a security\n            //    check, passing:\n            // 5. If object is not a default iterator object for interface,\n            //    then throw a TypeError.\n            if (Object.getPrototypeOf(this) !== i) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n            // 6. Let index be object’s index.\n            // 7. Let kind be object’s kind.\n            // 8. Let values be object’s target's value pairs to iterate over.\n            const { index: index, kind: kind, target: target } = object;\n            const values = target();\n            // 9. Let len be the length of values.\n            const len = values.length;\n            // 10. If index is greater than or equal to len, then return\n            //     CreateIterResultObject(undefined, true).\n            if (index >= len) return {\n                value: undefined,\n                done: true\n            };\n            // 11. Let pair be the entry in values at index index.\n            const pair = values[index];\n            // 12. Set object’s index to index + 1.\n            object.index = index + 1;\n            // 13. Return the iterator result for pair and kind.\n            return $d95f1312d796a183$var$iteratorResult(pair, kind);\n        },\n        // The class string of an iterator prototype object for a given interface is the\n        // result of concatenating the identifier of the interface and the string \" Iterator\".\n        [Symbol.toStringTag]: `${name} Iterator`\n    };\n    // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n    Object.setPrototypeOf(i, $d95f1312d796a183$var$esIteratorPrototype);\n    // esIteratorPrototype needs to be the prototype of i\n    // which is the prototype of an empty object. Yes, it's confusing.\n    return Object.setPrototypeOf({}, i);\n}\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction $d95f1312d796a183$var$iteratorResult(pair, kind) {\n    let result;\n    // 1. Let result be a value determined by the value of kind:\n    switch(kind){\n        case 'key':\n            // 1. Let idlKey be pair’s key.\n            // 2. Let key be the result of converting idlKey to an\n            //    ECMAScript value.\n            // 3. result is key.\n            result = pair[0];\n            break;\n        case 'value':\n            // 1. Let idlValue be pair’s value.\n            // 2. Let value be the result of converting idlValue to\n            //    an ECMAScript value.\n            // 3. result is value.\n            result = pair[1];\n            break;\n        case 'key+value':\n            // 1. Let idlKey be pair’s key.\n            // 2. Let idlValue be pair’s value.\n            // 3. Let key be the result of converting idlKey to an\n            //    ECMAScript value.\n            // 4. Let value be the result of converting idlValue to\n            //    an ECMAScript value.\n            // 5. Let array be ! ArrayCreate(2).\n            // 6. Call ! CreateDataProperty(array, \"0\", key).\n            // 7. Call ! CreateDataProperty(array, \"1\", value).\n            // 8. result is array.\n            result = pair;\n            break;\n    }\n    // 2. Return CreateIterResultObject(result, false).\n    return {\n        value: result,\n        done: false\n    };\n}\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */ async function $d95f1312d796a183$var$fullyReadBody(body, processBody, processBodyError) {\n    // 1. If taskDestination is null, then set taskDestination to\n    //    the result of starting a new parallel queue.\n    // 2. Let successSteps given a byte sequence bytes be to queue a\n    //    fetch task to run processBody given bytes, with taskDestination.\n    const successSteps = processBody;\n    // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n    //    with taskDestination.\n    const errorSteps = processBodyError;\n    // 4. Let reader be the result of getting a reader for body’s stream.\n    //    If that threw an exception, then run errorSteps with that\n    //    exception and return.\n    let reader;\n    try {\n        reader = body.stream.getReader();\n    } catch (e) {\n        errorSteps(e);\n        return;\n    }\n    // 5. Read all bytes from reader, given successSteps and errorSteps.\n    try {\n        const result = await $d95f1312d796a183$var$readAllBytes(reader);\n        successSteps(result);\n    } catch (e) {\n        errorSteps(e);\n    }\n}\n/** @type {ReadableStream} */ let $d95f1312d796a183$var$ReadableStream = globalThis.ReadableStream;\n\nfunction $d95f1312d796a183$var$isReadableStreamLike(stream) {\n    if (!$d95f1312d796a183$var$ReadableStream) $d95f1312d796a183$var$ReadableStream = $asCiI$ReadableStream;\n    return stream instanceof $d95f1312d796a183$var$ReadableStream || stream[Symbol.toStringTag] === 'ReadableStream' && typeof stream.tee === 'function';\n}\nconst $d95f1312d796a183$var$MAXIMUM_ARGUMENT_LENGTH = 65535;\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */ function $d95f1312d796a183$var$isomorphicDecode(input) {\n    // 1. To isomorphic decode a byte sequence input, return a string whose code point\n    //    length is equal to input’s length and whose code points have the same values\n    //    as the values of input’s bytes, in the same order.\n    if (input.length < $d95f1312d796a183$var$MAXIMUM_ARGUMENT_LENGTH) return String.fromCharCode(...input);\n    return input.reduce((previous, current)=>previous + String.fromCharCode(current), '');\n}\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */ function $d95f1312d796a183$var$readableStreamClose(controller) {\n    try {\n        controller.close();\n    } catch (err) {\n        // TODO: add comment explaining why this error occurs.\n        if (!err.message.includes('Controller is already closed')) throw err;\n    }\n}\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */ function $d95f1312d796a183$var$isomorphicEncode(input) {\n    // 1. Assert: input contains no code points greater than U+00FF.\n    for(let i = 0; i < input.length; i++)$asCiI$assert(input.charCodeAt(i) <= 0xFF);\n    // 2. Return a byte sequence whose length is equal to input’s code\n    //    point length and whose bytes have the same values as the\n    //    values of input’s code points, in the same order\n    return input;\n}\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */ async function $d95f1312d796a183$var$readAllBytes(reader) {\n    const bytes = [];\n    let byteLength = 0;\n    while(true){\n        const { done: done, value: chunk } = await reader.read();\n        if (done) // 1. Call successSteps with bytes.\n        return Buffer.concat(bytes, byteLength);\n        // 1. If chunk is not a Uint8Array object, call failureSteps\n        //    with a TypeError and abort these steps.\n        if (!$d95f1312d796a183$require$isUint8Array(chunk)) throw new TypeError('Received non-Uint8Array chunk');\n        // 2. Append the bytes represented by chunk to bytes.\n        bytes.push(chunk);\n        byteLength += chunk.length;\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */ function $d95f1312d796a183$var$urlIsLocal(url) {\n    $asCiI$assert('protocol' in url) // ensure it's a url object\n    ;\n    const protocol = url.protocol;\n    return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:';\n}\n/**\n * @param {string|URL} url\n */ function $d95f1312d796a183$var$urlHasHttpsScheme(url) {\n    if (typeof url === 'string') return url.startsWith('https:');\n    return url.protocol === 'https:';\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */ function $d95f1312d796a183$var$urlIsHttpHttpsScheme(url) {\n    $asCiI$assert('protocol' in url) // ensure it's a url object\n    ;\n    const protocol = url.protocol;\n    return protocol === 'http:' || protocol === 'https:';\n}\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */ const $d95f1312d796a183$var$hasOwn = Object.hasOwn || ((dict, key)=>Object.prototype.hasOwnProperty.call(dict, key));\n$d95f1312d796a183$exports = {\n    isAborted: $d95f1312d796a183$var$isAborted,\n    isCancelled: $d95f1312d796a183$var$isCancelled,\n    createDeferredPromise: $d95f1312d796a183$var$createDeferredPromise,\n    ReadableStreamFrom: $d95f1312d796a183$require$ReadableStreamFrom,\n    toUSVString: $d95f1312d796a183$require$toUSVString,\n    tryUpgradeRequestToAPotentiallyTrustworthyURL: $d95f1312d796a183$var$tryUpgradeRequestToAPotentiallyTrustworthyURL,\n    coarsenedSharedCurrentTime: $d95f1312d796a183$var$coarsenedSharedCurrentTime,\n    determineRequestsReferrer: $d95f1312d796a183$var$determineRequestsReferrer,\n    makePolicyContainer: $d95f1312d796a183$var$makePolicyContainer,\n    clonePolicyContainer: $d95f1312d796a183$var$clonePolicyContainer,\n    appendFetchMetadata: $d95f1312d796a183$var$appendFetchMetadata,\n    appendRequestOriginHeader: $d95f1312d796a183$var$appendRequestOriginHeader,\n    TAOCheck: $d95f1312d796a183$var$TAOCheck,\n    corsCheck: $d95f1312d796a183$var$corsCheck,\n    crossOriginResourcePolicyCheck: $d95f1312d796a183$var$crossOriginResourcePolicyCheck,\n    createOpaqueTimingInfo: $d95f1312d796a183$var$createOpaqueTimingInfo,\n    setRequestReferrerPolicyOnRedirect: $d95f1312d796a183$var$setRequestReferrerPolicyOnRedirect,\n    isValidHTTPToken: $d95f1312d796a183$var$isValidHTTPToken,\n    requestBadPort: $d95f1312d796a183$var$requestBadPort,\n    requestCurrentURL: $d95f1312d796a183$var$requestCurrentURL,\n    responseURL: $d95f1312d796a183$var$responseURL,\n    responseLocationURL: $d95f1312d796a183$var$responseLocationURL,\n    isBlobLike: $d95f1312d796a183$require$isBlobLike,\n    isURLPotentiallyTrustworthy: $d95f1312d796a183$var$isURLPotentiallyTrustworthy,\n    isValidReasonPhrase: $d95f1312d796a183$var$isValidReasonPhrase,\n    sameOrigin: $d95f1312d796a183$var$sameOrigin,\n    normalizeMethod: $d95f1312d796a183$var$normalizeMethod,\n    serializeJavascriptValueToJSONString: $d95f1312d796a183$var$serializeJavascriptValueToJSONString,\n    makeIterator: $d95f1312d796a183$var$makeIterator,\n    isValidHeaderName: $d95f1312d796a183$var$isValidHeaderName,\n    isValidHeaderValue: $d95f1312d796a183$var$isValidHeaderValue,\n    hasOwn: $d95f1312d796a183$var$hasOwn,\n    isErrorLike: $d95f1312d796a183$var$isErrorLike,\n    fullyReadBody: $d95f1312d796a183$var$fullyReadBody,\n    bytesMatch: $d95f1312d796a183$var$bytesMatch,\n    isReadableStreamLike: $d95f1312d796a183$var$isReadableStreamLike,\n    readableStreamClose: $d95f1312d796a183$var$readableStreamClose,\n    isomorphicEncode: $d95f1312d796a183$var$isomorphicEncode,\n    isomorphicDecode: $d95f1312d796a183$var$isomorphicDecode,\n    urlIsLocal: $d95f1312d796a183$var$urlIsLocal,\n    urlHasHttpsScheme: $d95f1312d796a183$var$urlHasHttpsScheme,\n    urlIsHttpHttpsScheme: $d95f1312d796a183$var$urlIsHttpHttpsScheme,\n    readAllBytes: $d95f1312d796a183$var$readAllBytes,\n    normalizeMethodRecord: $d95f1312d796a183$var$normalizeMethodRecord,\n    parseMetadata: $d95f1312d796a183$var$parseMetadata\n};\n\n\nexport {$d95f1312d796a183$exports as default};\n//# sourceMappingURL=python-version-check.3f48d3ee.js.map\n","'use strict'\n\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require('./constants')\nconst { getGlobalOrigin } = require('./global')\nconst { performance } = require('perf_hooks')\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = require('../core/util')\nconst assert = require('assert')\nconst { isUint8Array } = require('util/types')\n\nlet supportedHashes = []\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto\n\ntry {\n  crypto = require('crypto')\n  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512']\n  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash))\n/* c8 ignore next 3 */\n} catch {\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */\nfunction isTokenCharCode (c) {\n  switch (c) {\n    case 0x22:\n    case 0x28:\n    case 0x29:\n    case 0x2c:\n    case 0x2f:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x7b:\n    case 0x7d:\n      // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n      return false\n    default:\n      // VCHAR %x21-7E\n      return c >= 0x21 && c <= 0x7e\n  }\n}\n\n/**\n * @param {string} characters\n */\nfunction isValidHTTPToken (characters) {\n  if (characters.length === 0) {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    if (!isTokenCharCode(characters.charCodeAt(i))) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nfunction isValidHeaderName (potentialValue) {\n  return isValidHTTPToken(potentialValue)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (\n    potentialValue.startsWith('\\t') ||\n    potentialValue.startsWith(' ') ||\n    potentialValue.endsWith('\\t') ||\n    potentialValue.endsWith(' ')\n  ) {\n    return false\n  }\n\n  if (\n    potentialValue.includes('\\0') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\n')\n  ) {\n    return false\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('origin', serializedOrigin)\n    }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  const areSameOrigin = sameOrigin(request, referrerURL)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerURL\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of request’s current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer (url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL)\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer'\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = ''\n\n  // 4. Set url’s password to the empty string.\n  url.password = ''\n\n  // 5. Set url’s fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = ''\n\n    // 2. Set url’s query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If response is not eligible for integrity validation, return false.\n  // TODO\n\n  // 4. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 5. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const strongest = getStrongestMetadata(parsedMetadata)\n  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest)\n\n  // 6. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    if (actualValue[actualValue.length - 1] === '=') {\n      if (actualValue[actualValue.length - 2] === '=') {\n        actualValue = actualValue.slice(0, -2)\n      } else {\n        actualValue = actualValue.slice(0, -1)\n      }\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (compareBase64Mixed(actualValue, expectedValue)) {\n      return true\n    }\n  }\n\n  // 7. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (\n      parsedToken === null ||\n      parsedToken.groups === undefined ||\n      parsedToken.groups.algo === undefined\n    ) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo.toLowerCase()\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm)) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */\nfunction getStrongestMetadata (metadataList) {\n  // Let algorithm be the algo component of the first item in metadataList.\n  // Can be sha256\n  let algorithm = metadataList[0].algo\n  // If the algorithm is sha512, then it is the strongest\n  // and we can return immediately\n  if (algorithm[3] === '5') {\n    return algorithm\n  }\n\n  for (let i = 1; i < metadataList.length; ++i) {\n    const metadata = metadataList[i]\n    // If the algorithm is sha512, then it is the strongest\n    // and we can break the loop immediately\n    if (metadata.algo[3] === '5') {\n      algorithm = 'sha512'\n      break\n    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n    } else if (algorithm[3] === '3') {\n      continue\n    // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n    // the strongest\n    } else if (metadata.algo[3] === '3') {\n      algorithm = 'sha384'\n    }\n  }\n  return algorithm\n}\n\nfunction filterMetadataListByAlgorithm (metadataList, algorithm) {\n  if (metadataList.length === 1) {\n    return metadataList\n  }\n\n  let pos = 0\n  for (let i = 0; i < metadataList.length; ++i) {\n    if (metadataList[i].algo === algorithm) {\n      metadataList[pos++] = metadataList[i]\n    }\n  }\n\n  metadataList.length = pos\n\n  return metadataList\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */\nfunction compareBase64Mixed (actualValue, expectedValue) {\n  if (actualValue.length !== expectedValue.length) {\n    return false\n  }\n  for (let i = 0; i < actualValue.length; ++i) {\n    if (actualValue[i] !== expectedValue[i]) {\n      if (\n        (actualValue[i] === '+' && expectedValue[i] === '-') ||\n        (actualValue[i] === '/' && expectedValue[i] === '_')\n      ) {\n        continue\n      }\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\nconst normalizeMethodRecord = {\n  delete: 'DELETE',\n  DELETE: 'DELETE',\n  get: 'GET',\n  GET: 'GET',\n  head: 'HEAD',\n  HEAD: 'HEAD',\n  options: 'OPTIONS',\n  OPTIONS: 'OPTIONS',\n  post: 'POST',\n  POST: 'POST',\n  put: 'PUT',\n  PUT: 'PUT'\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizeMethodRecord, null)\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizeMethodRecord[method.toLowerCase()] ?? method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */\nfunction makeIterator (iterator, name, kind) {\n  const object = {\n    index: 0,\n    kind,\n    target: iterator\n  }\n\n  const i = {\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n\n      // 2. Let thisValue be the this value.\n\n      // 3. Let object be ? ToObject(thisValue).\n\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const { index, kind, target } = object\n      const values = target()\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return { value: undefined, done: true }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const pair = values[index]\n\n      // 12. Set object’s index to index + 1.\n      object.index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n      return iteratorResult(pair, kind)\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  }\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype)\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i)\n}\n\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult (pair, kind) {\n  let result\n\n  // 1. Let result be a value determined by the value of kind:\n  switch (kind) {\n    case 'key': {\n      // 1. Let idlKey be pair’s key.\n      // 2. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 3. result is key.\n      result = pair[0]\n      break\n    }\n    case 'value': {\n      // 1. Let idlValue be pair’s value.\n      // 2. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 3. result is value.\n      result = pair[1]\n      break\n    }\n    case 'key+value': {\n      // 1. Let idlKey be pair’s key.\n      // 2. Let idlValue be pair’s value.\n      // 3. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 4. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 5. Let array be ! ArrayCreate(2).\n      // 6. Call ! CreateDataProperty(array, \"0\", key).\n      // 7. Call ! CreateDataProperty(array, \"1\", value).\n      // 8. result is array.\n      result = pair\n      break\n    }\n  }\n\n  // 2. Return CreateIterResultObject(result, false).\n  return { value: result, done: false }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    const result = await readAllBytes(reader)\n    successSteps(result)\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\n/** @type {ReadableStream} */\nlet ReadableStream = globalThis.ReadableStream\n\nfunction isReadableStreamLike (stream) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\nconst MAXIMUM_ARGUMENT_LENGTH = 65535\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n\n  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n    return String.fromCharCode(...input)\n  }\n\n  return input.reduce((previous, current) => previous + String.fromCharCode(current), '')\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed')) {\n      throw err\n    }\n  }\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  for (let i = 0; i < input.length; i++) {\n    assert(input.charCodeAt(i) <= 0xFF)\n  }\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes (reader) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    const { done, value: chunk } = await reader.read()\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength)\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk')\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n */\nfunction urlHasHttpsScheme (url) {\n  if (typeof url === 'string') {\n    return url.startsWith('https:')\n  }\n\n  return url.protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  isomorphicDecode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  normalizeMethodRecord,\n  parseMetadata\n}\n"],"names":["$d95f1312d796a183$var$crypto","$asCiI$pythonversioncheck863e006ejs2","$asCiI$pythonversioncheckb40ebe18js","$asCiI$pythonversioncheck7ed1514ejs2","performance","$asCiI$performance","$asCiI$assert","isUint8Array","$asCiI$isUint8Array","ReadableStream","$asCiI$ReadableStream","$d95f1312d796a183$exports","$d95f1312d796a183$require$redirectStatusSet","$asCiI$pythonversioncheck863e006ejs1","redirectStatusSet","$d95f1312d796a183$require$referrerPolicyTokens","referrerPolicySet","$d95f1312d796a183$require$badPortsSet","$asCiI$pythonversioncheck863e006ejs","badPortsSet","$d95f1312d796a183$require$getGlobalOrigin","getGlobalOrigin","$d95f1312d796a183$require$isBlobLike","$asCiI$pythonversioncheck7ed1514ejs","isBlobLike","$d95f1312d796a183$require$toUSVString","toUSVString","$d95f1312d796a183$require$ReadableStreamFrom","$asCiI$pythonversioncheck7ed1514ejs1","ReadableStreamFrom","$d95f1312d796a183$var$supportedHashes","$d95f1312d796a183$import$2ba574d69762f442","possibleRelevantHashes","getHashes","filter","hash","includes","$d95f1312d796a183$var$responseURL","response","urlList","length","toString","$d95f1312d796a183$var$requestCurrentURL","request","$d95f1312d796a183$var$isValidHTTPToken","characters","i","$d95f1312d796a183$var$isTokenCharCode","c","charCodeAt","$d95f1312d796a183$var$isValidHeaderValue","potentialValue","startsWith","endsWith","$d95f1312d796a183$var$stripURLForReferrer","url","originOnly","URL","protocol","username","password","pathname","search","$d95f1312d796a183$var$isURLPotentiallyTrustworthy","href","isOriginPotentiallyTrustworthy","origin","originAsURL","test","hostname","$d95f1312d796a183$var$parseHashWithOptions","$d95f1312d796a183$var$parseMetadata","metadata","result","empty","token","split","parsedToken","exec","undefined","groups","algo","algorithm","toLowerCase","push","$d95f1312d796a183$var$sameOrigin","A","B","port","$d95f1312d796a183$var$normalizeMethodRecord","delete","DELETE","get","GET","head","HEAD","options","OPTIONS","post","POST","put","PUT","Object","setPrototypeOf","$d95f1312d796a183$var$esIteratorPrototype","getPrototypeOf","Symbol","iterator","$d95f1312d796a183$var$ReadableStream","globalThis","$d95f1312d796a183$var$readAllBytes","reader","bytes","byteLength","done","value","chunk","read","Buffer","concat","$d95f1312d796a183$require$isUint8Array","TypeError","$d95f1312d796a183$var$urlHasHttpsScheme","$d95f1312d796a183$var$urlIsHttpHttpsScheme","isAborted","fetchParams","controller","state","isCancelled","createDeferredPromise","res","rej","promise","Promise","resolve","reject","tryUpgradeRequestToAPotentiallyTrustworthyURL","coarsenedSharedCurrentTime","crossOriginIsolatedCapability","$d95f1312d796a183$require$performance","now","determineRequestsReferrer","policy","referrerPolicy","referrerSource","referrer","globalOrigin","referrerURL","referrerOrigin","areSameOrigin","isNonPotentiallyTrustWorthy","currentURL","makePolicyContainer","clonePolicyContainer","policyContainer","appendFetchMetadata","httpRequest","header","mode","headersList","set","appendRequestOriginHeader","serializedOrigin","responseTainting","append","method","TAOCheck","corsCheck","crossOriginResourcePolicyCheck","createOpaqueTimingInfo","timingInfo","startTime","redirectStartTime","redirectEndTime","postRedirectStartTime","finalServiceWorkerStartTime","finalNetworkResponseStartTime","finalNetworkRequestStartTime","endTime","encodedBodySize","decodedBodySize","finalConnectionTimingInfo","setRequestReferrerPolicyOnRedirect","actualResponse","policyHeader","trim","has","isValidHTTPToken","requestBadPort","requestCurrentURL","responseURL","responseLocationURL","requestFragment","status","location","isURLPotentiallyTrustworthy","isValidReasonPhrase","statusText","sameOrigin","normalizeMethod","serializeJavascriptValueToJSONString","JSON","stringify","makeIterator","name","kind","object","index","target","next","values","pair","$d95f1312d796a183$var$iteratorResult","toStringTag","isValidHeaderName","isValidHeaderValue","hasOwn","dict","key","prototype","hasOwnProperty","call","isErrorLike","Error","fullyReadBody","$d95f1312d796a183$var$fullyReadBody","body","processBody","processBodyError","stream","getReader","e","errorSteps","successSteps","bytesMatch","metadataList","parsedMetadata","strongest","$d95f1312d796a183$var$getStrongestMetadata","item","$d95f1312d796a183$var$filterMetadataListByAlgorithm","pos","expectedValue","actualValue","createHash","update","digest","slice","$d95f1312d796a183$var$compareBase64Mixed","isReadableStreamLike","tee","readableStreamClose","close","err","message","isomorphicEncode","input","isomorphicDecode","String","fromCharCode","reduce","previous","current","urlIsLocal","urlHasHttpsScheme","urlIsHttpHttpsScheme","readAllBytes","normalizeMethodRecord","parseMetadata","default"],"version":3,"file":"python-version-check.3f48d3ee.js.map","sourceRoot":"../"}