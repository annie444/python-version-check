{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js"],"sourcesContent":["import $rAjBc$pythonversioncheck7ed1514ejs1 from \"./python-version-check.7ed1514e.js\";\nimport $rAjBc$pythonversioncheckdba5a2d4js1 from \"./python-version-check.dba5a2d4.js\";\nimport {connect as $rAjBc$connect} from \"net\";\nimport * as $rAjBc$assert from \"assert\";\nimport * as $rAjBc$tls from \"tls\";\n\n\n      var $parcel$global = globalThis;\n    var $fae8d706d85bf84a$exports = {};\n'use strict';\n\n\n\n\nvar $fae8d706d85bf84a$require$InvalidArgumentError = $rAjBc$pythonversioncheckdba5a2d4js1.InvalidArgumentError;\nvar $fae8d706d85bf84a$require$ConnectTimeoutError = $rAjBc$pythonversioncheckdba5a2d4js.ConnectTimeoutError;\nlet $fae8d706d85bf84a$var$tls // include tls conditionally since it is not always available\n;\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\nlet $fae8d706d85bf84a$var$SessionCache;\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif ($parcel$global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) $fae8d706d85bf84a$var$SessionCache = class WeakSessionCache {\n    constructor(maxCachedSessions){\n        this._maxCachedSessions = maxCachedSessions;\n        this._sessionCache = new Map();\n        this._sessionRegistry = new $parcel$global.FinalizationRegistry((key)=>{\n            if (this._sessionCache.size < this._maxCachedSessions) return;\n            const ref = this._sessionCache.get(key);\n            if (ref !== undefined && ref.deref() === undefined) this._sessionCache.delete(key);\n        });\n    }\n    get(sessionKey) {\n        const ref = this._sessionCache.get(sessionKey);\n        return ref ? ref.deref() : null;\n    }\n    set(sessionKey, session) {\n        if (this._maxCachedSessions === 0) return;\n        this._sessionCache.set(sessionKey, new WeakRef(session));\n        this._sessionRegistry.register(session, sessionKey);\n    }\n};\nelse $fae8d706d85bf84a$var$SessionCache = class SimpleSessionCache {\n    constructor(maxCachedSessions){\n        this._maxCachedSessions = maxCachedSessions;\n        this._sessionCache = new Map();\n    }\n    get(sessionKey) {\n        return this._sessionCache.get(sessionKey);\n    }\n    set(sessionKey, session) {\n        if (this._maxCachedSessions === 0) return;\n        if (this._sessionCache.size >= this._maxCachedSessions) {\n            // remove the oldest session\n            const { value: oldestKey } = this._sessionCache.keys().next();\n            this._sessionCache.delete(oldestKey);\n        }\n        this._sessionCache.set(sessionKey, session);\n    }\n};\n\nfunction $fae8d706d85bf84a$var$buildConnector({ allowH2: allowH2, maxCachedSessions: maxCachedSessions, socketPath: socketPath, timeout: timeout, ...opts }) {\n    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new $fae8d706d85bf84a$require$InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n    const options = {\n        path: socketPath,\n        ...opts\n    };\n    const sessionCache = new $fae8d706d85bf84a$var$SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n    timeout = timeout == null ? 10e3 : timeout;\n    allowH2 = allowH2 != null ? allowH2 : false;\n    return function connect({ hostname: hostname, host: host, protocol: protocol, port: port, servername: servername, localAddress: localAddress, httpSocket: httpSocket }, callback) {\n        let socket;\n        if (protocol === 'https:') {\n            if (!$fae8d706d85bf84a$var$tls) $fae8d706d85bf84a$var$tls = $rAjBc$tls;\n            servername = servername || options.servername || $rAjBc$pythonversioncheck7ed1514ejs1.getServerName(host) || null;\n            const sessionKey = servername || hostname;\n            const session = sessionCache.get(sessionKey) || null;\n            $rAjBc$assert(sessionKey);\n            socket = $fae8d706d85bf84a$var$tls.connect({\n                highWaterMark: 16384,\n                ...options,\n                servername: servername,\n                session: session,\n                localAddress: localAddress,\n                // TODO(HTTP/2): Add support for h2c\n                ALPNProtocols: allowH2 ? [\n                    'http/1.1',\n                    'h2'\n                ] : [\n                    'http/1.1'\n                ],\n                socket: httpSocket,\n                port: port || 443,\n                host: hostname\n            });\n            socket.on('session', function(session) {\n                // TODO (fix): Can a session become invalid once established? Don't think so?\n                sessionCache.set(sessionKey, session);\n            });\n        } else {\n            $rAjBc$assert(!httpSocket, 'httpSocket can only be sent on TLS update');\n            socket = $rAjBc$connect({\n                highWaterMark: 65536,\n                ...options,\n                localAddress: localAddress,\n                port: port || 80,\n                host: hostname\n            });\n        }\n        // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n        if (options.keepAlive == null || options.keepAlive) {\n            const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n            socket.setKeepAlive(true, keepAliveInitialDelay);\n        }\n        const cancelTimeout = $fae8d706d85bf84a$var$setupTimeout(()=>$fae8d706d85bf84a$var$onConnectTimeout(socket), timeout);\n        socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function() {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(null, this);\n            }\n        }).on('error', function(err) {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(err);\n            }\n        });\n        return socket;\n    };\n}\nfunction $fae8d706d85bf84a$var$setupTimeout(onConnectTimeout, timeout) {\n    if (!timeout) return ()=>{};\n    let s1 = null;\n    let s2 = null;\n    const timeoutId = setTimeout(()=>{\n        // setImmediate is added to make sure that we priotorise socket error events over timeouts\n        s1 = setImmediate(()=>{\n            if (process.platform === 'win32') // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n            s2 = setImmediate(()=>onConnectTimeout());\n            else onConnectTimeout();\n        });\n    }, timeout);\n    return ()=>{\n        clearTimeout(timeoutId);\n        clearImmediate(s1);\n        clearImmediate(s2);\n    };\n}\nfunction $fae8d706d85bf84a$var$onConnectTimeout(socket) {\n    $rAjBc$pythonversioncheck7ed1514ejs.destroy(socket, new $fae8d706d85bf84a$require$ConnectTimeoutError());\n}\n$fae8d706d85bf84a$exports = $fae8d706d85bf84a$var$buildConnector;\n\n\nexport {$fae8d706d85bf84a$exports as default};\n//# sourceMappingURL=python-version-check.091f3542.js.map\n","'use strict'\n\nconst net = require('net')\nconst assert = require('assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {\n  SessionCache = class WeakSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n      this._sessionRegistry = new global.FinalizationRegistry((key) => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return\n        }\n\n        const ref = this._sessionCache.get(key)\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key)\n        }\n      })\n    }\n\n    get (sessionKey) {\n      const ref = this._sessionCache.get(sessionKey)\n      return ref ? ref.deref() : null\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      this._sessionCache.set(sessionKey, new WeakRef(session))\n      this._sessionRegistry.register(session, sessionKey)\n    }\n  }\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n    }\n\n    get (sessionKey) {\n      return this._sessionCache.get(sessionKey)\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const { value: oldestKey } = this._sessionCache.keys().next()\n        this._sessionCache.delete(oldestKey)\n      }\n\n      this._sessionCache.set(sessionKey, session)\n    }\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction setupTimeout (onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {}\n  }\n\n  let s1 = null\n  let s2 = null\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout())\n      } else {\n        onConnectTimeout()\n      }\n    })\n  }, timeout)\n  return () => {\n    clearTimeout(timeoutId)\n    clearImmediate(s1)\n    clearImmediate(s2)\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n"],"names":["$fae8d706d85bf84a$var$tls","$fae8d706d85bf84a$var$SessionCache","$rAjBc$pythonversioncheck7ed1514ejs1","$rAjBc$pythonversioncheckdba5a2d4js1","connect","$rAjBc$connect","$rAjBc$assert","$rAjBc$tls","$parcel$global","globalThis","$fae8d706d85bf84a$exports","$fae8d706d85bf84a$require$InvalidArgumentError","InvalidArgumentError","$fae8d706d85bf84a$require$ConnectTimeoutError","$rAjBc$pythonversioncheckdba5a2d4js","ConnectTimeoutError","FinalizationRegistry","process","env","NODE_V8_COVERAGE","maxCachedSessions","_maxCachedSessions","_sessionCache","Map","_sessionRegistry","key","size","ref","get","undefined","deref","delete","sessionKey","set","session","WeakRef","register","value","oldestKey","keys","next","allowH2","socketPath","timeout","opts","Number","isInteger","options","path","sessionCache","hostname","host","protocol","port","servername","localAddress","httpSocket","callback","socket","getServerName","highWaterMark","ALPNProtocols","on","keepAlive","keepAliveInitialDelay","setKeepAlive","cancelTimeout","$fae8d706d85bf84a$var$setupTimeout","onConnectTimeout","s1","s2","timeoutId","setTimeout","setImmediate","platform","clearTimeout","clearImmediate","$rAjBc$pythonversioncheck7ed1514ejs","destroy","setNoDelay","once","cb","err","default"],"version":3,"file":"python-version-check.091f3542.js.map","sourceRoot":"../"}