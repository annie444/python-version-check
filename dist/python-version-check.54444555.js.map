{"mappings":"A,I,E,C,ECGA,IAAM,EAAc,IAAI,YAAY,SAC9B,EAAe,IAAI,IAAI,CAC3B,CAAC,QAAS,EAAY,CACtB,CAAC,OAAQ,EAAY,CACtB,IAwCO,CAAC,EAAM,IACX,AAAI,AAAgB,IAAhB,EAAK,MAAM,CACN,IAEL,AAAgB,UAAhB,OAAO,GACT,CAAA,EAAO,OAAO,IAAI,CAAC,EAAM,EAD3B,EAGO,EAAK,SAAS,CAAC,EAAG,EAAK,MAAM,KAG9B,CAAC,EAAM,IACb,AAAI,AAAgB,IAAhB,EAAK,MAAM,CACN,GAEL,AAAgB,UAAhB,OAAO,EACF,EAEF,EAAK,WAAW,CAAC,EAAG,EAAK,MAAM,IAG/B,CAAC,EAAM,IACd,AAAI,AAAgB,IAAhB,EAAK,MAAM,CACN,IAEL,AAAgB,UAAhB,OAAO,GACT,CAAA,EAAO,OAAO,IAAI,CAAC,EAAM,EAD3B,EAGO,EAAK,SAAS,CAAC,EAAG,EAAK,MAAM,KAG9B,CAAC,EAAM,IACb,AAAI,AAAgB,IAAhB,EAAK,MAAM,CACN,IAEL,AAAgB,UAAhB,OAAO,GACT,CAAA,EAAO,OAAO,IAAI,CAAC,EAAM,EAD3B,EAGO,EAAK,WAAW,CAAC,EAAG,EAAK,MAAM,KAGjC,CAAC,EAAM,KACZ,GAAI,AAAgB,IAAhB,EAAK,MAAM,CACb,MAAO,GAMT,GAJI,AAAgB,UAAhB,OAAO,GACT,CAAA,EAAO,OAAO,IAAI,CAAC,EAAM,EAD3B,EAII,EAAa,GAAG,CAAC,EAAK,QAAQ,IAChC,GAAI,CACF,OAAO,EAAa,GAAG,CAAC,GAAM,MAAM,CAAC,EACvC,CAAE,KAAM,CAAC,CAEX,MAAO,AAAgB,UAAhB,OAAO,EACV,EACA,EAAK,QAAQ,EACnB,EAUF,EAPA,SAAqB,CAAI,CAAE,CAAc,CAAE,CAAY,SACrD,AAAI,EACK,AAnGX,CAAA,SAAqB,CAAO,EAC1B,IAAI,EACJ,OACE,OAAQ,GACN,IAAK,QACL,IAAK,OACH,QACF,KAAK,SACL,IAAK,QACL,IAAK,WACL,IAAK,aACL,IAAK,YACL,IAAK,WACL,IAAK,aACL,IAAK,eACL,IAAK,kBACL,IAAK,SACL,IAAK,WACH,QACF,KAAK,UACL,IAAK,WACL,IAAK,OACL,IAAK,QACH,QACF,KAAK,SACH,QACF,SACE,GAAI,AAAO,KAAA,IAAP,EAAkB,CACpB,EAAK,CAAA,EACL,EAAU,EAAQ,WAAW,GAC7B,QACF,CACA,OAAO,EAAe,IAAI,CAAC,EAC/B,CAEJ,CAAA,EAgEsB,GAAc,EAAM,GAEjC,CACT,S,K,O","sources":["<anon>","node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js"],"sourcesContent":["var $6b01d72019680240$exports = {};\n'use strict';\n// Node has always utf-8\nconst $6b01d72019680240$var$utf8Decoder = new TextDecoder('utf-8');\nconst $6b01d72019680240$var$textDecoders = new Map([\n    [\n        'utf-8',\n        $6b01d72019680240$var$utf8Decoder\n    ],\n    [\n        'utf8',\n        $6b01d72019680240$var$utf8Decoder\n    ]\n]);\nfunction $6b01d72019680240$var$getDecoder(charset) {\n    let lc;\n    while(true)switch(charset){\n        case 'utf-8':\n        case 'utf8':\n            return $6b01d72019680240$var$decoders.utf8;\n        case 'latin1':\n        case 'ascii':\n        case 'us-ascii':\n        case 'iso-8859-1':\n        case 'iso8859-1':\n        case 'iso88591':\n        case 'iso_8859-1':\n        case 'windows-1252':\n        case 'iso_8859-1:1987':\n        case 'cp1252':\n        case 'x-cp1252':\n            return $6b01d72019680240$var$decoders.latin1;\n        case 'utf16le':\n        case 'utf-16le':\n        case 'ucs2':\n        case 'ucs-2':\n            return $6b01d72019680240$var$decoders.utf16le;\n        case 'base64':\n            return $6b01d72019680240$var$decoders.base64;\n        default:\n            if (lc === undefined) {\n                lc = true;\n                charset = charset.toLowerCase();\n                continue;\n            }\n            return $6b01d72019680240$var$decoders.other.bind(charset);\n    }\n}\nconst $6b01d72019680240$var$decoders = {\n    utf8: (data, sourceEncoding)=>{\n        if (data.length === 0) return '';\n        if (typeof data === 'string') data = Buffer.from(data, sourceEncoding);\n        return data.utf8Slice(0, data.length);\n    },\n    latin1: (data, sourceEncoding)=>{\n        if (data.length === 0) return '';\n        if (typeof data === 'string') return data;\n        return data.latin1Slice(0, data.length);\n    },\n    utf16le: (data, sourceEncoding)=>{\n        if (data.length === 0) return '';\n        if (typeof data === 'string') data = Buffer.from(data, sourceEncoding);\n        return data.ucs2Slice(0, data.length);\n    },\n    base64: (data, sourceEncoding)=>{\n        if (data.length === 0) return '';\n        if (typeof data === 'string') data = Buffer.from(data, sourceEncoding);\n        return data.base64Slice(0, data.length);\n    },\n    other: (data, sourceEncoding)=>{\n        if (data.length === 0) return '';\n        if (typeof data === 'string') data = Buffer.from(data, sourceEncoding);\n        if ($6b01d72019680240$var$textDecoders.has($6b01d72019680240$exports.toString())) try {\n            return $6b01d72019680240$var$textDecoders.get($6b01d72019680240$exports).decode(data);\n        } catch  {}\n        return typeof data === 'string' ? data : data.toString();\n    }\n};\nfunction $6b01d72019680240$var$decodeText(text, sourceEncoding, destEncoding) {\n    if (text) return $6b01d72019680240$var$getDecoder(destEncoding)(text, sourceEncoding);\n    return text;\n}\n$6b01d72019680240$exports = $6b01d72019680240$var$decodeText;\n\n\nexport {$6b01d72019680240$exports as default};\n//# sourceMappingURL=python-version-check.54444555.js.map\n","'use strict'\n\n// Node has always utf-8\nconst utf8Decoder = new TextDecoder('utf-8')\nconst textDecoders = new Map([\n  ['utf-8', utf8Decoder],\n  ['utf8', utf8Decoder]\n])\n\nfunction getDecoder (charset) {\n  let lc\n  while (true) {\n    switch (charset) {\n      case 'utf-8':\n      case 'utf8':\n        return decoders.utf8\n      case 'latin1':\n      case 'ascii': // TODO: Make these a separate, strict decoder?\n      case 'us-ascii':\n      case 'iso-8859-1':\n      case 'iso8859-1':\n      case 'iso88591':\n      case 'iso_8859-1':\n      case 'windows-1252':\n      case 'iso_8859-1:1987':\n      case 'cp1252':\n      case 'x-cp1252':\n        return decoders.latin1\n      case 'utf16le':\n      case 'utf-16le':\n      case 'ucs2':\n      case 'ucs-2':\n        return decoders.utf16le\n      case 'base64':\n        return decoders.base64\n      default:\n        if (lc === undefined) {\n          lc = true\n          charset = charset.toLowerCase()\n          continue\n        }\n        return decoders.other.bind(charset)\n    }\n  }\n}\n\nconst decoders = {\n  utf8: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, sourceEncoding)\n    }\n    return data.utf8Slice(0, data.length)\n  },\n\n  latin1: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      return data\n    }\n    return data.latin1Slice(0, data.length)\n  },\n\n  utf16le: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, sourceEncoding)\n    }\n    return data.ucs2Slice(0, data.length)\n  },\n\n  base64: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, sourceEncoding)\n    }\n    return data.base64Slice(0, data.length)\n  },\n\n  other: (data, sourceEncoding) => {\n    if (data.length === 0) {\n      return ''\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, sourceEncoding)\n    }\n\n    if (textDecoders.has(this.toString())) {\n      try {\n        return textDecoders.get(this).decode(data)\n      } catch {}\n    }\n    return typeof data === 'string'\n      ? data\n      : data.toString()\n  }\n}\n\nfunction decodeText (text, sourceEncoding, destEncoding) {\n  if (text) {\n    return getDecoder(destEncoding)(text, sourceEncoding)\n  }\n  return text\n}\n\nmodule.exports = decodeText\n"],"names":["$6b01d72019680240$exports","$6b01d72019680240$var$utf8Decoder","TextDecoder","$6b01d72019680240$var$textDecoders","Map","data","sourceEncoding","length","Buffer","from","utf8Slice","latin1Slice","ucs2Slice","base64Slice","has","toString","get","decode","text","destEncoding","$6b01d72019680240$var$getDecoder","charset","lc","undefined","toLowerCase","$6b01d72019680240$var$decoders","bind","default"],"version":3,"file":"python-version-check.54444555.js.map","sourceRoot":"../"}