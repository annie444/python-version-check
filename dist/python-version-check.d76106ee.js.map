{"mappings":"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","sources":["<anon>","node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js"],"sourcesContent":["import $8r5Wi$pythonversioncheck8bf8cf5cjs from \"./python-version-check.8bf8cf5c.js\";\nimport $8r5Wi$pythonversioncheck789a0bf3js from \"./python-version-check.789a0bf3.js\";\nimport $8r5Wi$pythonversioncheck54444555js from \"./python-version-check.54444555.js\";\nimport $8r5Wi$pythonversioncheckc72f9711js from \"./python-version-check.c72f9711.js\";\nimport $8r5Wi$pythonversionchecke046c214js from \"./python-version-check.e046c214.js\";\nimport {Readable as $8r5Wi$Readable} from \"node:stream\";\nimport {inherits as $8r5Wi$inherits} from \"node:util\";\n\nvar $498aec4271741754$exports = {};\n'use strict';\n\nvar $498aec4271741754$require$Readable = $8r5Wi$Readable;\n\nvar $498aec4271741754$require$inherits = $8r5Wi$inherits;\n\n\n\n\n\nconst $498aec4271741754$var$RE_BOUNDARY = /^boundary$/i;\nconst $498aec4271741754$var$RE_FIELD = /^form-data$/i;\nconst $498aec4271741754$var$RE_CHARSET = /^charset$/i;\nconst $498aec4271741754$var$RE_FILENAME = /^filename$/i;\nconst $498aec4271741754$var$RE_NAME = /^name$/i;\n$498aec4271741754$var$Multipart.detect = /^multipart\\/form-data/i;\nfunction $498aec4271741754$var$Multipart(boy, cfg) {\n    let i;\n    let len;\n    const self = this;\n    let boundary;\n    const limits = cfg.limits;\n    const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName)=>contentType === 'application/octet-stream' || fileName !== undefined);\n    const parsedConType = cfg.parsedConType || [];\n    const defCharset = cfg.defCharset || 'utf8';\n    const preservePath = cfg.preservePath;\n    const fileOpts = {\n        highWaterMark: cfg.fileHwm\n    };\n    for(i = 0, len = parsedConType.length; i < len; ++i)if (Array.isArray(parsedConType[i]) && $498aec4271741754$var$RE_BOUNDARY.test(parsedConType[i][0])) {\n        boundary = parsedConType[i][1];\n        break;\n    }\n    function checkFinished() {\n        if (nends === 0 && finished && !boy._done) {\n            finished = false;\n            self.end();\n        }\n    }\n    if (typeof boundary !== 'string') throw new Error('Multipart: Boundary not found');\n    const fieldSizeLimit = $8r5Wi$pythonversionchecke046c214js(limits, 'fieldSize', 1048576);\n    const fileSizeLimit = $8r5Wi$pythonversionchecke046c214js(limits, 'fileSize', Infinity);\n    const filesLimit = $8r5Wi$pythonversionchecke046c214js(limits, 'files', Infinity);\n    const fieldsLimit = $8r5Wi$pythonversionchecke046c214js(limits, 'fields', Infinity);\n    const partsLimit = $8r5Wi$pythonversionchecke046c214js(limits, 'parts', Infinity);\n    const headerPairsLimit = $8r5Wi$pythonversionchecke046c214js(limits, 'headerPairs', 2000);\n    const headerSizeLimit = $8r5Wi$pythonversionchecke046c214js(limits, 'headerSize', 81920);\n    let nfiles = 0;\n    let nfields = 0;\n    let nends = 0;\n    let curFile;\n    let curField;\n    let finished = false;\n    this._needDrain = false;\n    this._pause = false;\n    this._cb = undefined;\n    this._nparts = 0;\n    this._boy = boy;\n    const parserCfg = {\n        boundary: boundary,\n        maxHeaderPairs: headerPairsLimit,\n        maxHeaderSize: headerSizeLimit,\n        partHwm: fileOpts.highWaterMark,\n        highWaterMark: cfg.highWaterMark\n    };\n    this.parser = new $8r5Wi$pythonversioncheck8bf8cf5cjs(parserCfg);\n    this.parser.on('drain', function() {\n        self._needDrain = false;\n        if (self._cb && !self._pause) {\n            const cb = self._cb;\n            self._cb = undefined;\n            cb();\n        }\n    }).on('part', function onPart(part) {\n        if (++self._nparts > partsLimit) {\n            self.parser.removeListener('part', onPart);\n            self.parser.on('part', $498aec4271741754$var$skipPart);\n            boy.hitPartsLimit = true;\n            boy.emit('partsLimit');\n            return $498aec4271741754$var$skipPart(part);\n        }\n        // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n        // us emit 'end' early since we know the part has ended if we are already\n        // seeing the next part\n        if (curField) {\n            const field = curField;\n            field.emit('end');\n            field.removeAllListeners('end');\n        }\n        part.on('header', function(header) {\n            let contype;\n            let fieldname;\n            let parsed;\n            let charset;\n            let encoding;\n            let filename;\n            let nsize = 0;\n            if (header['content-type']) {\n                parsed = $8r5Wi$pythonversioncheck789a0bf3js(header['content-type'][0]);\n                if (parsed[0]) {\n                    contype = parsed[0].toLowerCase();\n                    for(i = 0, len = parsed.length; i < len; ++i)if ($498aec4271741754$var$RE_CHARSET.test(parsed[i][0])) {\n                        charset = parsed[i][1].toLowerCase();\n                        break;\n                    }\n                }\n            }\n            if (contype === undefined) contype = 'text/plain';\n            if (charset === undefined) charset = defCharset;\n            if (header['content-disposition']) {\n                parsed = $8r5Wi$pythonversioncheck789a0bf3js(header['content-disposition'][0]);\n                if (!$498aec4271741754$var$RE_FIELD.test(parsed[0])) return $498aec4271741754$var$skipPart(part);\n                for(i = 0, len = parsed.length; i < len; ++i){\n                    if ($498aec4271741754$var$RE_NAME.test(parsed[i][0])) fieldname = parsed[i][1];\n                    else if ($498aec4271741754$var$RE_FILENAME.test(parsed[i][0])) {\n                        filename = parsed[i][1];\n                        if (!preservePath) filename = $8r5Wi$pythonversioncheckc72f9711js(filename);\n                    }\n                }\n            } else return $498aec4271741754$var$skipPart(part);\n            if (header['content-transfer-encoding']) encoding = header['content-transfer-encoding'][0].toLowerCase();\n            else encoding = '7bit';\n            let onData, onEnd;\n            if (isPartAFile(fieldname, contype, filename)) {\n                // file/binary field\n                if (nfiles === filesLimit) {\n                    if (!boy.hitFilesLimit) {\n                        boy.hitFilesLimit = true;\n                        boy.emit('filesLimit');\n                    }\n                    return $498aec4271741754$var$skipPart(part);\n                }\n                ++nfiles;\n                if (boy.listenerCount('file') === 0) {\n                    self.parser._ignore();\n                    return;\n                }\n                ++nends;\n                const file = new $498aec4271741754$var$FileStream(fileOpts);\n                curFile = file;\n                file.on('end', function() {\n                    --nends;\n                    self._pause = false;\n                    checkFinished();\n                    if (self._cb && !self._needDrain) {\n                        const cb = self._cb;\n                        self._cb = undefined;\n                        cb();\n                    }\n                });\n                file._read = function(n) {\n                    if (!self._pause) return;\n                    self._pause = false;\n                    if (self._cb && !self._needDrain) {\n                        const cb = self._cb;\n                        self._cb = undefined;\n                        cb();\n                    }\n                };\n                boy.emit('file', fieldname, file, filename, encoding, contype);\n                onData = function(data) {\n                    if ((nsize += data.length) > fileSizeLimit) {\n                        const extralen = fileSizeLimit - nsize + data.length;\n                        if (extralen > 0) file.push(data.slice(0, extralen));\n                        file.truncated = true;\n                        file.bytesRead = fileSizeLimit;\n                        part.removeAllListeners('data');\n                        file.emit('limit');\n                        return;\n                    } else if (!file.push(data)) self._pause = true;\n                    file.bytesRead = nsize;\n                };\n                onEnd = function() {\n                    curFile = undefined;\n                    file.push(null);\n                };\n            } else {\n                // non-file field\n                if (nfields === fieldsLimit) {\n                    if (!boy.hitFieldsLimit) {\n                        boy.hitFieldsLimit = true;\n                        boy.emit('fieldsLimit');\n                    }\n                    return $498aec4271741754$var$skipPart(part);\n                }\n                ++nfields;\n                ++nends;\n                let buffer = '';\n                let truncated = false;\n                curField = part;\n                onData = function(data) {\n                    if ((nsize += data.length) > fieldSizeLimit) {\n                        const extralen = fieldSizeLimit - (nsize - data.length);\n                        buffer += data.toString('binary', 0, extralen);\n                        truncated = true;\n                        part.removeAllListeners('data');\n                    } else buffer += data.toString('binary');\n                };\n                onEnd = function() {\n                    curField = undefined;\n                    if (buffer.length) buffer = $8r5Wi$pythonversioncheck54444555js(buffer, 'binary', charset);\n                    boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);\n                    --nends;\n                    checkFinished();\n                };\n            }\n            /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */ part._readableState.sync = false;\n            part.on('data', onData);\n            part.on('end', onEnd);\n        }).on('error', function(err) {\n            if (curFile) curFile.emit('error', err);\n        });\n    }).on('error', function(err) {\n        boy.emit('error', err);\n    }).on('finish', function() {\n        finished = true;\n        checkFinished();\n    });\n}\n$498aec4271741754$var$Multipart.prototype.write = function(chunk, cb) {\n    const r = this.parser.write(chunk);\n    if (r && !this._pause) cb();\n    else {\n        this._needDrain = !r;\n        this._cb = cb;\n    }\n};\n$498aec4271741754$var$Multipart.prototype.end = function() {\n    const self = this;\n    if (self.parser.writable) self.parser.end();\n    else if (!self._boy._done) process.nextTick(function() {\n        self._boy._done = true;\n        self._boy.emit('finish');\n    });\n};\nfunction $498aec4271741754$var$skipPart(part) {\n    part.resume();\n}\nfunction $498aec4271741754$var$FileStream(opts) {\n    $498aec4271741754$require$Readable.call(this, opts);\n    this.bytesRead = 0;\n    this.truncated = false;\n}\n$498aec4271741754$require$inherits($498aec4271741754$var$FileStream, $498aec4271741754$require$Readable);\n$498aec4271741754$var$FileStream.prototype._read = function(n) {};\n$498aec4271741754$exports = $498aec4271741754$var$Multipart;\n\n\nexport {$498aec4271741754$exports as default};\n//# sourceMappingURL=python-version-check.d76106ee.js.map\n","'use strict'\n\n// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\n\nconst { Readable } = require('node:stream')\nconst { inherits } = require('node:util')\n\nconst Dicer = require('../../deps/dicer/lib/Dicer')\n\nconst parseParams = require('../utils/parseParams')\nconst decodeText = require('../utils/decodeText')\nconst basename = require('../utils/basename')\nconst getLimit = require('../utils/getLimit')\n\nconst RE_BOUNDARY = /^boundary$/i\nconst RE_FIELD = /^form-data$/i\nconst RE_CHARSET = /^charset$/i\nconst RE_FILENAME = /^filename$/i\nconst RE_NAME = /^name$/i\n\nMultipart.detect = /^multipart\\/form-data/i\nfunction Multipart (boy, cfg) {\n  let i\n  let len\n  const self = this\n  let boundary\n  const limits = cfg.limits\n  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined))\n  const parsedConType = cfg.parsedConType || []\n  const defCharset = cfg.defCharset || 'utf8'\n  const preservePath = cfg.preservePath\n  const fileOpts = { highWaterMark: cfg.fileHwm }\n\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) &&\n      RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1]\n      break\n    }\n  }\n\n  function checkFinished () {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false\n      self.end()\n    }\n  }\n\n  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }\n\n  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)\n  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity)\n  const filesLimit = getLimit(limits, 'files', Infinity)\n  const fieldsLimit = getLimit(limits, 'fields', Infinity)\n  const partsLimit = getLimit(limits, 'parts', Infinity)\n  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000)\n  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024)\n\n  let nfiles = 0\n  let nfields = 0\n  let nends = 0\n  let curFile\n  let curField\n  let finished = false\n\n  this._needDrain = false\n  this._pause = false\n  this._cb = undefined\n  this._nparts = 0\n  this._boy = boy\n\n  const parserCfg = {\n    boundary,\n    maxHeaderPairs: headerPairsLimit,\n    maxHeaderSize: headerSizeLimit,\n    partHwm: fileOpts.highWaterMark,\n    highWaterMark: cfg.highWaterMark\n  }\n\n  this.parser = new Dicer(parserCfg)\n  this.parser.on('drain', function () {\n    self._needDrain = false\n    if (self._cb && !self._pause) {\n      const cb = self._cb\n      self._cb = undefined\n      cb()\n    }\n  }).on('part', function onPart (part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart)\n      self.parser.on('part', skipPart)\n      boy.hitPartsLimit = true\n      boy.emit('partsLimit')\n      return skipPart(part)\n    }\n\n    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n    if (curField) {\n      const field = curField\n      field.emit('end')\n      field.removeAllListeners('end')\n    }\n\n    part.on('header', function (header) {\n      let contype\n      let fieldname\n      let parsed\n      let charset\n      let encoding\n      let filename\n      let nsize = 0\n\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0])\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase()\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase()\n              break\n            }\n          }\n        }\n      }\n\n      if (contype === undefined) { contype = 'text/plain' }\n      if (charset === undefined) { charset = defCharset }\n\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0])\n        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = parsed[i][1]\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = parsed[i][1]\n            if (!preservePath) { filename = basename(filename) }\n          }\n        }\n      } else { return skipPart(part) }\n\n      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase() } else { encoding = '7bit' }\n\n      let onData,\n        onEnd\n\n      if (isPartAFile(fieldname, contype, filename)) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true\n            boy.emit('filesLimit')\n          }\n          return skipPart(part)\n        }\n\n        ++nfiles\n\n        if (boy.listenerCount('file') === 0) {\n          self.parser._ignore()\n          return\n        }\n\n        ++nends\n        const file = new FileStream(fileOpts)\n        curFile = file\n        file.on('end', function () {\n          --nends\n          self._pause = false\n          checkFinished()\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb\n            self._cb = undefined\n            cb()\n          }\n        })\n        file._read = function (n) {\n          if (!self._pause) { return }\n          self._pause = false\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb\n            self._cb = undefined\n            cb()\n          }\n        }\n        boy.emit('file', fieldname, file, filename, encoding, contype)\n\n        onData = function (data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            const extralen = fileSizeLimit - nsize + data.length\n            if (extralen > 0) { file.push(data.slice(0, extralen)) }\n            file.truncated = true\n            file.bytesRead = fileSizeLimit\n            part.removeAllListeners('data')\n            file.emit('limit')\n            return\n          } else if (!file.push(data)) { self._pause = true }\n\n          file.bytesRead = nsize\n        }\n\n        onEnd = function () {\n          curFile = undefined\n          file.push(null)\n        }\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true\n            boy.emit('fieldsLimit')\n          }\n          return skipPart(part)\n        }\n\n        ++nfields\n        ++nends\n        let buffer = ''\n        let truncated = false\n        curField = part\n\n        onData = function (data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            const extralen = (fieldSizeLimit - (nsize - data.length))\n            buffer += data.toString('binary', 0, extralen)\n            truncated = true\n            part.removeAllListeners('data')\n          } else { buffer += data.toString('binary') }\n        }\n\n        onEnd = function () {\n          curField = undefined\n          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset) }\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype)\n          --nends\n          checkFinished()\n        }\n      }\n\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */\n      part._readableState.sync = false\n\n      part.on('data', onData)\n      part.on('end', onEnd)\n    }).on('error', function (err) {\n      if (curFile) { curFile.emit('error', err) }\n    })\n  }).on('error', function (err) {\n    boy.emit('error', err)\n  }).on('finish', function () {\n    finished = true\n    checkFinished()\n  })\n}\n\nMultipart.prototype.write = function (chunk, cb) {\n  const r = this.parser.write(chunk)\n  if (r && !this._pause) {\n    cb()\n  } else {\n    this._needDrain = !r\n    this._cb = cb\n  }\n}\n\nMultipart.prototype.end = function () {\n  const self = this\n\n  if (self.parser.writable) {\n    self.parser.end()\n  } else if (!self._boy._done) {\n    process.nextTick(function () {\n      self._boy._done = true\n      self._boy.emit('finish')\n    })\n  }\n}\n\nfunction skipPart (part) {\n  part.resume()\n}\n\nfunction FileStream (opts) {\n  Readable.call(this, opts)\n\n  this.bytesRead = 0\n\n  this.truncated = false\n}\n\ninherits(FileStream, Readable)\n\nFileStream.prototype._read = function (n) {}\n\nmodule.exports = Multipart\n"],"names":["$8r5Wi$pythonversioncheck8bf8cf5cjs","$8r5Wi$pythonversioncheck789a0bf3js","$8r5Wi$pythonversioncheck54444555js","$8r5Wi$pythonversioncheckc72f9711js","$8r5Wi$pythonversionchecke046c214js","Readable","$8r5Wi$Readable","inherits","$8r5Wi$inherits","$498aec4271741754$exports","$498aec4271741754$var$RE_BOUNDARY","$498aec4271741754$var$RE_FIELD","$498aec4271741754$var$RE_CHARSET","$498aec4271741754$var$RE_FILENAME","$498aec4271741754$var$RE_NAME","$498aec4271741754$var$Multipart","boy","cfg","i","len","boundary","curFile","curField","self","limits","isPartAFile","fieldName","contentType","fileName","undefined","parsedConType","defCharset","preservePath","fileOpts","highWaterMark","fileHwm","length","Array","isArray","test","checkFinished","nends","finished","_done","end","Error","fieldSizeLimit","fileSizeLimit","Infinity","filesLimit","fieldsLimit","partsLimit","headerPairsLimit","headerSizeLimit","nfiles","nfields","_needDrain","_pause","_cb","_nparts","_boy","parserCfg","maxHeaderPairs","maxHeaderSize","partHwm","parser","on","cb","onPart","part","removeListener","$498aec4271741754$var$skipPart","hitPartsLimit","emit","field","removeAllListeners","header","contype","fieldname","parsed","charset","encoding","filename","onData","onEnd","nsize","toLowerCase","hitFilesLimit","listenerCount","_ignore","file","$498aec4271741754$var$FileStream","_read","n","data","extralen","push","slice","truncated","bytesRead","hitFieldsLimit","buffer","toString","_readableState","sync","err","resume","opts","$498aec4271741754$require$Readable","call","detect","prototype","write","chunk","r","writable","process","nextTick","$498aec4271741754$require$inherits","default"],"version":3,"file":"python-version-check.d76106ee.js.map","sourceRoot":"../"}