{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cache.js"],"sourcesContent":["import $aC1eT$pythonversioncheck892401fajs from \"./python-version-check.892401fa.js\";\nimport $aC1eT$pythonversioncheck28dd9cbbjs1 from \"./python-version-check.28dd9cbb.js\";\nimport $aC1eT$pythonversioncheck7ed1514ejs1 from \"./python-version-check.7ed1514e.js\";\nimport $aC1eT$pythonversioncheckebf2a848js from \"./python-version-check.ebf2a848.js\";\nimport $aC1eT$pythonversioncheck801bb0f1js from \"./python-version-check.801bb0f1.js\";\nimport $aC1eT$pythonversioncheckc211052ejs1 from \"./python-version-check.c211052e.js\";\nimport $aC1eT$pythonversioncheckff3942bajs from \"./python-version-check.ff3942ba.js\";\nimport $aC1eT$pythonversioncheck92c00e26js3 from \"./python-version-check.92c00e26.js\";\nimport $aC1eT$pythonversioncheckdb834fc6js from \"./python-version-check.db834fc6.js\";\nimport $aC1eT$pythonversioncheck3f48d3eejs2 from \"./python-version-check.3f48d3ee.js\";\nimport $aC1eT$pythonversioncheck2f8c5fadjs from \"./python-version-check.2f8c5fad.js\";\nimport * as $aC1eT$assert from \"assert\";\n\nvar $16bc28ac822c9bc7$exports = {};\n'use strict';\n\nvar $16bc28ac822c9bc7$require$kConstruct = $aC1eT$pythonversioncheck892401fajs.kConstruct;\n\nvar $16bc28ac822c9bc7$require$urlEquals = $aC1eT$pythonversioncheck28dd9cbbjs1.urlEquals;\nvar $16bc28ac822c9bc7$require$getFieldValues = $aC1eT$pythonversioncheck28dd9cbbjs.fieldValues;\n\nvar $16bc28ac822c9bc7$require$kEnumerableProperty = $aC1eT$pythonversioncheck7ed1514ejs1.kEnumerableProperty;\nvar $16bc28ac822c9bc7$require$isDisturbed = $aC1eT$pythonversioncheck7ed1514ejs.isDisturbed;\n\nvar $16bc28ac822c9bc7$require$kHeadersList = $aC1eT$pythonversioncheckebf2a848js.kHeadersList;\n\nvar $16bc28ac822c9bc7$require$webidl = $aC1eT$pythonversioncheck801bb0f1js.webidl;\n\nvar $16bc28ac822c9bc7$require$Response = $aC1eT$pythonversioncheckc211052ejs1.Response;\nvar $16bc28ac822c9bc7$require$cloneResponse = $aC1eT$pythonversioncheckc211052ejs.cloneResponse;\n\nvar $16bc28ac822c9bc7$require$Request = $aC1eT$pythonversioncheckff3942bajs.Request;\n\nvar $16bc28ac822c9bc7$require$kState = $aC1eT$pythonversioncheck92c00e26js3.kState;\nvar $16bc28ac822c9bc7$require$kHeaders = $aC1eT$pythonversioncheck92c00e26js1.kHeaders;\nvar $16bc28ac822c9bc7$require$kGuard = $aC1eT$pythonversioncheck92c00e26js.kGuard;\nvar $16bc28ac822c9bc7$require$kRealm = $aC1eT$pythonversioncheck92c00e26js2.kRealm;\n\nvar $16bc28ac822c9bc7$require$fetching = $aC1eT$pythonversioncheckdb834fc6js.fetching;\n\nvar $16bc28ac822c9bc7$require$urlIsHttpHttpsScheme = $aC1eT$pythonversioncheck3f48d3eejs2.urlIsHttpHttpsScheme;\nvar $16bc28ac822c9bc7$require$createDeferredPromise = $aC1eT$pythonversioncheck3f48d3eejs.createDeferredPromise;\nvar $16bc28ac822c9bc7$require$readAllBytes = $aC1eT$pythonversioncheck3f48d3eejs1.readAllBytes;\n\n\nvar $16bc28ac822c9bc7$require$getGlobalDispatcher = $aC1eT$pythonversioncheck2f8c5fadjs.getGlobalDispatcher;\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */ /**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */ class $16bc28ac822c9bc7$var$Cache {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */ #relevantRequestResponseList;\n    constructor(){\n        if (arguments[0] !== $16bc28ac822c9bc7$require$kConstruct) $16bc28ac822c9bc7$require$webidl.illegalConstructor();\n        this.#relevantRequestResponseList = arguments[1];\n    }\n    async match(request, options = {}) {\n        $16bc28ac822c9bc7$require$webidl.brandCheck(this, $16bc28ac822c9bc7$var$Cache);\n        $16bc28ac822c9bc7$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'Cache.match'\n        });\n        request = $16bc28ac822c9bc7$require$webidl.converters.RequestInfo(request);\n        options = $16bc28ac822c9bc7$require$webidl.converters.CacheQueryOptions(options);\n        const p = await this.matchAll(request, options);\n        if (p.length === 0) return;\n        return p[0];\n    }\n    async matchAll(request, options = {}) {\n        $16bc28ac822c9bc7$require$webidl.brandCheck(this, $16bc28ac822c9bc7$var$Cache);\n        if (request !== undefined) request = $16bc28ac822c9bc7$require$webidl.converters.RequestInfo(request);\n        options = $16bc28ac822c9bc7$require$webidl.converters.CacheQueryOptions(options);\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            if (request instanceof $16bc28ac822c9bc7$require$Request) {\n                // 2.1.1\n                r = request[$16bc28ac822c9bc7$require$kState];\n                // 2.1.2\n                if (r.method !== 'GET' && !options.ignoreMethod) return [];\n            } else if (typeof request === 'string') // 2.2.1\n            r = new $16bc28ac822c9bc7$require$Request(request)[$16bc28ac822c9bc7$require$kState];\n        }\n        // 5.\n        // 5.1\n        const responses = [];\n        // 5.2\n        if (request === undefined) // 5.2.1\n        for (const requestResponse of this.#relevantRequestResponseList)responses.push(requestResponse[1]);\n        else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses)responses.push(requestResponse[1]);\n        }\n        // 5.4\n        // We don't implement CORs so we don't need to loop over the responses, yay!\n        // 5.5.1\n        const responseList = [];\n        // 5.5.2\n        for (const response of responses){\n            // 5.5.2.1\n            const responseObject = new $16bc28ac822c9bc7$require$Response(response.body?.source ?? null);\n            const body = responseObject[$16bc28ac822c9bc7$require$kState].body;\n            responseObject[$16bc28ac822c9bc7$require$kState] = response;\n            responseObject[$16bc28ac822c9bc7$require$kState].body = body;\n            responseObject[$16bc28ac822c9bc7$require$kHeaders][$16bc28ac822c9bc7$require$kHeadersList] = response.headersList;\n            responseObject[$16bc28ac822c9bc7$require$kHeaders][$16bc28ac822c9bc7$require$kGuard] = 'immutable';\n            responseList.push(responseObject);\n        }\n        // 6.\n        return Object.freeze(responseList);\n    }\n    async add(request) {\n        $16bc28ac822c9bc7$require$webidl.brandCheck(this, $16bc28ac822c9bc7$var$Cache);\n        $16bc28ac822c9bc7$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'Cache.add'\n        });\n        request = $16bc28ac822c9bc7$require$webidl.converters.RequestInfo(request);\n        // 1.\n        const requests = [\n            request\n        ];\n        // 2.\n        const responseArrayPromise = this.addAll(requests);\n        // 3.\n        return await responseArrayPromise;\n    }\n    async addAll(requests) {\n        $16bc28ac822c9bc7$require$webidl.brandCheck(this, $16bc28ac822c9bc7$var$Cache);\n        $16bc28ac822c9bc7$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'Cache.addAll'\n        });\n        requests = $16bc28ac822c9bc7$require$webidl.converters['sequence<RequestInfo>'](requests);\n        // 1.\n        const responsePromises = [];\n        // 2.\n        const requestList = [];\n        // 3.\n        for (const request of requests){\n            if (typeof request === 'string') continue;\n            // 3.1\n            const r = request[$16bc28ac822c9bc7$require$kState];\n            // 3.2\n            if (!$16bc28ac822c9bc7$require$urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                header: 'Cache.addAll',\n                message: 'Expected http/s scheme when method is not GET.'\n            });\n        }\n        // 4.\n        /** @type {ReturnType<typeof fetching>[]} */ const fetchControllers = [];\n        // 5.\n        for (const request of requests){\n            // 5.1\n            const r = new $16bc28ac822c9bc7$require$Request(request)[$16bc28ac822c9bc7$require$kState];\n            // 5.2\n            if (!$16bc28ac822c9bc7$require$urlIsHttpHttpsScheme(r.url)) throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                header: 'Cache.addAll',\n                message: 'Expected http/s scheme.'\n            });\n            // 5.4\n            r.initiator = 'fetch';\n            r.destination = 'subresource';\n            // 5.5\n            requestList.push(r);\n            // 5.6\n            const responsePromise = $16bc28ac822c9bc7$require$createDeferredPromise();\n            // 5.7\n            fetchControllers.push($16bc28ac822c9bc7$require$fetching({\n                request: r,\n                dispatcher: $16bc28ac822c9bc7$require$getGlobalDispatcher(),\n                processResponse (response) {\n                    // 1.\n                    if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) responsePromise.reject($16bc28ac822c9bc7$require$webidl.errors.exception({\n                        header: 'Cache.addAll',\n                        message: 'Received an invalid status code or the request failed.'\n                    }));\n                    else if (response.headersList.contains('vary')) {\n                        // 2.1\n                        const fieldValues = $16bc28ac822c9bc7$require$getFieldValues(response.headersList.get('vary'));\n                        // 2.2\n                        for (const fieldValue of fieldValues)// 2.2.1\n                        if (fieldValue === '*') {\n                            responsePromise.reject($16bc28ac822c9bc7$require$webidl.errors.exception({\n                                header: 'Cache.addAll',\n                                message: 'invalid vary field value'\n                            }));\n                            for (const controller of fetchControllers)controller.abort();\n                            return;\n                        }\n                    }\n                },\n                processResponseEndOfBody (response) {\n                    // 1.\n                    if (response.aborted) {\n                        responsePromise.reject(new DOMException('aborted', 'AbortError'));\n                        return;\n                    }\n                    // 2.\n                    responsePromise.resolve(response);\n                }\n            }));\n            // 5.8\n            responsePromises.push(responsePromise.promise);\n        }\n        // 6.\n        const p = Promise.all(responsePromises);\n        // 7.\n        const responses = await p;\n        // 7.1\n        const operations = [];\n        // 7.2\n        let index = 0;\n        // 7.3\n        for (const response of responses){\n            // 7.3.1\n            /** @type {CacheBatchOperation} */ const operation = {\n                type: 'put',\n                request: requestList[index],\n                response: response // 7.3.4\n            };\n            operations.push(operation) // 7.3.5\n            ;\n            index++ // 7.3.6\n            ;\n        }\n        // 7.5\n        const cacheJobPromise = $16bc28ac822c9bc7$require$createDeferredPromise();\n        // 7.6.1\n        let errorData = null;\n        // 7.6.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 7.6.3\n        queueMicrotask(()=>{\n            // 7.6.3.1\n            if (errorData === null) cacheJobPromise.resolve(undefined);\n            else // 7.6.3.2\n            cacheJobPromise.reject(errorData);\n        });\n        // 7.7\n        return cacheJobPromise.promise;\n    }\n    async put(request, response) {\n        $16bc28ac822c9bc7$require$webidl.brandCheck(this, $16bc28ac822c9bc7$var$Cache);\n        $16bc28ac822c9bc7$require$webidl.argumentLengthCheck(arguments, 2, {\n            header: 'Cache.put'\n        });\n        request = $16bc28ac822c9bc7$require$webidl.converters.RequestInfo(request);\n        response = $16bc28ac822c9bc7$require$webidl.converters.Response(response);\n        // 1.\n        let innerRequest = null;\n        // 2.\n        if (request instanceof $16bc28ac822c9bc7$require$Request) innerRequest = request[$16bc28ac822c9bc7$require$kState];\n        else innerRequest = new $16bc28ac822c9bc7$require$Request(request)[$16bc28ac822c9bc7$require$kState];\n        // 4.\n        if (!$16bc28ac822c9bc7$require$urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n            header: 'Cache.put',\n            message: 'Expected an http/s scheme when method is not GET'\n        });\n        // 5.\n        const innerResponse = response[$16bc28ac822c9bc7$require$kState];\n        // 6.\n        if (innerResponse.status === 206) throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n            header: 'Cache.put',\n            message: 'Got 206 status'\n        });\n        // 7.\n        if (innerResponse.headersList.contains('vary')) {\n            // 7.1.\n            const fieldValues = $16bc28ac822c9bc7$require$getFieldValues(innerResponse.headersList.get('vary'));\n            // 7.2.\n            for (const fieldValue of fieldValues){\n                // 7.2.1\n                if (fieldValue === '*') throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                    header: 'Cache.put',\n                    message: 'Got * vary field value'\n                });\n            }\n        }\n        // 8.\n        if (innerResponse.body && ($16bc28ac822c9bc7$require$isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n            header: 'Cache.put',\n            message: 'Response body is locked or disturbed'\n        });\n        // 9.\n        const clonedResponse = $16bc28ac822c9bc7$require$cloneResponse(innerResponse);\n        // 10.\n        const bodyReadPromise = $16bc28ac822c9bc7$require$createDeferredPromise();\n        // 11.\n        if (innerResponse.body != null) {\n            // 11.1\n            const stream = innerResponse.body.stream;\n            // 11.2\n            const reader = stream.getReader();\n            // 11.3\n            $16bc28ac822c9bc7$require$readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);\n        } else bodyReadPromise.resolve(undefined);\n        // 12.\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        // 13.\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: 'put',\n            request: innerRequest,\n            response: clonedResponse // 16.\n        };\n        // 17.\n        operations.push(operation);\n        // 19.\n        const bytes = await bodyReadPromise.promise;\n        if (clonedResponse.body != null) clonedResponse.body.source = bytes;\n        // 19.1\n        const cacheJobPromise = $16bc28ac822c9bc7$require$createDeferredPromise();\n        // 19.2.1\n        let errorData = null;\n        // 19.2.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 19.2.3\n        queueMicrotask(()=>{\n            // 19.2.3.1\n            if (errorData === null) cacheJobPromise.resolve();\n            else cacheJobPromise.reject(errorData);\n        });\n        return cacheJobPromise.promise;\n    }\n    async delete(request, options = {}) {\n        $16bc28ac822c9bc7$require$webidl.brandCheck(this, $16bc28ac822c9bc7$var$Cache);\n        $16bc28ac822c9bc7$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'Cache.delete'\n        });\n        request = $16bc28ac822c9bc7$require$webidl.converters.RequestInfo(request);\n        options = $16bc28ac822c9bc7$require$webidl.converters.CacheQueryOptions(options);\n        /**\n     * @type {Request}\n     */ let r = null;\n        if (request instanceof $16bc28ac822c9bc7$require$Request) {\n            r = request[$16bc28ac822c9bc7$require$kState];\n            if (r.method !== 'GET' && !options.ignoreMethod) return false;\n        } else {\n            $aC1eT$assert(typeof request === 'string');\n            r = new $16bc28ac822c9bc7$require$Request(request)[$16bc28ac822c9bc7$require$kState];\n        }\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: 'delete',\n            request: r,\n            options: options\n        };\n        operations.push(operation);\n        const cacheJobPromise = $16bc28ac822c9bc7$require$createDeferredPromise();\n        let errorData = null;\n        let requestResponses;\n        try {\n            requestResponses = this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        queueMicrotask(()=>{\n            if (errorData === null) cacheJobPromise.resolve(!!requestResponses?.length);\n            else cacheJobPromise.reject(errorData);\n        });\n        return cacheJobPromise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {readonly Request[]}\n   */ async keys(request, options = {}) {\n        $16bc28ac822c9bc7$require$webidl.brandCheck(this, $16bc28ac822c9bc7$var$Cache);\n        if (request !== undefined) request = $16bc28ac822c9bc7$require$webidl.converters.RequestInfo(request);\n        options = $16bc28ac822c9bc7$require$webidl.converters.CacheQueryOptions(options);\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            // 2.1\n            if (request instanceof $16bc28ac822c9bc7$require$Request) {\n                // 2.1.1\n                r = request[$16bc28ac822c9bc7$require$kState];\n                // 2.1.2\n                if (r.method !== 'GET' && !options.ignoreMethod) return [];\n            } else if (typeof request === 'string') r = new $16bc28ac822c9bc7$require$Request(request)[$16bc28ac822c9bc7$require$kState];\n        }\n        // 4.\n        const promise = $16bc28ac822c9bc7$require$createDeferredPromise();\n        // 5.\n        // 5.1\n        const requests = [];\n        // 5.2\n        if (request === undefined) // 5.2.1\n        for (const requestResponse of this.#relevantRequestResponseList)// 5.2.1.1\n        requests.push(requestResponse[0]);\n        else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses)// 5.3.2.1\n            requests.push(requestResponse[0]);\n        }\n        // 5.4\n        queueMicrotask(()=>{\n            // 5.4.1\n            const requestList = [];\n            // 5.4.2\n            for (const request of requests){\n                const requestObject = new $16bc28ac822c9bc7$require$Request('https://a');\n                requestObject[$16bc28ac822c9bc7$require$kState] = request;\n                requestObject[$16bc28ac822c9bc7$require$kHeaders][$16bc28ac822c9bc7$require$kHeadersList] = request.headersList;\n                requestObject[$16bc28ac822c9bc7$require$kHeaders][$16bc28ac822c9bc7$require$kGuard] = 'immutable';\n                requestObject[$16bc28ac822c9bc7$require$kRealm] = request.client;\n                // 5.4.2.1\n                requestList.push(requestObject);\n            }\n            // 5.4.3\n            promise.resolve(Object.freeze(requestList));\n        });\n        return promise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */ #batchCacheOperations(operations) {\n        // 1.\n        const cache = this.#relevantRequestResponseList;\n        // 2.\n        const backupCache = [\n            ...cache\n        ];\n        // 3.\n        const addedItems = [];\n        // 4.1\n        const resultList = [];\n        try {\n            // 4.2\n            for (const operation of operations){\n                // 4.2.1\n                if (operation.type !== 'delete' && operation.type !== 'put') throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                    header: 'Cache.#batchCacheOperations',\n                    message: 'operation type does not match \"delete\" or \"put\"'\n                });\n                // 4.2.2\n                if (operation.type === 'delete' && operation.response != null) throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                    header: 'Cache.#batchCacheOperations',\n                    message: 'delete operation should not have an associated response'\n                });\n                // 4.2.3\n                if (this.#queryCache(operation.request, operation.options, addedItems).length) throw new DOMException('???', 'InvalidStateError');\n                // 4.2.4\n                let requestResponses;\n                // 4.2.5\n                if (operation.type === 'delete') {\n                    // 4.2.5.1\n                    requestResponses = this.#queryCache(operation.request, operation.options);\n                    // TODO: the spec is wrong, this is needed to pass WPTs\n                    if (requestResponses.length === 0) return [];\n                    // 4.2.5.2\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        $aC1eT$assert(idx !== -1);\n                        // 4.2.5.2.1\n                        cache.splice(idx, 1);\n                    }\n                } else if (operation.type === 'put') {\n                    // 4.2.6.1\n                    if (operation.response == null) throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                        header: 'Cache.#batchCacheOperations',\n                        message: 'put operation should have an associated response'\n                    });\n                    // 4.2.6.2\n                    const r = operation.request;\n                    // 4.2.6.3\n                    if (!$16bc28ac822c9bc7$require$urlIsHttpHttpsScheme(r.url)) throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                        header: 'Cache.#batchCacheOperations',\n                        message: 'expected http or https scheme'\n                    });\n                    // 4.2.6.4\n                    if (r.method !== 'GET') throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                        header: 'Cache.#batchCacheOperations',\n                        message: 'not get method'\n                    });\n                    // 4.2.6.5\n                    if (operation.options != null) throw $16bc28ac822c9bc7$require$webidl.errors.exception({\n                        header: 'Cache.#batchCacheOperations',\n                        message: 'options must not be defined'\n                    });\n                    // 4.2.6.6\n                    requestResponses = this.#queryCache(operation.request);\n                    // 4.2.6.7\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        $aC1eT$assert(idx !== -1);\n                        // 4.2.6.7.1\n                        cache.splice(idx, 1);\n                    }\n                    // 4.2.6.8\n                    cache.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                    // 4.2.6.10\n                    addedItems.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                }\n                // 4.2.7\n                resultList.push([\n                    operation.request,\n                    operation.response\n                ]);\n            }\n            // 4.3\n            return resultList;\n        } catch (e) {\n            // 5.1\n            this.#relevantRequestResponseList.length = 0;\n            // 5.2\n            this.#relevantRequestResponseList = backupCache;\n            // 5.3\n            throw e;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */ #queryCache(requestQuery, options, targetStorage) {\n        /** @type {requestResponseList} */ const resultList = [];\n        const storage = targetStorage ?? this.#relevantRequestResponseList;\n        for (const requestResponse of storage){\n            const [cachedRequest, cachedResponse] = requestResponse;\n            if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);\n        }\n        return resultList;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */ #requestMatchesCachedItem(requestQuery, request, response = null, options) {\n        // if (options?.ignoreMethod === false && request.method === 'GET') {\n        //   return false\n        // }\n        const queryURL = new URL(requestQuery.url);\n        const cachedURL = new URL(request.url);\n        if (options?.ignoreSearch) {\n            cachedURL.search = '';\n            queryURL.search = '';\n        }\n        if (!$16bc28ac822c9bc7$require$urlEquals(queryURL, cachedURL, true)) return false;\n        if (response == null || options?.ignoreVary || !response.headersList.contains('vary')) return true;\n        const fieldValues = $16bc28ac822c9bc7$require$getFieldValues(response.headersList.get('vary'));\n        for (const fieldValue of fieldValues){\n            if (fieldValue === '*') return false;\n            const requestValue = request.headersList.get(fieldValue);\n            const queryValue = requestQuery.headersList.get(fieldValue);\n            // If one has the header and the other doesn't, or one has\n            // a different value than the other, return false\n            if (requestValue !== queryValue) return false;\n        }\n        return true;\n    }\n}\nObject.defineProperties($16bc28ac822c9bc7$var$Cache.prototype, {\n    [Symbol.toStringTag]: {\n        value: 'Cache',\n        configurable: true\n    },\n    match: $16bc28ac822c9bc7$require$kEnumerableProperty,\n    matchAll: $16bc28ac822c9bc7$require$kEnumerableProperty,\n    add: $16bc28ac822c9bc7$require$kEnumerableProperty,\n    addAll: $16bc28ac822c9bc7$require$kEnumerableProperty,\n    put: $16bc28ac822c9bc7$require$kEnumerableProperty,\n    delete: $16bc28ac822c9bc7$require$kEnumerableProperty,\n    keys: $16bc28ac822c9bc7$require$kEnumerableProperty\n});\nconst $16bc28ac822c9bc7$var$cacheQueryOptionConverters = [\n    {\n        key: 'ignoreSearch',\n        converter: $16bc28ac822c9bc7$require$webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: 'ignoreMethod',\n        converter: $16bc28ac822c9bc7$require$webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: 'ignoreVary',\n        converter: $16bc28ac822c9bc7$require$webidl.converters.boolean,\n        defaultValue: false\n    }\n];\n$16bc28ac822c9bc7$require$webidl.converters.CacheQueryOptions = $16bc28ac822c9bc7$require$webidl.dictionaryConverter($16bc28ac822c9bc7$var$cacheQueryOptionConverters);\n$16bc28ac822c9bc7$require$webidl.converters.MultiCacheQueryOptions = $16bc28ac822c9bc7$require$webidl.dictionaryConverter([\n    ...$16bc28ac822c9bc7$var$cacheQueryOptionConverters,\n    {\n        key: 'cacheName',\n        converter: $16bc28ac822c9bc7$require$webidl.converters.DOMString\n    }\n]);\n$16bc28ac822c9bc7$require$webidl.converters.Response = $16bc28ac822c9bc7$require$webidl.interfaceConverter($16bc28ac822c9bc7$require$Response);\n$16bc28ac822c9bc7$require$webidl.converters['sequence<RequestInfo>'] = $16bc28ac822c9bc7$require$webidl.sequenceConverter($16bc28ac822c9bc7$require$webidl.converters.RequestInfo);\n$16bc28ac822c9bc7$exports = {\n    Cache: $16bc28ac822c9bc7$var$Cache\n};\n\n\nexport {$16bc28ac822c9bc7$exports as default};\n//# sourceMappingURL=python-version-check.471ed536.js.map\n","'use strict'\n\nconst { kConstruct } = require('./symbols')\nconst { urlEquals, fieldValues: getFieldValues } = require('./util')\nconst { kEnumerableProperty, isDisturbed } = require('../core/util')\nconst { kHeadersList } = require('../core/symbols')\nconst { webidl } = require('../fetch/webidl')\nconst { Response, cloneResponse } = require('../fetch/response')\nconst { Request } = require('../fetch/request')\nconst { kState, kHeaders, kGuard, kRealm } = require('../fetch/symbols')\nconst { fetching } = require('../fetch/index')\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require('../fetch/util')\nconst assert = require('assert')\nconst { getGlobalDispatcher } = require('../global')\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' })\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    const p = await this.matchAll(request, options)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = new Response(response.body?.source ?? null)\n      const body = responseObject[kState].body\n      responseObject[kState] = response\n      responseObject[kState].body = body\n      responseObject[kHeaders][kHeadersList] = response.headersList\n      responseObject[kHeaders][kGuard] = 'immutable'\n\n      responseList.push(responseObject)\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' })\n\n    request = webidl.converters.RequestInfo(request)\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' })\n\n    requests = webidl.converters['sequence<RequestInfo>'](requests)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (const request of requests) {\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = request[kState]\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: 'Cache.addAll',\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = new Request(request)[kState]\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: 'Cache.addAll',\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        dispatcher: getGlobalDispatcher(),\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' })\n\n    request = webidl.converters.RequestInfo(request)\n    response = webidl.converters.Response(response)\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (request instanceof Request) {\n      innerRequest = request[kState]\n    } else { // 3.\n      innerRequest = new Request(request)[kState]\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = response[kState]\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: 'Cache.put',\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: 'Cache.put',\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' })\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (request instanceof Request) {\n      r = request[kState]\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = new Request(request)[kState]\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {readonly Request[]}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.CacheQueryOptions(options)\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = new Request('https://a')\n        requestObject[kState] = request\n        requestObject[kHeaders][kHeadersList] = request.headersList\n        requestObject[kHeaders][kGuard] = 'immutable'\n        requestObject[kRealm] = request.client\n\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(Response)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n"],"names":["$aC1eT$pythonversioncheck892401fajs","$aC1eT$pythonversioncheck28dd9cbbjs1","$aC1eT$pythonversioncheck7ed1514ejs1","$aC1eT$pythonversioncheckebf2a848js","$aC1eT$pythonversioncheck801bb0f1js","$aC1eT$pythonversioncheckc211052ejs1","$aC1eT$pythonversioncheckff3942bajs","$aC1eT$pythonversioncheck92c00e26js3","$aC1eT$pythonversioncheckdb834fc6js","$aC1eT$pythonversioncheck3f48d3eejs2","$aC1eT$pythonversioncheck2f8c5fadjs","$aC1eT$assert","$16bc28ac822c9bc7$exports","$16bc28ac822c9bc7$require$kConstruct","kConstruct","$16bc28ac822c9bc7$require$urlEquals","urlEquals","$16bc28ac822c9bc7$require$getFieldValues","$aC1eT$pythonversioncheck28dd9cbbjs","fieldValues","$16bc28ac822c9bc7$require$kEnumerableProperty","kEnumerableProperty","$16bc28ac822c9bc7$require$isDisturbed","$aC1eT$pythonversioncheck7ed1514ejs","isDisturbed","$16bc28ac822c9bc7$require$kHeadersList","kHeadersList","$16bc28ac822c9bc7$require$webidl","webidl","$16bc28ac822c9bc7$require$Response","Response","$16bc28ac822c9bc7$require$cloneResponse","$aC1eT$pythonversioncheckc211052ejs","cloneResponse","$16bc28ac822c9bc7$require$Request","Request","$16bc28ac822c9bc7$require$kState","kState","$16bc28ac822c9bc7$require$kHeaders","$aC1eT$pythonversioncheck92c00e26js1","kHeaders","$16bc28ac822c9bc7$require$kGuard","$aC1eT$pythonversioncheck92c00e26js","kGuard","$16bc28ac822c9bc7$require$kRealm","$aC1eT$pythonversioncheck92c00e26js2","kRealm","$16bc28ac822c9bc7$require$fetching","fetching","$16bc28ac822c9bc7$require$urlIsHttpHttpsScheme","urlIsHttpHttpsScheme","$16bc28ac822c9bc7$require$createDeferredPromise","$aC1eT$pythonversioncheck3f48d3eejs","createDeferredPromise","$16bc28ac822c9bc7$require$readAllBytes","$aC1eT$pythonversioncheck3f48d3eejs1","readAllBytes","$16bc28ac822c9bc7$require$getGlobalDispatcher","getGlobalDispatcher","$16bc28ac822c9bc7$var$Cache","arguments","illegalConstructor","match","request","options","brandCheck","argumentLengthCheck","header","converters","RequestInfo","CacheQueryOptions","p","matchAll","length","undefined","r","method","ignoreMethod","responses","requestResponse","push","responseList","response","responseObject","body","source","headersList","Object","freeze","add","requests","responseArrayPromise","addAll","responsePromises","requestList","url","errors","exception","message","fetchControllers","initiator","destination","responsePromise","dispatcher","processResponse","type","status","reject","contains","fieldValue","get","controller","abort","processResponseEndOfBody","aborted","DOMException","resolve","promise","Promise","all","operations","index","operation","cacheJobPromise","errorData","e","queueMicrotask","put","innerRequest","innerResponse","stream","locked","clonedResponse","bodyReadPromise","getReader","then","bytes","delete","requestResponses","keys","requestObject","client","cache","backupCache","addedItems","resultList","idx","indexOf","splice","requestQuery","targetStorage","cachedRequest","cachedResponse","queryURL","URL","cachedURL","ignoreSearch","search","ignoreVary","requestValue","defineProperties","prototype","Symbol","toStringTag","value","configurable","$16bc28ac822c9bc7$var$cacheQueryOptionConverters","key","converter","boolean","defaultValue","dictionaryConverter","MultiCacheQueryOptions","DOMString","interfaceConverter","sequenceConverter","Cache","default"],"version":3,"file":"python-version-check.471ed536.js.map","sourceRoot":"../"}