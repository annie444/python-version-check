{"mappings":"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","sources":["<anon>","node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js"],"sourcesContent":["import $hdghK$pythonversioncheck329fae56js from \"./python-version-check.329fae56.js\";\nimport $hdghK$pythonversioncheck54444555js from \"./python-version-check.54444555.js\";\nimport $hdghK$pythonversionchecke046c214js from \"./python-version-check.e046c214.js\";\n\nvar $e940e348f732fb42$exports = {};\n'use strict';\n\n\n\nconst $e940e348f732fb42$var$RE_CHARSET = /^charset$/i;\n$e940e348f732fb42$var$UrlEncoded.detect = /^application\\/x-www-form-urlencoded/i;\nfunction $e940e348f732fb42$var$UrlEncoded(boy, cfg) {\n    const limits = cfg.limits;\n    const parsedConType = cfg.parsedConType;\n    this.boy = boy;\n    this.fieldSizeLimit = $hdghK$pythonversionchecke046c214js(limits, 'fieldSize', 1048576);\n    this.fieldNameSizeLimit = $hdghK$pythonversionchecke046c214js(limits, 'fieldNameSize', 100);\n    this.fieldsLimit = $hdghK$pythonversionchecke046c214js(limits, 'fields', Infinity);\n    let charset;\n    for(var i = 0, len = parsedConType.length; i < len; ++i)if (Array.isArray(parsedConType[i]) && $e940e348f732fb42$var$RE_CHARSET.test(parsedConType[i][0])) {\n        charset = parsedConType[i][1].toLowerCase();\n        break;\n    }\n    if (charset === undefined) charset = cfg.defCharset || 'utf8';\n    this.decoder = new $hdghK$pythonversioncheck329fae56js();\n    this.charset = charset;\n    this._fields = 0;\n    this._state = 'key';\n    this._checkingBytes = true;\n    this._bytesKey = 0;\n    this._bytesVal = 0;\n    this._key = '';\n    this._val = '';\n    this._keyTrunc = false;\n    this._valTrunc = false;\n    this._hitLimit = false;\n}\n$e940e348f732fb42$var$UrlEncoded.prototype.write = function(data, cb) {\n    if (this._fields === this.fieldsLimit) {\n        if (!this.boy.hitFieldsLimit) {\n            this.boy.hitFieldsLimit = true;\n            this.boy.emit('fieldsLimit');\n        }\n        return cb();\n    }\n    let idxeq;\n    let idxamp;\n    let i;\n    let p = 0;\n    const len = data.length;\n    while(p < len)if (this._state === 'key') {\n        idxeq = idxamp = undefined;\n        for(i = p; i < len; ++i){\n            if (!this._checkingBytes) ++p;\n            if (data[i] === 0x3D /* = */ ) {\n                idxeq = i;\n                break;\n            } else if (data[i] === 0x26 /* & */ ) {\n                idxamp = i;\n                break;\n            }\n            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n                this._hitLimit = true;\n                break;\n            } else if (this._checkingBytes) ++this._bytesKey;\n        }\n        if (idxeq !== undefined) {\n            // key with assignment\n            if (idxeq > p) this._key += this.decoder.write(data.toString('binary', p, idxeq));\n            this._state = 'val';\n            this._hitLimit = false;\n            this._checkingBytes = true;\n            this._val = '';\n            this._bytesVal = 0;\n            this._valTrunc = false;\n            this.decoder.reset();\n            p = idxeq + 1;\n        } else if (idxamp !== undefined) {\n            // key with no assignment\n            ++this._fields;\n            let key;\n            const keyTrunc = this._keyTrunc;\n            if (idxamp > p) key = this._key += this.decoder.write(data.toString('binary', p, idxamp));\n            else key = this._key;\n            this._hitLimit = false;\n            this._checkingBytes = true;\n            this._key = '';\n            this._bytesKey = 0;\n            this._keyTrunc = false;\n            this.decoder.reset();\n            if (key.length) this.boy.emit('field', $hdghK$pythonversioncheck54444555js(key, 'binary', this.charset), '', keyTrunc, false);\n            p = idxamp + 1;\n            if (this._fields === this.fieldsLimit) return cb();\n        } else if (this._hitLimit) {\n            // we may not have hit the actual limit if there are encoded bytes...\n            if (i > p) this._key += this.decoder.write(data.toString('binary', p, i));\n            p = i;\n            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n                // yep, we actually did hit the limit\n                this._checkingBytes = false;\n                this._keyTrunc = true;\n            }\n        } else {\n            if (p < len) this._key += this.decoder.write(data.toString('binary', p));\n            p = len;\n        }\n    } else {\n        idxamp = undefined;\n        for(i = p; i < len; ++i){\n            if (!this._checkingBytes) ++p;\n            if (data[i] === 0x26 /* & */ ) {\n                idxamp = i;\n                break;\n            }\n            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n                this._hitLimit = true;\n                break;\n            } else if (this._checkingBytes) ++this._bytesVal;\n        }\n        if (idxamp !== undefined) {\n            ++this._fields;\n            if (idxamp > p) this._val += this.decoder.write(data.toString('binary', p, idxamp));\n            this.boy.emit('field', $hdghK$pythonversioncheck54444555js(this._key, 'binary', this.charset), $hdghK$pythonversioncheck54444555js(this._val, 'binary', this.charset), this._keyTrunc, this._valTrunc);\n            this._state = 'key';\n            this._hitLimit = false;\n            this._checkingBytes = true;\n            this._key = '';\n            this._bytesKey = 0;\n            this._keyTrunc = false;\n            this.decoder.reset();\n            p = idxamp + 1;\n            if (this._fields === this.fieldsLimit) return cb();\n        } else if (this._hitLimit) {\n            // we may not have hit the actual limit if there are encoded bytes...\n            if (i > p) this._val += this.decoder.write(data.toString('binary', p, i));\n            p = i;\n            if (this._val === '' && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n                // yep, we actually did hit the limit\n                this._checkingBytes = false;\n                this._valTrunc = true;\n            }\n        } else {\n            if (p < len) this._val += this.decoder.write(data.toString('binary', p));\n            p = len;\n        }\n    }\n    cb();\n};\n$e940e348f732fb42$var$UrlEncoded.prototype.end = function() {\n    if (this.boy._done) return;\n    if (this._state === 'key' && this._key.length > 0) this.boy.emit('field', $hdghK$pythonversioncheck54444555js(this._key, 'binary', this.charset), '', this._keyTrunc, false);\n    else if (this._state === 'val') this.boy.emit('field', $hdghK$pythonversioncheck54444555js(this._key, 'binary', this.charset), $hdghK$pythonversioncheck54444555js(this._val, 'binary', this.charset), this._keyTrunc, this._valTrunc);\n    this.boy._done = true;\n    this.boy.emit('finish');\n};\n$e940e348f732fb42$exports = $e940e348f732fb42$var$UrlEncoded;\n\n\nexport {$e940e348f732fb42$exports as default};\n//# sourceMappingURL=python-version-check.89a0ce5d.js.map\n","'use strict'\n\nconst Decoder = require('../utils/Decoder')\nconst decodeText = require('../utils/decodeText')\nconst getLimit = require('../utils/getLimit')\n\nconst RE_CHARSET = /^charset$/i\n\nUrlEncoded.detect = /^application\\/x-www-form-urlencoded/i\nfunction UrlEncoded (boy, cfg) {\n  const limits = cfg.limits\n  const parsedConType = cfg.parsedConType\n  this.boy = boy\n\n  this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)\n  this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100)\n  this.fieldsLimit = getLimit(limits, 'fields', Infinity)\n\n  let charset\n  for (var i = 0, len = parsedConType.length; i < len; ++i) { // eslint-disable-line no-var\n    if (Array.isArray(parsedConType[i]) &&\n        RE_CHARSET.test(parsedConType[i][0])) {\n      charset = parsedConType[i][1].toLowerCase()\n      break\n    }\n  }\n\n  if (charset === undefined) { charset = cfg.defCharset || 'utf8' }\n\n  this.decoder = new Decoder()\n  this.charset = charset\n  this._fields = 0\n  this._state = 'key'\n  this._checkingBytes = true\n  this._bytesKey = 0\n  this._bytesVal = 0\n  this._key = ''\n  this._val = ''\n  this._keyTrunc = false\n  this._valTrunc = false\n  this._hitLimit = false\n}\n\nUrlEncoded.prototype.write = function (data, cb) {\n  if (this._fields === this.fieldsLimit) {\n    if (!this.boy.hitFieldsLimit) {\n      this.boy.hitFieldsLimit = true\n      this.boy.emit('fieldsLimit')\n    }\n    return cb()\n  }\n\n  let idxeq; let idxamp; let i; let p = 0; const len = data.length\n\n  while (p < len) {\n    if (this._state === 'key') {\n      idxeq = idxamp = undefined\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes) { ++p }\n        if (data[i] === 0x3D/* = */) {\n          idxeq = i\n          break\n        } else if (data[i] === 0x26/* & */) {\n          idxamp = i\n          break\n        }\n        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n          this._hitLimit = true\n          break\n        } else if (this._checkingBytes) { ++this._bytesKey }\n      }\n\n      if (idxeq !== undefined) {\n        // key with assignment\n        if (idxeq > p) { this._key += this.decoder.write(data.toString('binary', p, idxeq)) }\n        this._state = 'val'\n\n        this._hitLimit = false\n        this._checkingBytes = true\n        this._val = ''\n        this._bytesVal = 0\n        this._valTrunc = false\n        this.decoder.reset()\n\n        p = idxeq + 1\n      } else if (idxamp !== undefined) {\n        // key with no assignment\n        ++this._fields\n        let key; const keyTrunc = this._keyTrunc\n        if (idxamp > p) { key = (this._key += this.decoder.write(data.toString('binary', p, idxamp))) } else { key = this._key }\n\n        this._hitLimit = false\n        this._checkingBytes = true\n        this._key = ''\n        this._bytesKey = 0\n        this._keyTrunc = false\n        this.decoder.reset()\n\n        if (key.length) {\n          this.boy.emit('field', decodeText(key, 'binary', this.charset),\n            '',\n            keyTrunc,\n            false)\n        }\n\n        p = idxamp + 1\n        if (this._fields === this.fieldsLimit) { return cb() }\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p) { this._key += this.decoder.write(data.toString('binary', p, i)) }\n        p = i\n        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false\n          this._keyTrunc = true\n        }\n      } else {\n        if (p < len) { this._key += this.decoder.write(data.toString('binary', p)) }\n        p = len\n      }\n    } else {\n      idxamp = undefined\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes) { ++p }\n        if (data[i] === 0x26/* & */) {\n          idxamp = i\n          break\n        }\n        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n          this._hitLimit = true\n          break\n        } else if (this._checkingBytes) { ++this._bytesVal }\n      }\n\n      if (idxamp !== undefined) {\n        ++this._fields\n        if (idxamp > p) { this._val += this.decoder.write(data.toString('binary', p, idxamp)) }\n        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n          decodeText(this._val, 'binary', this.charset),\n          this._keyTrunc,\n          this._valTrunc)\n        this._state = 'key'\n\n        this._hitLimit = false\n        this._checkingBytes = true\n        this._key = ''\n        this._bytesKey = 0\n        this._keyTrunc = false\n        this.decoder.reset()\n\n        p = idxamp + 1\n        if (this._fields === this.fieldsLimit) { return cb() }\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p) { this._val += this.decoder.write(data.toString('binary', p, i)) }\n        p = i\n        if ((this._val === '' && this.fieldSizeLimit === 0) ||\n            (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false\n          this._valTrunc = true\n        }\n      } else {\n        if (p < len) { this._val += this.decoder.write(data.toString('binary', p)) }\n        p = len\n      }\n    }\n  }\n  cb()\n}\n\nUrlEncoded.prototype.end = function () {\n  if (this.boy._done) { return }\n\n  if (this._state === 'key' && this._key.length > 0) {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n      '',\n      this._keyTrunc,\n      false)\n  } else if (this._state === 'val') {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n      decodeText(this._val, 'binary', this.charset),\n      this._keyTrunc,\n      this._valTrunc)\n  }\n  this.boy._done = true\n  this.boy.emit('finish')\n}\n\nmodule.exports = UrlEncoded\n"],"names":["$hdghK$pythonversioncheck329fae56js","$hdghK$pythonversioncheck54444555js","$hdghK$pythonversionchecke046c214js","$e940e348f732fb42$exports","$e940e348f732fb42$var$RE_CHARSET","$e940e348f732fb42$var$UrlEncoded","boy","cfg","charset","limits","parsedConType","fieldSizeLimit","fieldNameSizeLimit","fieldsLimit","Infinity","i","len","length","Array","isArray","test","toLowerCase","undefined","defCharset","decoder","_fields","_state","_checkingBytes","_bytesKey","_bytesVal","_key","_val","_keyTrunc","_valTrunc","_hitLimit","detect","prototype","write","data","cb","idxeq","idxamp","hitFieldsLimit","emit","p","toString","reset","key","keyTrunc","end","_done","default"],"version":3,"file":"python-version-check.89a0ce5d.js.map","sourceRoot":"../"}