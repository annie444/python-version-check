{"mappings":"A,O,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,Q,C,C,Q,C,K,Q,A,W,M,Q,A,Q,gB,C,C,iB,C,K,Y,A,Q,kB,C,K,Y,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,MCwBI,EApBE,IAAA,EAAA,EAAA,kBAAA,CAAA,EAAA,sDAAA,UAAA,CAAA,EAAA,sDAAA,oBAAA,CAAA,EAAA,sDAAA,mBAAA,CAAA,EAAA,qDAAA,qBAAA,CAAA,EAAA,sDAAA,aAAA,CAQA,EAAA,EAAA,QAAA,CACA,EAAA,EAAA,MAAA,CACA,EAAA,EAAA,MAAA,CACA,EAAA,qDAAA,YAAA,CAAA,EAAA,EAAA,eAAA,CAEA,EAAA,EAAA,SAAA,CAEA,EAAA,sDAAA,SAAA,CAEA,EAAA,EAAA,IAAA,CACA,EAAA,qDAAA,aAAA,CAAA,EAAA,EAAA,kBAAA,CAGN,GAAI,CACF,IAAM,EAAS,0CACf,EAAS,AAAC,GAAQ,EAAO,SAAS,CAAC,EAAG,EACxC,CAAE,KAAM,CACN,EAAS,AAAC,GAAQ,KAAK,KAAK,CAAC,KAAK,MAAM,CAAC,GAC3C,CAEA,IAAI,EAAiB,WAAW,cAAc,CAGxC,EAAO,AAnBP,GAkBN,EAEM,EAAc,IAAI,YAClB,EAAc,IAAI,YAGxB,SAAS,EAAa,CAAM,CAAE,EAAY,CAAA,CAAK,EACzC,AAAC,GACH,CAAA,EAAiB,CADnB,EAKA,IAAI,EAAS,KAyBb,EAAO,EArBL,EADE,aAAkB,EACX,EACA,EAAW,GAGX,EAAO,MAAM,GAIb,IAAI,EAAe,CAC1B,MAAM,KAAM,CAAU,EACpB,EAAW,OAAO,CAChB,AAAkB,UAAlB,OAAO,EAAsB,EAAY,MAAM,CAAC,G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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js"],"sourcesContent":["import $8EnIj$pythonversioncheck5a6f079bjs from \"./python-version-check.5a6f079b.js\";\nimport $8EnIj$pythonversioncheck7ed1514ejs3 from \"./python-version-check.7ed1514e.js\";\nimport $8EnIj$pythonversioncheck3f48d3eejs5 from \"./python-version-check.3f48d3ee.js\";\nimport $8EnIj$pythonversioncheck34871282js from \"./python-version-check.34871282.js\";\nimport $8EnIj$pythonversioncheck92c00e26js from \"./python-version-check.92c00e26.js\";\nimport $8EnIj$pythonversioncheck801bb0f1js from \"./python-version-check.801bb0f1.js\";\nimport $8EnIj$pythonversioncheck863e006ejs1 from \"./python-version-check.863e006e.js\";\nimport $8EnIj$pythonversioncheckebf2a848js from \"./python-version-check.ebf2a848.js\";\nimport $8EnIj$pythonversionchecka81ff9ccjs from \"./python-version-check.a81ff9cc.js\";\nimport $8EnIj$pythonversioncheck685b5bb2js1 from \"./python-version-check.685b5bb2.js\";\nimport {Blob as $8EnIj$Blob, File as $8EnIj$File} from \"buffer\";\nimport * as $8EnIj$assert from \"assert\";\nimport {isUint8Array as $8EnIj$isUint8Array, isArrayBuffer as $8EnIj$isArrayBuffer} from \"util/types\";\nimport {ReadableStream as $8EnIj$ReadableStream} from \"stream/web\";\n\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5a65\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5a65\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"9IGRA\", function(module, exports) {\n'use strict';\n\n\n\nvar $01d381f309bc1532$require$ReadableStreamFrom = $8EnIj$pythonversioncheck3f48d3eejs5.ReadableStreamFrom;\nvar $01d381f309bc1532$require$isBlobLike = $8EnIj$pythonversioncheck3f48d3eejs2.isBlobLike;\nvar $01d381f309bc1532$require$isReadableStreamLike = $8EnIj$pythonversioncheck3f48d3eejs3.isReadableStreamLike;\nvar $01d381f309bc1532$require$readableStreamClose = $8EnIj$pythonversioncheck3f48d3eejs4.readableStreamClose;\nvar $01d381f309bc1532$require$createDeferredPromise = $8EnIj$pythonversioncheck3f48d3eejs.createDeferredPromise;\nvar $01d381f309bc1532$require$fullyReadBody = $8EnIj$pythonversioncheck3f48d3eejs1.fullyReadBody;\n\nvar $01d381f309bc1532$require$FormData = $8EnIj$pythonversioncheck34871282js.FormData;\n\nvar $01d381f309bc1532$require$kState = $8EnIj$pythonversioncheck92c00e26js.kState;\n\nvar $01d381f309bc1532$require$webidl = $8EnIj$pythonversioncheck801bb0f1js.webidl;\n\nvar $01d381f309bc1532$require$DOMException = $8EnIj$pythonversioncheck863e006ejs.DOMException;\nvar $01d381f309bc1532$require$structuredClone = $8EnIj$pythonversioncheck863e006ejs1.structuredClone;\n\nvar $01d381f309bc1532$require$Blob = $8EnIj$Blob;\nvar $01d381f309bc1532$require$NativeFile = $8EnIj$File;\n\nvar $01d381f309bc1532$require$kBodyUsed = $8EnIj$pythonversioncheckebf2a848js.kBodyUsed;\n\n\nvar $01d381f309bc1532$require$isErrored = $8EnIj$pythonversioncheck7ed1514ejs2.isErrored;\n\nvar $01d381f309bc1532$require$isUint8Array = $8EnIj$isUint8Array;\nvar $01d381f309bc1532$require$isArrayBuffer = $8EnIj$isArrayBuffer;\n\nvar $01d381f309bc1532$require$UndiciFile = $8EnIj$pythonversionchecka81ff9ccjs.File;\n\nvar $01d381f309bc1532$require$parseMIMEType = $8EnIj$pythonversioncheck685b5bb2js.parseMIMEType;\nvar $01d381f309bc1532$require$serializeAMimeType = $8EnIj$pythonversioncheck685b5bb2js1.serializeAMimeType;\nlet $01d381f309bc1532$var$random;\n\ntry {\n    const crypto = $01d381f309bc1532$import$89770a49fac40caf;\n    $01d381f309bc1532$var$random = (max)=>crypto.randomInt(0, max);\n} catch  {\n    $01d381f309bc1532$var$random = (max)=>Math.floor(Math.random(max));\n}\nlet $01d381f309bc1532$var$ReadableStream = globalThis.ReadableStream;\n/** @type {globalThis['File']} */ const $01d381f309bc1532$var$File = $01d381f309bc1532$require$NativeFile ?? $01d381f309bc1532$require$UndiciFile;\nconst $01d381f309bc1532$var$textEncoder = new TextEncoder();\nconst $01d381f309bc1532$var$textDecoder = new TextDecoder();\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction $01d381f309bc1532$var$extractBody(object, keepalive = false) {\n    if (!$01d381f309bc1532$var$ReadableStream) $01d381f309bc1532$var$ReadableStream = $8EnIj$ReadableStream;\n    // 1. Let stream be null.\n    let stream = null;\n    // 2. If object is a ReadableStream object, then set stream to object.\n    if (object instanceof $01d381f309bc1532$var$ReadableStream) stream = object;\n    else if ($01d381f309bc1532$require$isBlobLike(object)) // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream();\n    else // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream.\n    stream = new $01d381f309bc1532$var$ReadableStream({\n        async pull (controller) {\n            controller.enqueue(typeof source === 'string' ? $01d381f309bc1532$var$textEncoder.encode(source) : source);\n            queueMicrotask(()=>$01d381f309bc1532$require$readableStreamClose(controller));\n        },\n        start () {},\n        type: undefined\n    });\n    // 5. Assert: stream is a ReadableStream object.\n    $8EnIj$assert($01d381f309bc1532$require$isReadableStreamLike(stream));\n    // 6. Let action be null.\n    let action = null;\n    // 7. Let source be null.\n    let source = null;\n    // 8. Let length be null.\n    let length = null;\n    // 9. Let type be null.\n    let type = null;\n    // 10. Switch on object:\n    if (typeof object === 'string') {\n        // Set source to the UTF-8 encoding of object.\n        // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n        source = object;\n        // Set type to `text/plain;charset=UTF-8`.\n        type = 'text/plain;charset=UTF-8';\n    } else if (object instanceof URLSearchParams) {\n        // URLSearchParams\n        // spec says to run application/x-www-form-urlencoded on body.list\n        // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n        // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n        // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n        // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n        source = object.toString();\n        // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n        type = 'application/x-www-form-urlencoded;charset=UTF-8';\n    } else if ($01d381f309bc1532$require$isArrayBuffer(object)) // BufferSource/ArrayBuffer\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice());\n    else if (ArrayBuffer.isView(object)) // BufferSource/ArrayBufferView\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n    else if ($8EnIj$pythonversioncheck7ed1514ejs3.isFormDataLike(object)) {\n        const boundary = `----formdata-undici-0${`${$01d381f309bc1532$var$random(1e11)}`.padStart(11, '0')}`;\n        const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n        /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ const escape = (str)=>str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n        const normalizeLinefeeds = (value)=>value.replace(/\\r?\\n|\\r/g, '\\r\\n');\n        // Set action to this step: run the multipart/form-data\n        // encoding algorithm, with object’s entry list and UTF-8.\n        // - This ensures that the body is immutable and can't be changed afterwords\n        // - That the content-length is calculated in advance.\n        // - And that all parts are pre-encoded and ready to be sent.\n        const blobParts = [];\n        const rn = new Uint8Array([\n            13,\n            10\n        ]) // '\\r\\n'\n        ;\n        length = 0;\n        let hasUnknownSizeValue = false;\n        for (const [name, value] of object)if (typeof value === 'string') {\n            const chunk = $01d381f309bc1532$var$textEncoder.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n            blobParts.push(chunk);\n            length += chunk.byteLength;\n        } else {\n            const chunk = $01d381f309bc1532$var$textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n            blobParts.push(chunk, value, rn);\n            if (typeof value.size === 'number') length += chunk.byteLength + value.size + rn.byteLength;\n            else hasUnknownSizeValue = true;\n        }\n        const chunk = $01d381f309bc1532$var$textEncoder.encode(`--${boundary}--`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n        if (hasUnknownSizeValue) length = null;\n        // Set source to object.\n        source = object;\n        action = async function*() {\n            for (const part of blobParts)if (part.stream) yield* part.stream();\n            else yield part;\n        };\n        // Set type to `multipart/form-data; boundary=`,\n        // followed by the multipart/form-data boundary string generated\n        // by the multipart/form-data encoding algorithm.\n        type = 'multipart/form-data; boundary=' + boundary;\n    } else if ($01d381f309bc1532$require$isBlobLike(object)) {\n        // Blob\n        // Set source to object.\n        source = object;\n        // Set length to object’s size.\n        length = object.size;\n        // If object’s type attribute is not the empty byte sequence, set\n        // type to its value.\n        if (object.type) type = object.type;\n    } else if (typeof object[Symbol.asyncIterator] === 'function') {\n        // If keepalive is true, then throw a TypeError.\n        if (keepalive) throw new TypeError('keepalive');\n        // If object is disturbed or locked, then throw a TypeError.\n        if ($8EnIj$pythonversioncheck7ed1514ejs1.isDisturbed(object) || object.locked) throw new TypeError('Response body object should not be disturbed or locked');\n        stream = object instanceof $01d381f309bc1532$var$ReadableStream ? object : $01d381f309bc1532$require$ReadableStreamFrom(object);\n    }\n    // 11. If source is a byte sequence, then set action to a\n    // step that returns source and length to source’s length.\n    if (typeof source === 'string' || $8EnIj$pythonversioncheck7ed1514ejs.isBuffer(source)) length = Buffer.byteLength(source);\n    // 12. If action is non-null, then run these steps in in parallel:\n    if (action != null) {\n        // Run action.\n        let iterator;\n        stream = new $01d381f309bc1532$var$ReadableStream({\n            async start () {\n                iterator = action(object)[Symbol.asyncIterator]();\n            },\n            async pull (controller) {\n                const { value: value, done: done } = await iterator.next();\n                if (done) // When running action is done, close stream.\n                queueMicrotask(()=>{\n                    controller.close();\n                });\n                else // Whenever one or more bytes are available and stream is not errored,\n                // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n                // bytes into stream.\n                if (!$01d381f309bc1532$require$isErrored(stream)) controller.enqueue(new Uint8Array(value));\n                return controller.desiredSize > 0;\n            },\n            async cancel (reason) {\n                await iterator.return();\n            },\n            type: undefined\n        });\n    }\n    // 13. Let body be a body whose stream is stream, source is source,\n    // and length is length.\n    const body = {\n        stream: stream,\n        source: source,\n        length: length\n    };\n    // 14. Return (body, type).\n    return [\n        body,\n        type\n    ];\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction $01d381f309bc1532$var$safelyExtractBody(object, keepalive = false) {\n    if (!$01d381f309bc1532$var$ReadableStream) // istanbul ignore next\n    $01d381f309bc1532$var$ReadableStream = $8EnIj$ReadableStream;\n    // To safely extract a body and a `Content-Type` value from\n    // a byte sequence or BodyInit object object, run these steps:\n    // 1. If object is a ReadableStream object, then:\n    if (object instanceof $01d381f309bc1532$var$ReadableStream) {\n        // Assert: object is neither disturbed nor locked.\n        // istanbul ignore next\n        $8EnIj$assert(!$8EnIj$pythonversioncheck7ed1514ejs1.isDisturbed(object), 'The body has already been consumed.');\n        // istanbul ignore next\n        $8EnIj$assert(!object.locked, 'The stream is locked.');\n    }\n    // 2. Return the results of extracting object.\n    return $01d381f309bc1532$var$extractBody(object, keepalive);\n}\nfunction $01d381f309bc1532$var$cloneBody(body) {\n    // To clone a body body, run these steps:\n    // https://fetch.spec.whatwg.org/#concept-body-clone\n    // 1. Let « out1, out2 » be the result of teeing body’s stream.\n    const [out1, out2] = body.stream.tee();\n    const out2Clone = $01d381f309bc1532$require$structuredClone(out2, {\n        transfer: [\n            out2\n        ]\n    });\n    // This, for whatever reasons, unrefs out2Clone which allows\n    // the process to exit by itself.\n    const [, finalClone] = out2Clone.tee();\n    // 2. Set body’s stream to out1.\n    body.stream = out1;\n    // 3. Return a body whose stream is out2 and other members are copied from body.\n    return {\n        stream: finalClone,\n        length: body.length,\n        source: body.source\n    };\n}\nasync function* $01d381f309bc1532$var$consumeBody(body) {\n    if (body) {\n        if ($01d381f309bc1532$require$isUint8Array(body)) yield body;\n        else {\n            const stream = body.stream;\n            if ($8EnIj$pythonversioncheck7ed1514ejs1.isDisturbed(stream)) throw new TypeError('The body has already been consumed.');\n            if (stream.locked) throw new TypeError('The stream is locked.');\n            // Compat.\n            stream[$01d381f309bc1532$require$kBodyUsed] = true;\n            yield* stream;\n        }\n    }\n}\nfunction $01d381f309bc1532$var$throwIfAborted(state) {\n    if (state.aborted) throw new $01d381f309bc1532$require$DOMException('The operation was aborted.', 'AbortError');\n}\nfunction $01d381f309bc1532$var$bodyMixinMethods(instance) {\n    const methods = {\n        blob () {\n            // The blob() method steps are to return the result of\n            // running consume body with this and the following step\n            // given a byte sequence bytes: return a Blob whose\n            // contents are bytes and whose type attribute is this’s\n            // MIME type.\n            return $01d381f309bc1532$var$specConsumeBody(this, (bytes)=>{\n                let mimeType = $01d381f309bc1532$var$bodyMimeType(this);\n                if (mimeType === 'failure') mimeType = '';\n                else if (mimeType) mimeType = $01d381f309bc1532$require$serializeAMimeType(mimeType);\n                // Return a Blob whose contents are bytes and type attribute\n                // is mimeType.\n                return new $01d381f309bc1532$require$Blob([\n                    bytes\n                ], {\n                    type: mimeType\n                });\n            }, instance);\n        },\n        arrayBuffer () {\n            // The arrayBuffer() method steps are to return the result\n            // of running consume body with this and the following step\n            // given a byte sequence bytes: return a new ArrayBuffer\n            // whose contents are bytes.\n            return $01d381f309bc1532$var$specConsumeBody(this, (bytes)=>{\n                return new Uint8Array(bytes).buffer;\n            }, instance);\n        },\n        text () {\n            // The text() method steps are to return the result of running\n            // consume body with this and UTF-8 decode.\n            return $01d381f309bc1532$var$specConsumeBody(this, $01d381f309bc1532$var$utf8DecodeBytes, instance);\n        },\n        json () {\n            // The json() method steps are to return the result of running\n            // consume body with this and parse JSON from bytes.\n            return $01d381f309bc1532$var$specConsumeBody(this, $01d381f309bc1532$var$parseJSONFromBytes, instance);\n        },\n        async formData () {\n            $01d381f309bc1532$require$webidl.brandCheck(this, instance);\n            $01d381f309bc1532$var$throwIfAborted(this[$01d381f309bc1532$require$kState]);\n            const contentType = this.headers.get('Content-Type');\n            // If mimeType’s essence is \"multipart/form-data\", then:\n            if (/multipart\\/form-data/.test(contentType)) {\n                const headers = {};\n                for (const [key, value] of this.headers)headers[key.toLowerCase()] = value;\n                const responseFormData = new $01d381f309bc1532$require$FormData();\n                let busboy;\n                try {\n                    busboy = new $8EnIj$pythonversioncheck5a6f079bjs({\n                        headers: headers,\n                        preservePath: true\n                    });\n                } catch (err) {\n                    throw new $01d381f309bc1532$require$DOMException(`${err}`, 'AbortError');\n                }\n                busboy.on('field', (name, value)=>{\n                    responseFormData.append(name, value);\n                });\n                busboy.on('file', (name, value, filename, encoding, mimeType)=>{\n                    const chunks = [];\n                    if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {\n                        let base64chunk = '';\n                        value.on('data', (chunk)=>{\n                            base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '');\n                            const end = base64chunk.length - base64chunk.length % 4;\n                            chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));\n                            base64chunk = base64chunk.slice(end);\n                        });\n                        value.on('end', ()=>{\n                            chunks.push(Buffer.from(base64chunk, 'base64'));\n                            responseFormData.append(name, new $01d381f309bc1532$var$File(chunks, filename, {\n                                type: mimeType\n                            }));\n                        });\n                    } else {\n                        value.on('data', (chunk)=>{\n                            chunks.push(chunk);\n                        });\n                        value.on('end', ()=>{\n                            responseFormData.append(name, new $01d381f309bc1532$var$File(chunks, filename, {\n                                type: mimeType\n                            }));\n                        });\n                    }\n                });\n                const busboyResolve = new Promise((resolve, reject)=>{\n                    busboy.on('finish', resolve);\n                    busboy.on('error', (err)=>reject(new TypeError(err)));\n                });\n                if (this.body !== null) for await (const chunk of $01d381f309bc1532$var$consumeBody(this[$01d381f309bc1532$require$kState].body))busboy.write(chunk);\n                busboy.end();\n                await busboyResolve;\n                return responseFormData;\n            } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n                // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n                // 1. Let entries be the result of parsing bytes.\n                let entries;\n                try {\n                    let text = '';\n                    // application/x-www-form-urlencoded parser will keep the BOM.\n                    // https://url.spec.whatwg.org/#concept-urlencoded-parser\n                    // Note that streaming decoder is stateful and cannot be reused\n                    const streamingDecoder = new TextDecoder('utf-8', {\n                        ignoreBOM: true\n                    });\n                    for await (const chunk of $01d381f309bc1532$var$consumeBody(this[$01d381f309bc1532$require$kState].body)){\n                        if (!$01d381f309bc1532$require$isUint8Array(chunk)) throw new TypeError('Expected Uint8Array chunk');\n                        text += streamingDecoder.decode(chunk, {\n                            stream: true\n                        });\n                    }\n                    text += streamingDecoder.decode();\n                    entries = new URLSearchParams(text);\n                } catch (err) {\n                    // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n                    // 2. If entries is failure, then throw a TypeError.\n                    throw Object.assign(new TypeError(), {\n                        cause: err\n                    });\n                }\n                // 3. Return a new FormData object whose entries are entries.\n                const formData = new $01d381f309bc1532$require$FormData();\n                for (const [name, value] of entries)formData.append(name, value);\n                return formData;\n            } else {\n                // Wait a tick before checking if the request has been aborted.\n                // Otherwise, a TypeError can be thrown when an AbortError should.\n                await Promise.resolve();\n                $01d381f309bc1532$var$throwIfAborted(this[$01d381f309bc1532$require$kState]);\n                // Otherwise, throw a TypeError.\n                throw $01d381f309bc1532$require$webidl.errors.exception({\n                    header: `${instance.name}.formData`,\n                    message: 'Could not parse content as FormData.'\n                });\n            }\n        }\n    };\n    return methods;\n}\nfunction $01d381f309bc1532$var$mixinBody(prototype) {\n    Object.assign(prototype.prototype, $01d381f309bc1532$var$bodyMixinMethods(prototype));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */ async function $01d381f309bc1532$var$specConsumeBody(object, convertBytesToJSValue, instance) {\n    $01d381f309bc1532$require$webidl.brandCheck(object, instance);\n    $01d381f309bc1532$var$throwIfAborted(object[$01d381f309bc1532$require$kState]);\n    // 1. If object is unusable, then return a promise rejected\n    //    with a TypeError.\n    if ($01d381f309bc1532$var$bodyUnusable(object[$01d381f309bc1532$require$kState].body)) throw new TypeError('Body is unusable');\n    // 2. Let promise be a new promise.\n    const promise = $01d381f309bc1532$require$createDeferredPromise();\n    // 3. Let errorSteps given error be to reject promise with error.\n    const errorSteps = (error)=>promise.reject(error);\n    // 4. Let successSteps given a byte sequence data be to resolve\n    //    promise with the result of running convertBytesToJSValue\n    //    with data. If that threw an exception, then run errorSteps\n    //    with that exception.\n    const successSteps = (data)=>{\n        try {\n            promise.resolve(convertBytesToJSValue(data));\n        } catch (e) {\n            errorSteps(e);\n        }\n    };\n    // 5. If object’s body is null, then run successSteps with an\n    //    empty byte sequence.\n    if (object[$01d381f309bc1532$require$kState].body == null) {\n        successSteps(new Uint8Array());\n        return promise.promise;\n    }\n    // 6. Otherwise, fully read object’s body given successSteps,\n    //    errorSteps, and object’s relevant global object.\n    await $01d381f309bc1532$require$fullyReadBody(object[$01d381f309bc1532$require$kState].body, successSteps, errorSteps);\n    // 7. Return promise.\n    return promise.promise;\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction $01d381f309bc1532$var$bodyUnusable(body) {\n    // An object including the Body interface mixin is\n    // said to be unusable if its body is non-null and\n    // its body’s stream is disturbed or locked.\n    return body != null && (body.stream.locked || $8EnIj$pythonversioncheck7ed1514ejs1.isDisturbed(body.stream));\n}\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */ function $01d381f309bc1532$var$utf8DecodeBytes(buffer) {\n    if (buffer.length === 0) return '';\n    // 1. Let buffer be the result of peeking three bytes from\n    //    ioQueue, converted to a byte sequence.\n    // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n    //    bytes from ioQueue. (Do nothing with those bytes.)\n    if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) buffer = buffer.subarray(3);\n    // 3. Process a queue with an instance of UTF-8’s\n    //    decoder, ioQueue, output, and \"replacement\".\n    const output = $01d381f309bc1532$var$textDecoder.decode(buffer);\n    // 4. Return output.\n    return output;\n}\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */ function $01d381f309bc1532$var$parseJSONFromBytes(bytes) {\n    return JSON.parse($01d381f309bc1532$var$utf8DecodeBytes(bytes));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */ function $01d381f309bc1532$var$bodyMimeType(object) {\n    const { headersList: headersList } = object[$01d381f309bc1532$require$kState];\n    const contentType = headersList.get('content-type');\n    if (contentType === null) return 'failure';\n    return $01d381f309bc1532$require$parseMIMEType(contentType);\n}\nmodule.exports = {\n    extractBody: $01d381f309bc1532$var$extractBody,\n    safelyExtractBody: $01d381f309bc1532$var$safelyExtractBody,\n    cloneBody: $01d381f309bc1532$var$cloneBody,\n    mixinBody: $01d381f309bc1532$var$mixinBody\n};\n\n});\n\n\nparcelRequire(\"9IGRA\");\n\n//# sourceMappingURL=python-version-check.152f8bba.js.map\n","'use strict'\n\nconst Busboy = require('@fastify/busboy')\nconst util = require('../core/util')\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody\n} = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { DOMException, structuredClone } = require('./constants')\nconst { Blob, File: NativeFile } = require('buffer')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { isErrored } = require('../core/util')\nconst { isUint8Array, isArrayBuffer } = require('util/types')\nconst { File: UndiciFile } = require('./file')\nconst { parseMIMEType, serializeAMimeType } = require('./dataURL')\n\nlet random\ntry {\n  const crypto = require('node:crypto')\n  random = (max) => crypto.randomInt(0, max)\n} catch {\n  random = (max) => Math.floor(Math.random(max))\n}\n\nlet ReadableStream = globalThis.ReadableStream\n\n/** @type {globalThis['File']} */\nconst File = NativeFile ?? UndiciFile\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream.\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? textEncoder.encode(source) : source\n        )\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: undefined\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    const chunk = textEncoder.encode(`--${boundary}--`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: undefined\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n  const out2Clone = structuredClone(out2, { transfer: [out2] })\n  // This, for whatever reasons, unrefs out2Clone which allows\n  // the process to exit by itself.\n  const [, finalClone] = out2Clone.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: finalClone,\n    length: body.length,\n    source: body.source\n  }\n}\n\nasync function * consumeBody (body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body\n    } else {\n      const stream = body.stream\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.')\n      }\n\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.')\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true\n\n      yield * stream\n    }\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return specConsumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(this)\n\n        if (mimeType === 'failure') {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return specConsumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return specConsumeBody(this, utf8DecodeBytes, instance)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return specConsumeBody(this, parseJSONFromBytes, instance)\n    },\n\n    async formData () {\n      webidl.brandCheck(this, instance)\n\n      throwIfAborted(this[kState])\n\n      const contentType = this.headers.get('Content-Type')\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {}\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value\n\n        const responseFormData = new FormData()\n\n        let busboy\n\n        try {\n          busboy = new Busboy({\n            headers,\n            preservePath: true\n          })\n        } catch (err) {\n          throw new DOMException(`${err}`, 'AbortError')\n        }\n\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value)\n        })\n        busboy.on('file', (name, value, filename, encoding, mimeType) => {\n          const chunks = []\n\n          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {\n            let base64chunk = ''\n\n            value.on('data', (chunk) => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '')\n\n              const end = base64chunk.length - base64chunk.length % 4\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'))\n\n              base64chunk = base64chunk.slice(end)\n            })\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'))\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          } else {\n            value.on('data', (chunk) => {\n              chunks.push(chunk)\n            })\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          }\n        })\n\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve)\n          busboy.on('error', (err) => reject(new TypeError(err)))\n        })\n\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk)\n        busboy.end()\n        await busboyResolve\n\n        return responseFormData\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries\n        try {\n          let text = ''\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          // Note that streaming decoder is stateful and cannot be reused\n          const streamingDecoder = new TextDecoder('utf-8', { ignoreBOM: true })\n\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk')\n            }\n            text += streamingDecoder.decode(chunk, { stream: true })\n          }\n          text += streamingDecoder.decode()\n          entries = new URLSearchParams(text)\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData()\n        for (const [name, value] of entries) {\n          formData.append(name, value)\n        }\n        return formData\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve()\n\n        throwIfAborted(this[kState])\n\n        // Otherwise, throw a TypeError.\n        throw webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        })\n      }\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function specConsumeBody (object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance)\n\n  throwIfAborted(object[kState])\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object[kState].body)) {\n    throw new TypeError('Body is unusable')\n  }\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(new Uint8Array())\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable (body) {\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */\nfunction bodyMimeType (object) {\n  const { headersList } = object[kState]\n  const contentType = headersList.get('content-type')\n\n  if (contentType === null) {\n    return 'failure'\n  }\n\n  return parseMIMEType(contentType)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n"],"names":["$8EnIj$pythonversioncheck5a6f079bjs","$8EnIj$pythonversioncheck7ed1514ejs3","$8EnIj$pythonversioncheck3f48d3eejs5","$8EnIj$pythonversioncheck34871282js","$8EnIj$pythonversioncheck92c00e26js","$8EnIj$pythonversioncheck801bb0f1js","$8EnIj$pythonversioncheck863e006ejs1","$8EnIj$pythonversioncheckebf2a848js","$8EnIj$pythonversionchecka81ff9ccjs","$8EnIj$pythonversioncheck685b5bb2js1","Blob","$8EnIj$Blob","File","$8EnIj$File","$8EnIj$assert","isUint8Array","$8EnIj$isUint8Array","isArrayBuffer","$8EnIj$isArrayBuffer","ReadableStream","$8EnIj$ReadableStream","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$01d381f309bc1532$var$random","$01d381f309bc1532$require$ReadableStreamFrom","ReadableStreamFrom","$01d381f309bc1532$require$isBlobLike","$8EnIj$pythonversioncheck3f48d3eejs2","isBlobLike","$01d381f309bc1532$require$isReadableStreamLike","$8EnIj$pythonversioncheck3f48d3eejs3","isReadableStreamLike","$01d381f309bc1532$require$readableStreamClose","$8EnIj$pythonversioncheck3f48d3eejs4","readableStreamClose","$01d381f309bc1532$require$createDeferredPromise","$8EnIj$pythonversioncheck3f48d3eejs","createDeferredPromise","$01d381f309bc1532$require$fullyReadBody","$8EnIj$pythonversioncheck3f48d3eejs1","fullyReadBody","$01d381f309bc1532$require$FormData","FormData","$01d381f309bc1532$require$kState","kState","$01d381f309bc1532$require$webidl","webidl","$01d381f309bc1532$require$DOMException","$8EnIj$pythonversioncheck863e006ejs","DOMException","$01d381f309bc1532$require$structuredClone","structuredClone","$01d381f309bc1532$require$kBodyUsed","kBodyUsed","$01d381f309bc1532$require$isErrored","$8EnIj$pythonversioncheck7ed1514ejs2","isErrored","$01d381f309bc1532$require$UndiciFile","$01d381f309bc1532$require$parseMIMEType","$8EnIj$pythonversioncheck685b5bb2js","parseMIMEType","$01d381f309bc1532$require$serializeAMimeType","serializeAMimeType","crypto","$01d381f309bc1532$import$89770a49fac40caf","max","randomInt","Math","floor","random","$01d381f309bc1532$var$ReadableStream","$01d381f309bc1532$var$File","$01d381f309bc1532$require$NativeFile","$01d381f309bc1532$var$textEncoder","TextEncoder","$01d381f309bc1532$var$textDecoder","TextDecoder","$01d381f309bc1532$var$extractBody","object","keepalive","stream","pull","controller","enqueue","source","encode","queueMicrotask","start","type","undefined","action","length","URLSearchParams","toString","$01d381f309bc1532$require$isArrayBuffer","Uint8Array","slice","ArrayBuffer","isView","buffer","byteOffset","byteLength","isFormDataLike","boundary","padStart","prefix","escape","str","replace","normalizeLinefeeds","value","blobParts","rn","hasUnknownSizeValue","name","chunk","push","size","part","Symbol","asyncIterator","TypeError","$8EnIj$pythonversioncheck7ed1514ejs1","isDisturbed","locked","$8EnIj$pythonversioncheck7ed1514ejs","isBuffer","Buffer","iterator","done","next","close","desiredSize","cancel","reason","return","$01d381f309bc1532$var$consumeBody","body","$01d381f309bc1532$require$isUint8Array","$01d381f309bc1532$var$throwIfAborted","state","aborted","$01d381f309bc1532$var$specConsumeBody","convertBytesToJSValue","instance","brandCheck","promise","errorSteps","error","reject","successSteps","data","resolve","e","$01d381f309bc1532$var$utf8DecodeBytes","subarray","decode","$01d381f309bc1532$var$parseJSONFromBytes","bytes","JSON","parse","extractBody","safelyExtractBody","cloneBody","out1","out2","tee","finalClone","out2Clone","transfer","mixinBody","prototype","Object","assign","blob","mimeType","$01d381f309bc1532$var$bodyMimeType","headersList","contentType","get","arrayBuffer","text","json","formData","headers","test","busboy","key","toLowerCase","responseFormData","preservePath","on","append","filename","encoding","chunks","base64chunk","end","from","busboyResolve","Promise","write","entries","streamingDecoder","ignoreBOM","cause","errors","exception","header","message"],"version":3,"file":"python-version-check.152f8bba.js.map","sourceRoot":"../"}