{"mappings":"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","sources":["<anon>","node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js"],"sourcesContent":["var $013a0eddcc2c69c1$exports = {};\n\"use strict\";\nfunction $013a0eddcc2c69c1$var$compile(nodes) {\n    var assignedPaths = [];\n    var valueAssignments = [];\n    var currentPath = \"\";\n    var data = Object.create(null);\n    var context = data;\n    var arrayMode = false;\n    return reduce(nodes);\n    function reduce(nodes) {\n        var node;\n        for(var i = 0; i < nodes.length; i++){\n            node = nodes[i];\n            switch(node.type){\n                case \"Assign\":\n                    assign(node);\n                    break;\n                case \"ObjectPath\":\n                    setPath(node);\n                    break;\n                case \"ArrayPath\":\n                    addTableArray(node);\n                    break;\n            }\n        }\n        return data;\n    }\n    function genError(err, line, col) {\n        var ex = new Error(err);\n        ex.line = line;\n        ex.column = col;\n        throw ex;\n    }\n    function assign(node) {\n        var key = node.key;\n        var value = node.value;\n        var line = node.line;\n        var column = node.column;\n        var fullPath;\n        if (currentPath) fullPath = currentPath + \".\" + key;\n        else fullPath = key;\n        if (typeof context[key] !== \"undefined\") genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\n        context[key] = reduceValueNode(value);\n        if (!pathAssigned(fullPath)) {\n            assignedPaths.push(fullPath);\n            valueAssignments.push(fullPath);\n        }\n    }\n    function pathAssigned(path) {\n        return assignedPaths.indexOf(path) !== -1;\n    }\n    function reduceValueNode(node) {\n        if (node.type === \"Array\") return reduceArrayWithTypeChecking(node.value);\n        else if (node.type === \"InlineTable\") return reduceInlineTableNode(node.value);\n        else return node.value;\n    }\n    function reduceInlineTableNode(values) {\n        var obj = Object.create(null);\n        for(var i = 0; i < values.length; i++){\n            var val = values[i];\n            if (val.value.type === \"InlineTable\") obj[val.key] = reduceInlineTableNode(val.value.value);\n            else if (val.type === \"InlineTableValue\") obj[val.key] = reduceValueNode(val.value);\n        }\n        return obj;\n    }\n    function setPath(node) {\n        var path = node.value;\n        var quotedPath = path.map(quoteDottedString).join(\".\");\n        var line = node.line;\n        var column = node.column;\n        if (pathAssigned(quotedPath)) genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n        assignedPaths.push(quotedPath);\n        context = deepRef(data, path, Object.create(null), line, column);\n        currentPath = path;\n    }\n    function addTableArray(node) {\n        var path = node.value;\n        var quotedPath = path.map(quoteDottedString).join(\".\");\n        var line = node.line;\n        var column = node.column;\n        if (!pathAssigned(quotedPath)) assignedPaths.push(quotedPath);\n        assignedPaths = assignedPaths.filter(function(p) {\n            return p.indexOf(quotedPath) !== 0;\n        });\n        assignedPaths.push(quotedPath);\n        context = deepRef(data, path, [], line, column);\n        currentPath = quotedPath;\n        if (context instanceof Array) {\n            var newObj = Object.create(null);\n            context.push(newObj);\n            context = newObj;\n        } else genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n    // Given a path 'a.b.c', create (as necessary) `start.a`,\n    // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\n    // If `a` or `b` are arrays and have items in them, the last item in the\n    // array is used as the context for the next sub-path.\n    function deepRef(start, keys, value, line, column) {\n        var traversed = [];\n        var traversedPath = \"\";\n        var path = keys.join(\".\");\n        var ctx = start;\n        for(var i = 0; i < keys.length; i++){\n            var key = keys[i];\n            traversed.push(key);\n            traversedPath = traversed.join(\".\");\n            if (typeof ctx[key] === \"undefined\") {\n                if (i === keys.length - 1) ctx[key] = value;\n                else ctx[key] = Object.create(null);\n            } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) // already a non-object value at key, can't be used as part of a new path\n            genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\n            ctx = ctx[key];\n            if (ctx instanceof Array && ctx.length && i < keys.length - 1) ctx = ctx[ctx.length - 1];\n        }\n        return ctx;\n    }\n    function reduceArrayWithTypeChecking(array) {\n        // Ensure that all items in the array are of the same type\n        var firstType = null;\n        for(var i = 0; i < array.length; i++){\n            var node = array[i];\n            if (firstType === null) firstType = node.type;\n            else if (node.type !== firstType) genError(\"Cannot add value of type \" + node.type + \" to array of type \" + firstType + \".\", node.line, node.column);\n        }\n        // Recursively reduce array of nodes into array of the nodes' values\n        return array.map(reduceValueNode);\n    }\n    function quoteDottedString(str) {\n        if (str.indexOf(\".\") > -1) return \"\\\"\" + str + \"\\\"\";\n        else return str;\n    }\n}\n$013a0eddcc2c69c1$exports = {\n    compile: $013a0eddcc2c69c1$var$compile\n};\n\n\nexport {$013a0eddcc2c69c1$exports as default};\n//# sourceMappingURL=python-version-check.795d4376.js.map\n","\"use strict\";\nfunction compile(nodes) {\n  var assignedPaths = [];\n  var valueAssignments = [];\n  var currentPath = \"\";\n  var data = Object.create(null);\n  var context = data;\n  var arrayMode = false;\n\n  return reduce(nodes);\n\n  function reduce(nodes) {\n    var node;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      switch (node.type) {\n      case \"Assign\":\n        assign(node);\n        break;\n      case \"ObjectPath\":\n        setPath(node);\n        break;\n      case \"ArrayPath\":\n        addTableArray(node);\n        break;\n      }\n    }\n\n    return data;\n  }\n\n  function genError(err, line, col) {\n    var ex = new Error(err);\n    ex.line = line;\n    ex.column = col;\n    throw ex;\n  }\n\n  function assign(node) {\n    var key = node.key;\n    var value = node.value;\n    var line = node.line;\n    var column = node.column;\n\n    var fullPath;\n    if (currentPath) {\n      fullPath = currentPath + \".\" + key;\n    } else {\n      fullPath = key;\n    }\n    if (typeof context[key] !== \"undefined\") {\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\n    }\n\n    context[key] = reduceValueNode(value);\n\n    if (!pathAssigned(fullPath)) {\n      assignedPaths.push(fullPath);\n      valueAssignments.push(fullPath);\n    }\n  }\n\n\n  function pathAssigned(path) {\n    return assignedPaths.indexOf(path) !== -1;\n  }\n\n  function reduceValueNode(node) {\n    if (node.type === \"Array\") {\n      return reduceArrayWithTypeChecking(node.value);\n    } else if (node.type === \"InlineTable\") {\n      return reduceInlineTableNode(node.value);\n    } else {\n      return node.value;\n    }\n  }\n\n  function reduceInlineTableNode(values) {\n    var obj = Object.create(null);\n    for (var i = 0; i < values.length; i++) {\n      var val = values[i];\n      if (val.value.type === \"InlineTable\") {\n        obj[val.key] = reduceInlineTableNode(val.value.value);\n      } else if (val.type === \"InlineTableValue\") {\n        obj[val.key] = reduceValueNode(val.value);\n      }\n    }\n\n    return obj;\n  }\n\n  function setPath(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (pathAssigned(quotedPath)) {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, Object.create(null), line, column);\n    currentPath = path;\n  }\n\n  function addTableArray(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (!pathAssigned(quotedPath)) {\n      assignedPaths.push(quotedPath);\n    }\n    assignedPaths = assignedPaths.filter(function(p) {\n      return p.indexOf(quotedPath) !== 0;\n    });\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, [], line, column);\n    currentPath = quotedPath;\n\n    if (context instanceof Array) {\n      var newObj = Object.create(null);\n      context.push(newObj);\n      context = newObj;\n    } else {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n  }\n\n  // Given a path 'a.b.c', create (as necessary) `start.a`,\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\n  // If `a` or `b` are arrays and have items in them, the last item in the\n  // array is used as the context for the next sub-path.\n  function deepRef(start, keys, value, line, column) {\n    var traversed = [];\n    var traversedPath = \"\";\n    var path = keys.join(\".\");\n    var ctx = start;\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      traversed.push(key);\n      traversedPath = traversed.join(\".\");\n      if (typeof ctx[key] === \"undefined\") {\n        if (i === keys.length - 1) {\n          ctx[key] = value;\n        } else {\n          ctx[key] = Object.create(null);\n        }\n      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {\n        // already a non-object value at key, can't be used as part of a new path\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\n      }\n\n      ctx = ctx[key];\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\n        ctx = ctx[ctx.length - 1];\n      }\n    }\n\n    return ctx;\n  }\n\n  function reduceArrayWithTypeChecking(array) {\n    // Ensure that all items in the array are of the same type\n    var firstType = null;\n    for (var i = 0; i < array.length; i++) {\n      var node = array[i];\n      if (firstType === null) {\n        firstType = node.type;\n      } else {\n        if (node.type !== firstType) {\n          genError(\"Cannot add value of type \" + node.type + \" to array of type \" +\n            firstType + \".\", node.line, node.column);\n        }\n      }\n    }\n\n    // Recursively reduce array of nodes into array of the nodes' values\n    return array.map(reduceValueNode);\n  }\n\n  function quoteDottedString(str) {\n    if (str.indexOf(\".\") > -1) {\n      return \"\\\"\" + str + \"\\\"\";\n    } else {\n      return str;\n    }\n  }\n}\n\nmodule.exports = {\n  compile: compile\n};\n"],"names":["$013a0eddcc2c69c1$exports","compile","nodes","assignedPaths","valueAssignments","currentPath","data","Object","create","context","node","i","length","type","assign","fullPath","key","value","line","column","genError","reduceValueNode","reduceArrayWithTypeChecking","array","firstType","map","reduceInlineTableNode","values","obj","val","pathAssigned","push","setPath","path","quotedPath","quoteDottedString","join","deepRef","addTableArray","filter","p","indexOf","Array","newObj","err","col","ex","Error","start","keys","traversed","traversedPath","ctx","str","default"],"version":3,"file":"python-version-check.795d4376.js.map","sourceRoot":"../"}