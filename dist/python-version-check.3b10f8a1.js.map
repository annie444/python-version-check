{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js"],"sourcesContent":["import $8pGVa$pythonversioncheck7452b75ajs from \"./python-version-check.7452b75a.js\";\nimport $8pGVa$pythonversioncheck32039d93js4 from \"./python-version-check.32039d93.js\";\nimport $8pGVa$pythonversioncheck7ed1514ejs1 from \"./python-version-check.7ed1514e.js\";\nimport {STATUS_CODES as $8pGVa$STATUS_CODES} from \"http\";\nimport * as $8pGVa$util from \"util\";\n\nvar $5e4bdbfa16cc6f60$exports = {};\n'use strict';\n\nvar $5e4bdbfa16cc6f60$require$MockNotMatchedError = $8pGVa$pythonversioncheck7452b75ajs.MockNotMatchedError;\n\nvar $5e4bdbfa16cc6f60$require$kDispatches = $8pGVa$pythonversioncheck32039d93js.kDispatches;\nvar $5e4bdbfa16cc6f60$require$kMockAgent = $8pGVa$pythonversioncheck32039d93js2.kMockAgent;\nvar $5e4bdbfa16cc6f60$require$kOriginalDispatch = $8pGVa$pythonversioncheck32039d93js4.kOriginalDispatch;\nvar $5e4bdbfa16cc6f60$require$kOrigin = $8pGVa$pythonversioncheck32039d93js3.kOrigin;\nvar $5e4bdbfa16cc6f60$require$kGetNetConnect = $8pGVa$pythonversioncheck32039d93js1.kGetNetConnect;\n\nvar $5e4bdbfa16cc6f60$require$buildURL = $8pGVa$pythonversioncheck7ed1514ejs.buildURL;\nvar $5e4bdbfa16cc6f60$require$nop = $8pGVa$pythonversioncheck7ed1514ejs1.nop;\n\nvar $5e4bdbfa16cc6f60$require$STATUS_CODES = $8pGVa$STATUS_CODES;\n\nconst { types: { isPromise: $5e4bdbfa16cc6f60$var$isPromise } } = $8pGVa$util;\nfunction $5e4bdbfa16cc6f60$var$matchValue(match, value) {\n    if (typeof match === 'string') return match === value;\n    if (match instanceof RegExp) return match.test(value);\n    if (typeof match === 'function') return match(value) === true;\n    return false;\n}\nfunction $5e4bdbfa16cc6f60$var$lowerCaseEntries(headers) {\n    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue])=>{\n        return [\n            headerName.toLocaleLowerCase(),\n            headerValue\n        ];\n    }));\n}\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */ function $5e4bdbfa16cc6f60$var$getHeaderByName(headers, key) {\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i + 1];\n        }\n        return undefined;\n    } else if (typeof headers.get === 'function') return headers.get(key);\n    else return $5e4bdbfa16cc6f60$var$lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n}\n/** @param {string[]} headers */ function $5e4bdbfa16cc6f60$var$buildHeadersFromArray(headers) {\n    const clone = headers.slice();\n    const entries = [];\n    for(let index = 0; index < clone.length; index += 2)entries.push([\n        clone[index],\n        clone[index + 1]\n    ]);\n    return Object.fromEntries(entries);\n}\nfunction $5e4bdbfa16cc6f60$var$matchHeaders(mockDispatch, headers) {\n    if (typeof mockDispatch.headers === 'function') {\n        if (Array.isArray(headers)) headers = $5e4bdbfa16cc6f60$var$buildHeadersFromArray(headers);\n        return mockDispatch.headers(headers ? $5e4bdbfa16cc6f60$var$lowerCaseEntries(headers) : {});\n    }\n    if (typeof mockDispatch.headers === 'undefined') return true;\n    if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') return false;\n    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)){\n        const headerValue = $5e4bdbfa16cc6f60$var$getHeaderByName(headers, matchHeaderName);\n        if (!$5e4bdbfa16cc6f60$var$matchValue(matchHeaderValue, headerValue)) return false;\n    }\n    return true;\n}\nfunction $5e4bdbfa16cc6f60$var$safeUrl(path) {\n    if (typeof path !== 'string') return path;\n    const pathSegments = path.split('?');\n    if (pathSegments.length !== 2) return path;\n    const qp = new URLSearchParams(pathSegments.pop());\n    qp.sort();\n    return [\n        ...pathSegments,\n        qp.toString()\n    ].join('?');\n}\nfunction $5e4bdbfa16cc6f60$var$matchKey(mockDispatch, { path: path, method: method, body: body, headers: headers }) {\n    const pathMatch = $5e4bdbfa16cc6f60$var$matchValue(mockDispatch.path, path);\n    const methodMatch = $5e4bdbfa16cc6f60$var$matchValue(mockDispatch.method, method);\n    const bodyMatch = typeof mockDispatch.body !== 'undefined' ? $5e4bdbfa16cc6f60$var$matchValue(mockDispatch.body, body) : true;\n    const headersMatch = $5e4bdbfa16cc6f60$var$matchHeaders(mockDispatch, headers);\n    return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\nfunction $5e4bdbfa16cc6f60$var$getResponseData(data) {\n    if (Buffer.isBuffer(data)) return data;\n    else if (typeof data === 'object') return JSON.stringify(data);\n    else return data.toString();\n}\nfunction $5e4bdbfa16cc6f60$var$getMockDispatch(mockDispatches, key) {\n    const basePath = key.query ? $5e4bdbfa16cc6f60$require$buildURL(key.path, key.query) : key.path;\n    const resolvedPath = typeof basePath === 'string' ? $5e4bdbfa16cc6f60$var$safeUrl(basePath) : basePath;\n    // Match path\n    let matchedMockDispatches = mockDispatches.filter(({ consumed: consumed })=>!consumed).filter(({ path: path })=>$5e4bdbfa16cc6f60$var$matchValue($5e4bdbfa16cc6f60$var$safeUrl(path), resolvedPath));\n    if (matchedMockDispatches.length === 0) throw new $5e4bdbfa16cc6f60$require$MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n    // Match method\n    matchedMockDispatches = matchedMockDispatches.filter(({ method: method })=>$5e4bdbfa16cc6f60$var$matchValue(method, key.method));\n    if (matchedMockDispatches.length === 0) throw new $5e4bdbfa16cc6f60$require$MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);\n    // Match body\n    matchedMockDispatches = matchedMockDispatches.filter(({ body: body })=>typeof body !== 'undefined' ? $5e4bdbfa16cc6f60$var$matchValue(body, key.body) : true);\n    if (matchedMockDispatches.length === 0) throw new $5e4bdbfa16cc6f60$require$MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);\n    // Match headers\n    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch)=>$5e4bdbfa16cc6f60$var$matchHeaders(mockDispatch, key.headers));\n    if (matchedMockDispatches.length === 0) throw new $5e4bdbfa16cc6f60$require$MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`);\n    return matchedMockDispatches[0];\n}\nfunction $5e4bdbfa16cc6f60$var$addMockDispatch(mockDispatches, key, data) {\n    const baseData = {\n        timesInvoked: 0,\n        times: 1,\n        persist: false,\n        consumed: false\n    };\n    const replyData = typeof data === 'function' ? {\n        callback: data\n    } : {\n        ...data\n    };\n    const newMockDispatch = {\n        ...baseData,\n        ...key,\n        pending: true,\n        data: {\n            error: null,\n            ...replyData\n        }\n    };\n    mockDispatches.push(newMockDispatch);\n    return newMockDispatch;\n}\nfunction $5e4bdbfa16cc6f60$var$deleteMockDispatch(mockDispatches, key) {\n    const index = mockDispatches.findIndex((dispatch)=>{\n        if (!dispatch.consumed) return false;\n        return $5e4bdbfa16cc6f60$var$matchKey(dispatch, key);\n    });\n    if (index !== -1) mockDispatches.splice(index, 1);\n}\nfunction $5e4bdbfa16cc6f60$var$buildKey(opts) {\n    const { path: path, method: method, body: body, headers: headers, query: query } = opts;\n    return {\n        path: path,\n        method: method,\n        body: body,\n        headers: headers,\n        query: query\n    };\n}\nfunction $5e4bdbfa16cc6f60$var$generateKeyValues(data) {\n    return Object.entries(data).reduce((keyValuePairs, [key, value])=>[\n            ...keyValuePairs,\n            Buffer.from(`${key}`),\n            Array.isArray(value) ? value.map((x)=>Buffer.from(`${x}`)) : Buffer.from(`${value}`)\n        ], []);\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */ function $5e4bdbfa16cc6f60$var$getStatusText(statusCode) {\n    return $5e4bdbfa16cc6f60$require$STATUS_CODES[statusCode] || 'unknown';\n}\nasync function $5e4bdbfa16cc6f60$var$getResponse(body) {\n    const buffers = [];\n    for await (const data of body)buffers.push(data);\n    return Buffer.concat(buffers).toString('utf8');\n}\n/**\n * Mock dispatch function used to simulate undici dispatches\n */ function $5e4bdbfa16cc6f60$var$mockDispatch(opts, handler) {\n    // Get mock dispatch from built key\n    const key = $5e4bdbfa16cc6f60$var$buildKey(opts);\n    const mockDispatch = $5e4bdbfa16cc6f60$var$getMockDispatch(this[$5e4bdbfa16cc6f60$require$kDispatches], key);\n    mockDispatch.timesInvoked++;\n    // Here's where we resolve a callback if a callback is present for the dispatch data.\n    if (mockDispatch.data.callback) mockDispatch.data = {\n        ...mockDispatch.data,\n        ...mockDispatch.data.callback(opts)\n    };\n    // Parse mockDispatch data\n    const { data: { statusCode: statusCode, data: data, headers: headers, trailers: trailers, error: error }, delay: delay, persist: persist } = mockDispatch;\n    const { timesInvoked: timesInvoked, times: times } = mockDispatch;\n    // If it's used up and not persistent, mark as consumed\n    mockDispatch.consumed = !persist && timesInvoked >= times;\n    mockDispatch.pending = timesInvoked < times;\n    // If specified, trigger dispatch error\n    if (error !== null) {\n        $5e4bdbfa16cc6f60$var$deleteMockDispatch(this[$5e4bdbfa16cc6f60$require$kDispatches], key);\n        handler.onError(error);\n        return true;\n    }\n    // Handle the request with a delay if necessary\n    if (typeof delay === 'number' && delay > 0) setTimeout(()=>{\n        handleReply(this[$5e4bdbfa16cc6f60$require$kDispatches]);\n    }, delay);\n    else handleReply(this[$5e4bdbfa16cc6f60$require$kDispatches]);\n    function handleReply(mockDispatches, _data = data) {\n        // fetch's HeadersList is a 1D string array\n        const optsHeaders = Array.isArray(opts.headers) ? $5e4bdbfa16cc6f60$var$buildHeadersFromArray(opts.headers) : opts.headers;\n        const body = typeof _data === 'function' ? _data({\n            ...opts,\n            headers: optsHeaders\n        }) : _data;\n        // util.types.isPromise is likely needed for jest.\n        if ($5e4bdbfa16cc6f60$var$isPromise(body)) {\n            // If handleReply is asynchronous, throwing an error\n            // in the callback will reject the promise, rather than\n            // synchronously throw the error, which breaks some tests.\n            // Rather, we wait for the callback to resolve if it is a\n            // promise, and then re-run handleReply with the new body.\n            body.then((newData)=>handleReply(mockDispatches, newData));\n            return;\n        }\n        const responseData = $5e4bdbfa16cc6f60$var$getResponseData(body);\n        const responseHeaders = $5e4bdbfa16cc6f60$var$generateKeyValues(headers);\n        const responseTrailers = $5e4bdbfa16cc6f60$var$generateKeyValues(trailers);\n        handler.abort = $5e4bdbfa16cc6f60$require$nop;\n        handler.onHeaders(statusCode, responseHeaders, resume, $5e4bdbfa16cc6f60$var$getStatusText(statusCode));\n        handler.onData(Buffer.from(responseData));\n        handler.onComplete(responseTrailers);\n        $5e4bdbfa16cc6f60$var$deleteMockDispatch(mockDispatches, key);\n    }\n    function resume() {}\n    return true;\n}\nfunction $5e4bdbfa16cc6f60$var$buildMockDispatch() {\n    const agent = this[$5e4bdbfa16cc6f60$require$kMockAgent];\n    const origin = this[$5e4bdbfa16cc6f60$require$kOrigin];\n    const originalDispatch = this[$5e4bdbfa16cc6f60$require$kOriginalDispatch];\n    return function dispatch(opts, handler) {\n        if (agent.isMockActive) try {\n            $5e4bdbfa16cc6f60$var$mockDispatch.call(this, opts, handler);\n        } catch (error) {\n            if (error instanceof $5e4bdbfa16cc6f60$require$MockNotMatchedError) {\n                const netConnect = agent[$5e4bdbfa16cc6f60$require$kGetNetConnect]();\n                if (netConnect === false) throw new $5e4bdbfa16cc6f60$require$MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n                if ($5e4bdbfa16cc6f60$var$checkNetConnect(netConnect, origin)) originalDispatch.call(this, opts, handler);\n                else throw new $5e4bdbfa16cc6f60$require$MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n            } else throw error;\n        }\n        else originalDispatch.call(this, opts, handler);\n    };\n}\nfunction $5e4bdbfa16cc6f60$var$checkNetConnect(netConnect, origin) {\n    const url = new URL(origin);\n    if (netConnect === true) return true;\n    else if (Array.isArray(netConnect) && netConnect.some((matcher)=>$5e4bdbfa16cc6f60$var$matchValue(matcher, url.host))) return true;\n    return false;\n}\nfunction $5e4bdbfa16cc6f60$var$buildMockOptions(opts) {\n    if (opts) {\n        const { agent: agent, ...mockOptions } = opts;\n        return mockOptions;\n    }\n}\n$5e4bdbfa16cc6f60$exports = {\n    getResponseData: $5e4bdbfa16cc6f60$var$getResponseData,\n    getMockDispatch: $5e4bdbfa16cc6f60$var$getMockDispatch,\n    addMockDispatch: $5e4bdbfa16cc6f60$var$addMockDispatch,\n    deleteMockDispatch: $5e4bdbfa16cc6f60$var$deleteMockDispatch,\n    buildKey: $5e4bdbfa16cc6f60$var$buildKey,\n    generateKeyValues: $5e4bdbfa16cc6f60$var$generateKeyValues,\n    matchValue: $5e4bdbfa16cc6f60$var$matchValue,\n    getResponse: $5e4bdbfa16cc6f60$var$getResponse,\n    getStatusText: $5e4bdbfa16cc6f60$var$getStatusText,\n    mockDispatch: $5e4bdbfa16cc6f60$var$mockDispatch,\n    buildMockDispatch: $5e4bdbfa16cc6f60$var$buildMockDispatch,\n    checkNetConnect: $5e4bdbfa16cc6f60$var$checkNetConnect,\n    buildMockOptions: $5e4bdbfa16cc6f60$var$buildMockOptions,\n    getHeaderByName: $5e4bdbfa16cc6f60$var$getHeaderByName\n};\n\n\nexport {$5e4bdbfa16cc6f60$exports as default};\n//# sourceMappingURL=python-version-check.3b10f8a1.js.map\n","'use strict'\n\nconst { MockNotMatchedError } = require('./mock-errors')\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = require('./mock-symbols')\nconst { buildURL, nop } = require('../core/util')\nconst { STATUS_CODES } = require('http')\nconst {\n  types: {\n    isPromise\n  }\n} = require('util')\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n\n  const pathSegments = path.split('?')\n\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [\n    ...keyValuePairs,\n    Buffer.from(`${key}`),\n    Array.isArray(value) ? value.map(x => Buffer.from(`${x}`)) : Buffer.from(`${value}`)\n  ], [])\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then((newData) => handleReply(mockDispatches, newData))\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.abort = nop\n    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData(Buffer.from(responseData))\n    handler.onComplete(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName\n}\n"],"names":["$8pGVa$pythonversioncheck7452b75ajs","$8pGVa$pythonversioncheck32039d93js4","$8pGVa$pythonversioncheck7ed1514ejs1","STATUS_CODES","$8pGVa$STATUS_CODES","$8pGVa$util","$5e4bdbfa16cc6f60$exports","$5e4bdbfa16cc6f60$require$MockNotMatchedError","MockNotMatchedError","$5e4bdbfa16cc6f60$require$kDispatches","$8pGVa$pythonversioncheck32039d93js","kDispatches","$5e4bdbfa16cc6f60$require$kMockAgent","$8pGVa$pythonversioncheck32039d93js2","kMockAgent","$5e4bdbfa16cc6f60$require$kOriginalDispatch","kOriginalDispatch","$5e4bdbfa16cc6f60$require$kOrigin","$8pGVa$pythonversioncheck32039d93js3","kOrigin","$5e4bdbfa16cc6f60$require$kGetNetConnect","$8pGVa$pythonversioncheck32039d93js1","kGetNetConnect","$5e4bdbfa16cc6f60$require$buildURL","$8pGVa$pythonversioncheck7ed1514ejs","buildURL","$5e4bdbfa16cc6f60$require$nop","nop","types","isPromise","$5e4bdbfa16cc6f60$var$isPromise","$5e4bdbfa16cc6f60$var$matchValue","match","value","RegExp","test","$5e4bdbfa16cc6f60$var$lowerCaseEntries","headers","Object","fromEntries","entries","map","headerName","headerValue","toLocaleLowerCase","$5e4bdbfa16cc6f60$var$getHeaderByName","key","Array","isArray","i","length","get","$5e4bdbfa16cc6f60$var$buildHeadersFromArray","clone","slice","index","push","$5e4bdbfa16cc6f60$var$matchHeaders","mockDispatch","matchHeaderName","matchHeaderValue","$5e4bdbfa16cc6f60$var$safeUrl","path","pathSegments","split","qp","URLSearchParams","pop","sort","toString","join","$5e4bdbfa16cc6f60$var$getResponseData","data","Buffer","isBuffer","JSON","stringify","$5e4bdbfa16cc6f60$var$getMockDispatch","mockDispatches","basePath","query","resolvedPath","matchedMockDispatches","filter","consumed","method","body","$5e4bdbfa16cc6f60$var$deleteMockDispatch","findIndex","dispatch","$5e4bdbfa16cc6f60$var$matchKey","pathMatch","methodMatch","bodyMatch","headersMatch","splice","$5e4bdbfa16cc6f60$var$buildKey","opts","$5e4bdbfa16cc6f60$var$generateKeyValues","reduce","keyValuePairs","from","x","$5e4bdbfa16cc6f60$var$getStatusText","statusCode","$5e4bdbfa16cc6f60$require$STATUS_CODES","$5e4bdbfa16cc6f60$var$mockDispatch","handler","timesInvoked","callback","trailers","error","delay","persist","times","pending","onError","handleReply","_data","optsHeaders","then","newData","responseData","responseHeaders","responseTrailers","abort","onHeaders","resume","onData","onComplete","setTimeout","$5e4bdbfa16cc6f60$var$checkNetConnect","netConnect","origin","url","URL","some","matcher","host","getResponseData","getMockDispatch","addMockDispatch","replyData","newMockDispatch","deleteMockDispatch","buildKey","generateKeyValues","matchValue","getResponse","$5e4bdbfa16cc6f60$var$getResponse","buffers","concat","getStatusText","buildMockDispatch","agent","originalDispatch","isMockActive","call","message","checkNetConnect","buildMockOptions","mockOptions","getHeaderByName","default"],"version":3,"file":"python-version-check.3b10f8a1.js.map","sourceRoot":"../"}