{"mappings":"ICmFI,C,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,W,M,Q,A,Q,Q,C,K,K,A,Q,iB,C,K,M,A,Q,Y,C,K,Q,C,I,E,C,EArEE,EAAA,sDAAA,iCAAA,CAAA,EAAA,sDAAA,kCAAA,CAAA,EAAA,sDAAA,oBAAA,CAAA,EAAA,sDAAA,mBAAA,CAAA,EAAA,sDAAA,mBAAA,CAAA,EAAA,sDAAA,oBAAA,CAAA,EAAA,EAAA,WAAA,CAAA,EAAA,sDAAA,kBAAA,CAAA,EAAA,qDAAA,gBAAA,CAAA,EAAA,sDAAA,eAAA,CAAA,EAAA,uDAAA,4BAAA,CAAA,EAAA,sDAAA,oBAAA,CAeA,EAAA,uDAAA,IAAA,CAAA,EAAA,uDAAA,MAAA,CAAA,EAAA,uDAAA,WAAA,CAAA,EAAA,sDAAA,OAAA,CAAA,EAAA,sDAAA,KAAA,CAAA,EAAA,uDAAA,OAAA,CAAA,EAAA,sDAAA,QAAA,CAAA,EAAA,qDAAA,SAAA,CAAA,EAAA,uDAAA,SAAA,CAAA,EAAA,uDAAA,QAAA,CAAA,EAAA,uDAAA,QAAA,CAAA,EAAA,uDAAA,KAAA,CAAA,EAAA,EAAA,QAAA,CAAA,EAAA,uDAAA,MAAA,CAAA,EAAA,sDAAA,UAAA,CAAA,EAAA,sDAAA,WAAA,CAAA,EAAA,uDAAA,UAAA,CAAA,EAAA,uDAAA,MAAA,CAAA,EAAA,uDAAA,wBAAA,CAAA,EAAA,uDAAA,WAAA,CAAA,EAAA,uDAAA,WAAA,CAAA,EAAA,uDAAA,WAAA,CAAA,EAAA,uDAAA,MAAA,CAAA,EAAA,uDAAA,WAAA,CAAA,EAAA,uDAAA,OAAA,CAAA,GAAA,uDAAA,sBAAA,CAAA,GAAA,uDAAA,eAAA,CAAA,GAAA,uDAAA,oBAAA,CAAA,GAAA,uDAAA,0BAAA,CAAA,GAAA,uDAAA,eAAA,CAAA,GAAA,sDAAA,YAAA,CAAA,GAAA,uDAAA,oBAAA,CAAA,GAAA,sDAAA,UAAA,CAAA,GAAA,uDAAA,gBAAA,CAAA,GAAA,uDAAA,YAAA,CAAA,GAAA,sDAAA,QAAA,CAAA,GAAA,sDAAA,MAAA,CAAA,GAAA,uDAAA,QAAA,CAAA,GAAA,uDAAA,SAAA,CAAA,GAAA,uDAAA,aAAA,CAAA,GAAA,uDAAA,aAAA,CAAA,GAAA,uDAAA,gBAAA,CAAA,GAAA,uDAAA,gBAAA,CAAA,GAAA,uDAAA,KAAA,CAAA,GAAA,uDAAA,aAAA,CAAA,GAAA,uDAAA,kBAAA,CAAA,GAAA,uDAAA,kBAAA,CAAA,GAAA,uDAAA,iBAAA,CAAA,GAAA,uDAAA,kBAAA,CAuDN,GAAI,CACF,EAAQ,yCACV,CAAE,KAAM,CAEN,EAAQ,CAAE,UAAW,CAAC,CAAE,CAC1B,CAEA,GAAM,CACJ,UAAW,CAAA,uBACT,EAAsB,CAAA,oBACtB,EAAmB,CAAA,kBACnB,EAAiB,CAAA,oBACjB,EAAmB,CAAA,4BACnB,EAA2B,CAAA,oBAC3B,EAAmB,CAAA,oBACnB,EAAmB,CACpB,CACF,CAAG,EAGA,GAAuB,CAAA,EAErB,GAAa,MAAM,CAAC,OAAO,OAAO,CAAC,CAEnC,GAAiB,OAAO,kBAExB,GAAW,CAAC,EAElB,GAAI,CACF,IAAM,EAAqB,yCAC3B,CAAA,GAAS,WAAW,CAAG,EAAmB,OAAO,CAAC,6BAClD,GAAS,aAAa,CAAG,EAAmB,OAAO,CAAC,+BACpD,GAAS,YAAY,CAAG,EAAmB,OAAO,CAAC,8BACnD,GAAS,SAAS,CAAG,EAAmB,OAAO,CAAC,0BAClD,CAAE,KAAM,CACN,GAAS,WAAW,CAAG,CAAE,eAAgB,CAAA,CAAM,EAC/C,GAAS,aAAa,CAAG,CAAE,eAAgB,CAAA,CAAM,EACjD,GAAS,YAAY,CAAG,CAAE,eAAgB,CAAA,CAAM,EAChD,GAAS,SAAS,CAAG,CAAE,eAAgB,CAAA,CAAM,CAC/C,CAiTA,SAAS,GAAqB,CAAG,EAC/B,EAAO,AAAa,iCAAb,EAAI,IAAI,EAEf,IAAI,CAAA,EAAS,CAAA,EAAQ,CAAG,EAExB,GAAQ,IAAI,CAAA,EAAS,CAAE,EACzB,CAEA,SAAS,GAAmB,CAAI,CAAE,CAAI,CAAE,CAAE,EACxC,IAAM,EAAM,IAAA,EAAuB,CAAC,qCAAqC,EAAE,EAAK,OAAO,EAAE,EAAA,CAAM,CAEpF,CAAA,IAAP,IACF,IAAI,CAAA,EAAS,CAAA,EAAQ,CAAG,EACxB,GAAQ,IAAI,CAAA,EAAS,CAAE,GAE3B,CAEA,SAAS,KACP,sDAAA,OAAA,CAAa,IAAI,CAAE,IAAA,EAAgB,sBACnC,sDAAA,OAAA,CAAa,IAAI,CAAA,EAAS,CAAE,IAAA,EAAgB,qBAC9C,CAEA,SAAS,GAAe,CAAI,EAC1B,IAAM,EAAS,IAAI,CAAA,EAAS,CACtB,EAAM,IAAA,EAAuB,CAAC,0CAA0C,EAAE,EAAA,CAAM,EAItF,GAHA,CAAM,CAAA,EAAS,CAAG,KAClB,CAAM,CAAA,GAAe,CAAG,KAEpB,EAAO,SAAS,CAAE,CACpB,EAAO,AAAmB,IAAnB,IAAI,CAAA,EAAU,EAGrB,IAAM,EAAW,CAAM,CAAA,EAAQ,CAAC,MAAM,CAAC,CAAM,CAAA,EAAa,EAC1D,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAEnC,GAAa,IAAI,CADD,CAAQ,CAAC,EAAE,CACC,EAEhC,MAAO,GAAI,CAAM,CAAA,EAAU,CAAG,EAAG,CAE/B,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,AACnD,CAAA,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,GAAG,CAAG,KAExC,GAAa,EAAQ,EAAS,EAChC,CAEA,CAAM,CAAA,EAAa,CAAG,CAAM,CAAA,EAAa,CAEzC,EAAO,AAAqB,IAArB,CAAM,CAAA,EAAU,EAEvB,EAAO,IAAI,CAAC,aACV,CAAM,CAAA,EAAM,CACZ,CAAC,EAAO,CACR,GAGF,GAAO,EACT,CAIA,IAAM,GAAY,OAAO,KAAK,CAAC,GAgE3B,GAAiB,KACjB,GAAgB,AA/DpB,iBACE,IAEI,EAFE,EAAiB,QAAQ,GAAG,CAAC,cAAc,CAAG,EAAqC,KAAA,EAGzF,GAAI,CACF,EAAM,MAAM,YAAY,OAAO,CAAC,OAAO,IAAI,CAAC,EAAyC,UACvF,CAAE,MAAO,EAAG,CAOV,EAAM,MAAM,YAAY,OAAO,CAAC,OAAO,IAAI,CAAC,GAAkB,EAAoC,UACpG,CAEA,OAAO,MAAM,YAAY,WAAW,CAAC,EAAK,CACxC,IAAK,CAGH,YAAa,CAAC,EAAG,EAAI,IAEZ,EAET,eAAgB,CAAC,EAAG,EAAI,KACtB,EAAO,WAAW,CAAC,GAAc,GAAG,CAAE,GACtC,IAAM,EAAQ,EAAK,GAAmB,GAAiB,UAAU,CACjE,OAAO,GAAc,QAAQ,CAAC,IAAI,GAAW,GAAiB,MAAM,CAAE,EAAO,KAAS,CACxF,EACA,sBAAuB,AAAC,IACtB,EAAO,WAAW,CAAC,GAAc,GAAG,CAAE,GAC/B,GAAc,cAAc,IAAM,GAE3C,qBAAsB,CAAC,EAAG,EAAI,KAC5B,EAAO,WAAW,CAAC,GAAc,GAAG,CAAE,GACtC,IAAM,EAAQ,EAAK,GAAmB,GAAiB,UAAU,CACjE,OAAO,GAAc,aAAa,CAAC,IAAI,GAAW,GAAiB,MAAM,CAAE,EAAO,KAAS,CAC7F,EACA,qBAAsB,CAAC,EAAG,EAAI,KAC5B,EAAO,WAAW,CAAC,GAAc,GAAG,CAAE,GACtC,IAAM,EAAQ,EAAK,GAAmB,GAAiB,UAAU,CACjE,OAAO,GAAc,aAAa,CAAC,IAAI,GAAW,GAAiB,MAAM,CAAE,EAAO,KAAS,CAC7F,EACA,yBAA0B,CAAC,EAAG,EAAY,EAAS,KACjD,EAAO,WAAW,CAAC,GAAc,GAAG,CAAE,GAC/B,GAAc,iBAAiB,CAAC,EAAY,CAAA,CAAQ,EAAU,CAAA,CAAQ,IAAqB,GAEpG,aAAc,CAAC,EAAG,EAAI,KACpB,EAAO,WAAW,CAAC,GAAc,GAAG,CAAE,GACtC,IAAM,EAAQ,EAAK,GAAmB,GAAiB,UAAU,CACjE,OAAO,GAAc,MAAM,CAAC,IAAI,GAAW,GAAiB,MAAM,CAAE,EAAO,KAAS,CACtF,EACA,yBAA0B,AAAC,IACzB,EAAO,WAAW,CAAC,GAAc,GAAG,CAAE,GAC/B,GAAc,iBAAiB,IAAM,EAIhD,CACF,EACF,IAIA,GAAc,KAAK,GAEnB,IAAI,GAAgB,KAChB,GAAmB,KACnB,GAAoB,EACpB,GAAmB,IAMvB,OAAM,GACJ,YAAa,CAAM,CAAE,CAAM,CAAE,CAAA,QAAE,CAAO,CAAE,CAAE,CACxC,EAAO,OAAO,QAAQ,CAAC,CAAM,CAAA,GAAiB,GAAK,CAAM,CAAA,GAAiB,CAAG,GAE7E,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,EAAA,IAAA,CAAe,QAAQ,EAC3D,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,OAAO,CAAG,KACf,IAAI,CAAC,YAAY,CAAG,KACpB,IAAI,CAAC,WAAW,CAAG,KACnB,IAAI,CAAC,UAAU,CAAG,KAClB,IAAI,CAAC,UAAU,CAAG,GAClB,IAAI,CAAC,OAAO,CAAG,CAAA,EACf,IAAI,CAAC,OAAO,CAAG,EAAE,CACjB,IAAI,CAAC,WAAW,CAAG,EACnB,IAAI,CAAC,cAAc,CAAG,CAAM,CAAA,GAAiB,CAC7C,IAAI,CAAC,eAAe,CAAG,CAAA,EACvB,IAAI,CAAC,MAAM,CAAG,CAAA,EACd,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAEnC,IAAI,CAAC,SAAS,CAAG,EAEjB,IAAI,CAAC,SAAS,CAAG,GACjB,IAAI,CAAC,aAAa,CAAG,GACrB,IAAI,CAAC,UAAU,CAAG,GAClB,IAAI,CAAC,eAAe,CAAG,CAAM,CAAA,GAAkB,AACjD,CAEA,WAAY,CAAK,CAAE,CAAI,CAAE,CACvB,IAAI,CAAC,WAAW,CAAG,EACf,IAAU,IAAI,CAAC,YAAY,EAC7B,qDAAA,YAAA,CAAoB,IAAI,CAAC,OAAO,EAC5B,GACF,IAAI,CAAC,OAAO,CAAG,EAAA,UAAA,CAAkB,GAAiB,EAAO,IAAI,EAEzD,IAAI,CAAC,OAAO,CAAC,KAAK,EACpB,IAAI,CAAC,OAAO,CAAC,KAAK,IAGpB,IAAI,CAAC,OAAO,CAAG,KAEjB,IAAI,CAAC,YAAY,CAAG,GACX,IAAI,CAAC,OAAO,EAEjB,IAAI,CAAC,OAAO,CAAC,OAAO,EACtB,IAAI,CAAC,OAAO,CAAC,OAAO,EAG1B,CAEA,QAAU,EACJ,IAAI,CAAC,MAAM,CAAC,SAAS,EAAK,IAAI,CAAC,MAAM,GAIzC,EAAO,AAAY,MAAZ,IAAI,CAAC,GAAG,EACf,EAAO,AAAiB,MAAjB,IAEP,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,EAElC,EAAO,AAhEU,IAgEV,IAAI,CAAC,WAAW,EACnB,IAAI,CAAC,OAAO,EAEV,IAAI,CAAC,OAAO,CAAC,OAAO,EACtB,IAAI,CAAC,OAAO,CAAC,OAAO,GAIxB,IAAI,CAAC,MAAM,CAAG,CAAA,EACd,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAM,IACnC,IAAI,CAAC,QAAQ,GACf,CAEA,UAAY,CACV,KAAO,CAAC,IAAI,CAAC,MAAM,EAAI,IAAI,CAAC,GAAG,EAAE,CAC/B,IAAM,EAAQ,IAAI,CAAC,MAAM,CAAC,IAAI,GAC9B,GAAI,AAAU,OAAV,EACF,MAEF,IAAI,CAAC,OAAO,CAAC,EACf,CACF,CAEA,QAAS,CAAI,CAAE,CACb,EAAO,AAAY,MAAZ,IAAI,CAAC,GAAG,EACf,EAAO,AAAiB,MAAjB,IACP,EAAO,CAAC,IAAI,CAAC,MAAM,EAEnB,GAAM,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,AAE3B,CAAA,EAAK,MAAM,CAAG,KACZ,IACF,EAAO,IAAI,CAAC,IAEd,GAAoB,AAAgC,KAAhC,KAAK,IAAI,CAAC,EAAK,MAAM,CAAG,MAC5C,GAAmB,EAAO,MAAM,CAAC,KAGnC,IAAI,WAAW,EAAO,MAAM,CAAC,MAAM,CAAE,GAAkB,IAAmB,GAAG,CAAC,GAM9E,GAAI,KACE,EAEJ,GAAI,CACF,GAAmB,EACnB,GAAgB,IAAI,CACpB,EAAM,EAAO,cAAc,CAAC,IAAI,CAAC,GAAG,CAAE,GAAkB,EAAK,MAAM,CAErE,CAAE,MAAO,EAAK,CAEZ,MAAM,CACR,QAAU,CACR,GAAgB,KAChB,GAAmB,IACrB,CAEA,IAAM,EAAS,EAAO,oBAAoB,CAAC,IAAI,CAAC,GAAG,EAAI,GAEvD,GAAI,IAAQ,qDAAA,KAAA,CAAgB,cAAc,CACxC,IAAI,CAAC,SAAS,CAAC,EAAK,KAAK,CAAC,SACrB,GAAI,IAAQ,qDAAA,KAAA,CAAgB,MAAM,CACvC,IAAI,CAAC,MAAM,CAAG,CAAA,EACd,EAAO,OAAO,CAAC,EAAK,KAAK,CAAC,SACrB,GAAI,IAAQ,qDAAA,KAAA,CAAgB,EAAE,CAAE,CACrC,IAAM,EAAM,EAAO,uBAAuB,CAAC,IAAI,CAAC,GAAG,EAC/C,EAAU,GAEd,GAAI,EAAK,CACP,IAAM,EAAM,IAAI,WAAW,EAAO,MAAM,CAAC,MAAM,CAAE,GAAK,OAAO,CAAC,GAC9D,EACE,kDACA,OAAO,IAAI,CAAC,EAAO,MAAM,CAAC,MAAM,CAAE,EAAK,GAAK,QAAQ,GACpD,GACJ,CACA,MAAM,IAAA,EAAoB,EAAS,qDAAA,KAAe,CAAC,EAAI,CAAE,EAAK,KAAK,CAAC,GACtE,CACF,CAAE,MAAO,EAAK,CACZ,sDAAA,OAAA,CAAa,EAAQ,EACvB,CACF,CAEA,SAAW,CACT,EAAO,AAAY,MAAZ,IAAI,CAAC,GAAG,EACf,EAAO,AAAiB,MAAjB,IAEP,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,EAChC,IAAI,CAAC,GAAG,CAAG,KAEX,qDAAA,YAAA,CAAoB,IAAI,CAAC,OAAO,EAChC,IAAI,CAAC,OAAO,CAAG,KACf,IAAI,CAAC,YAAY,CAAG,KACpB,IAAI,CAAC,WAAW,CAAG,KAEnB,IAAI,CAAC,MAAM,CAAG,CAAA,CAChB,CAEA,SAAU,CAAG,CAAE,CACb,IAAI,CAAC,UAAU,CAAG,EAAI,QAAQ,EAChC,CAEA,gBAAkB,CAChB,GAAM,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAG/B,GAAI,EAAO,SAAS,EAKhB,CADY,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,CAHjD,OAAO,EAOX,CAEA,cAAe,CAAG,CAAE,CAClB,IAAM,EAAM,IAAI,CAAC,OAAO,CAAC,MAAM,AAE3B,CAAC,CAAA,AAAM,EAAN,CAAM,GAAO,EAChB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAElB,IAAI,CAAC,OAAO,CAAC,EAAM,EAAE,CAAG,OAAO,MAAM,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,EAAM,EAAE,CAAE,EAAI,EAGpE,IAAI,CAAC,WAAW,CAAC,EAAI,MAAM,CAC7B,CAEA,cAAe,CAAG,CAAE,CAClB,IAAI,EAAM,IAAI,CAAC,OAAO,CAAC,MAAM,AAExB,CAAA,CAAA,AAAM,EAAN,CAAM,GAAO,GAChB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAClB,GAAO,GAEP,IAAI,CAAC,OAAO,CAAC,EAAM,EAAE,CAAG,OAAO,MAAM,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,EAAM,EAAE,CAAE,EAAI,EAGpE,IAAM,EAAM,IAAI,CAAC,OAAO,CAAC,EAAM,EAAE,AAC7B,AAAe,CAAA,KAAf,EAAI,MAAM,EAAW,AAAiC,eAAjC,EAAI,QAAQ,GAAG,WAAW,GACjD,IAAI,CAAC,SAAS,EAAI,EAAI,QAAQ,GACrB,AAAe,KAAf,EAAI,MAAM,EAAW,AAAiC,eAAjC,EAAI,QAAQ,GAAG,WAAW,GACxD,IAAI,CAAC,UAAU,EAAI,EAAI,QAAQ,GACtB,AAAe,KAAf,EAAI,MAAM,EAAW,AAAiC,mBAAjC,EAAI,QAAQ,GAAG,WAAW,IACxD,CAAA,IAAI,CAAC,aAAa,EAAI,EAAI,QAAQ,EAD7B,EAIP,IAAI,CAAC,WAAW,CAAC,EAAI,MAAM,CAC7B,CAEA,YAAa,CAAG,CAAE,CAChB,IAAI,CAAC,WAAW,EAAI,EAChB,IAAI,CAAC,WAAW,EAAI,IAAI,CAAC,cAAc,EACzC,sDAAA,OAAA,CAAa,IAAI,CAAC,MAAM,CAAE,IAD5B,EAGF,CAEA,UAAW,CAAI,CAAE,CACf,GAAM,CAAA,QAAE,CAAO,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAA,QAAE,CAAO,CAAA,WAAE,CAAU,CAAE,CAAG,IAAI,CAE7D,EAAO,GAEP,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,CACnD,EAAO,GAEP,EAAO,CAAC,EAAO,SAAS,EACxB,EAAO,IAAW,CAAM,CAAA,EAAS,EACjC,EAAO,CAAC,IAAI,CAAC,MAAM,EACnB,EAAO,EAAQ,OAAO,EAAI,AAAmB,YAAnB,EAAQ,MAAM,EAExC,IAAI,CAAC,UAAU,CAAG,KAClB,IAAI,CAAC,UAAU,CAAG,GAClB,IAAI,CAAC,eAAe,CAAG,KAEvB,EAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,GAAM,GACnC,IAAI,CAAC,OAAO,CAAG,EAAE,CACjB,IAAI,CAAC,WAAW,CAAG,EAEnB,EAAO,OAAO,CAAC,GAEf,CAAM,CAAA,EAAS,CAAC,OAAO,GACvB,CAAM,CAAA,EAAS,CAAG,KAElB,CAAM,CAAA,EAAS,CAAG,KAClB,CAAM,CAAA,EAAQ,CAAG,KACjB,EACG,cAAc,CAAC,QAAS,IACxB,cAAc,CAAC,WAAY,IAC3B,cAAc,CAAC,MAAO,IACtB,cAAc,CAAC,QAAS,IAE3B,CAAM,CAAA,EAAS,CAAG,KAClB,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,GAAG,CAAG,KACxC,EAAO,IAAI,CAAC,aAAc,CAAM,CAAA,EAAM,CAAE,CAAC,EAAO,CAAE,IAAA,EAAuB,YAEzE,GAAI,CACF,EAAQ,SAAS,CAAC,EAAY,EAAS,EACzC,CAAE,MAAO,EAAK,CACZ,sDAAA,OAAA,CAAa,EAAQ,EACvB,CAEA,GAAO,EACT,CAEA,kBAAmB,CAAU,CAAE,CAAO,CAAE,CAAe,CAAE,CACvD,GAAM,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAA,QAAE,CAAO,CAAA,WAAE,CAAU,CAAE,CAAG,IAAI,CAGpD,GAAI,EAAO,SAAS,CAClB,OAAO,GAGT,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,CAGnD,GAAI,CAAC,EACH,OAAO,GAMT,GAHA,EAAO,CAAC,IAAI,CAAC,OAAO,EACpB,EAAO,IAAI,CAAC,UAAU,CAAG,KAErB,AAAe,MAAf,EAEF,OADA,sDAAA,OAAA,CAAa,EAAQ,IAAA,EAAgB,eAAgB,sDAAA,aAAA,CAAmB,KACjE,GAIT,GAAI,GAAW,CAAC,EAAQ,OAAO,CAE7B,OADA,sDAAA,OAAA,CAAa,EAAQ,IAAA,EAAgB,cAAe,sDAAA,aAAA,CAAmB,KAChE,GAYT,GATA,EAAO,WAAW,CAAC,IAAI,CAAC,WAAW,CA5Sf,GA8SpB,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,eAAe,CAClB,GAEC,AAAmB,SAAnB,EAAQ,MAAM,EAAe,CAAC,CAAM,CAAA,EAAQ,EAAI,AAAkC,eAAlC,IAAI,CAAC,UAAU,CAAC,WAAW,GAG1E,IAAI,CAAC,UAAU,EAAI,IAAK,CAC1B,IAAM,EAAc,AAAuB,MAAvB,EAAQ,WAAW,CACnC,EAAQ,WAAW,CACnB,CAAM,CAAA,GAAc,CACxB,IAAI,CAAC,UAAU,CAAC,EAxTD,EAyTjB,MAAW,IAAI,CAAC,OAAO,EAEjB,IAAI,CAAC,OAAO,CAAC,OAAO,EACtB,IAAI,CAAC,OAAO,CAAC,OAAO,GAIxB,GAAuB,YAAnB,EAAQ,MAAM,EAMd,EAHF,OAFA,EAAO,AAAqB,IAArB,CAAM,CAAA,EAAU,EACvB,IAAI,CAAC,OAAO,CAAG,CAAA,EACR,EAaT,GAJA,EAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,GAAM,GACnC,IAAI,CAAC,OAAO,CAAG,EAAE,CACjB,IAAI,CAAC,WAAW,CAAG,EAEf,IAAI,CAAC,eAAe,EAAI,CAAM,CAAA,EAAa,CAAE,CAC/C,IAAM,EAAmB,IAAI,CAAC,SAAS,CAAG,sDAAA,qBAAA,CAA2B,IAAI,CAAC,SAAS,EAAI,KAEvF,GAAI,AAAoB,MAApB,EAA0B,CAC5B,IAAM,EAAU,KAAK,GAAG,CACtB,EAAmB,CAAM,CAAA,GAA4B,CACrD,CAAM,CAAA,GAAsB,CAE1B,CAAA,GAAW,EACb,CAAM,CAAA,EAAQ,CAAG,CAAA,EAEjB,CAAM,CAAA,GAAwB,CAAG,CAErC,MACE,CAAM,CAAA,GAAwB,CAAG,CAAM,CAAA,EAA0B,AAErE,MAEE,CAAM,CAAA,EAAQ,CAAG,CAAA,EAGnB,IAAM,EAAQ,AAAoE,CAAA,IAApE,EAAQ,SAAS,CAAC,EAAY,EAAS,IAAI,CAAC,MAAM,CAAE,UAElE,AAAI,EAAQ,OAAO,CACV,GAGc,SAAnB,EAAQ,MAAM,EAId,EAAa,IAHR,GAOL,CAAM,CAAA,EAAW,GACnB,CAAM,CAAA,EAAW,CAAG,CAAA,EACpB,GAAO,IAGF,EAAQ,qDAAA,KAAA,CAAgB,MAAM,CAAG,EAC1C,CAEA,OAAQ,CAAG,CAAE,CACX,GAAM,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAA,WAAE,CAAU,CAAA,gBAAE,CAAe,CAAE,CAAG,IAAI,CAE5D,GAAI,EAAO,SAAS,CAClB,OAAO,GAGT,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,OAanD,CAZA,EAAO,GAEP,EAAO,WAAW,CAAC,IAAI,CAAC,WAAW,CArYlB,GAsYb,IAAI,CAAC,OAAO,EAEV,IAAI,CAAC,OAAO,CAAC,OAAO,EACtB,IAAI,CAAC,OAAO,CAAC,OAAO,GAIxB,EAAO,GAAc,KAEjB,EAAkB,IAAM,IAAI,CAAC,SAAS,CAAG,EAAI,MAAM,CAAG,IACxD,sDAAA,OAAA,CAAa,EAAQ,IAArB,GACO,KAGT,IAAI,CAAC,SAAS,EAAI,EAAI,MAAM,CAExB,AAAwB,CAAA,IAAxB,EAAQ,MAAM,CAAC,IACV,qDAAA,KAAA,CAAgB,MAAM,OAEjC,CAEA,mBAAqB,CACnB,GAAM,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAA,WAAE,CAAU,CAAA,QAAE,CAAO,CAAA,QAAE,CAAO,CAAA,cAAE,CAAa,CAAA,UAAE,CAAS,CAAA,gBAAE,CAAe,CAAE,CAAG,IAAI,CAExG,GAAI,EAAO,SAAS,EAAK,CAAA,CAAC,GAAc,CAAA,EACtC,OAAO,GAGT,GAAI,EACF,OAGF,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,CAgBnD,GAfA,EAAO,GAEP,EAAO,GAAc,KAErB,IAAI,CAAC,UAAU,CAAG,KAClB,IAAI,CAAC,UAAU,CAAG,GAClB,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,aAAa,CAAG,GACrB,IAAI,CAAC,SAAS,CAAG,GACjB,IAAI,CAAC,UAAU,CAAG,GAElB,EAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAG,GAAM,GACnC,IAAI,CAAC,OAAO,CAAG,EAAE,CACjB,IAAI,CAAC,WAAW,CAAG,GAEf,CAAA,EAAa,GAAA,GAKjB,GAAI,AAAmB,SAAnB,EAAQ,MAAM,EAAe,GAAiB,IAAc,SAAS,EAAe,IAEtF,OADA,sDAAA,OAAA,CAAa,EAAQ,IAArB,GACO,GAOT,GAJA,EAAQ,UAAU,CAAC,GAEnB,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,GAAG,CAAG,KAEpC,CAAM,CAAA,EAAU,CAIlB,OAHA,EAAO,WAAW,CAAC,CAAM,CAAA,EAAU,CAAE,GAErC,sDAAA,OAAA,CAAa,EAAQ,IAAA,EAAuB,UACrC,qDAAA,KAAA,CAAgB,MAAM,CACxB,GAAI,CAAC,EAEV,OADA,sDAAA,OAAA,CAAa,EAAQ,IAAA,EAAuB,UACrC,qDAAA,KAAA,CAAgB,MAAM,CACxB,GAAI,CAAM,CAAA,EAAQ,EAAI,AAAqB,IAArB,CAAM,CAAA,EAAU,CAM3C,OADA,sDAAA,OAAA,CAAa,EAAQ,IAAA,EAAuB,UACrC,qDAAA,KAAA,CAAgB,MAAM,AACpB,AAAwB,CAAA,IAAxB,CAAM,CAAA,EAAa,CAI5B,aAAa,GAAQ,GAErB,GAAO,GAEX,CACF,CAEA,SAAS,GAAiB,CAAM,EAC9B,GAAM,CAAA,OAAE,CAAM,CAAA,YAAE,CAAW,CAAA,OAAE,CAAM,CAAE,CAAG,CAGpC,AAnekB,CAAA,IAmelB,EACE,CAAA,CAAC,CAAM,CAAA,EAAU,EAAI,EAAO,iBAAiB,EAAI,CAAM,CAAA,EAAU,CAAG,CAAA,IACtE,EAAO,CAAC,EAAO,MAAM,CAAE,8CACvB,sDAAA,OAAA,CAAa,EAAQ,IAArB,IAEO,AAveQ,IAueR,EACL,AAAC,EAAO,MAAM,EAChB,sDAAA,OAAA,CAAa,EAAQ,IADvB,GAveiB,IA0eR,IACT,EAAO,AAAqB,IAArB,CAAM,CAAA,EAAU,EAAU,CAAM,CAAA,GAAwB,EAC/D,sDAAA,OAAA,CAAa,EAAQ,IAAA,EAAuB,wBAEhD,CAEA,SAAS,KACP,GAAM,CAAE,CAAA,EAAS,CAAE,CAAM,CAAE,CAAG,IAAI,AAC9B,CAAA,GACF,EAAO,QAAQ,EAEnB,CAEA,SAAS,GAAe,CAAG,EACzB,GAAM,CAAE,CAAA,EAAS,CAAE,CAAM,CAAE,CAAA,EAAS,CAAE,CAAM,CAAE,CAAG,IAAI,CAIrD,GAFA,EAAO,AAAa,iCAAb,EAAI,IAAI,EAEX,AAA6B,OAA7B,CAAM,CAAA,GAAkB,EAGtB,AAAa,eAAb,EAAI,IAAI,EAAqB,EAAO,UAAU,EAAI,CAAC,EAAO,eAAe,CAAE,YAE7E,EAAO,iBAAiB,EAK5B,CAAA,IAAI,CAAA,EAAQ,CAAG,EAEf,GAAQ,IAAI,CAAA,EAAS,CAAE,EACzB,CAEA,SAAS,GAAS,CAAM,CAAE,CAAG,EAC3B,GACE,AAAqB,IAArB,CAAM,CAAA,EAAU,EAChB,AAAa,iBAAb,EAAI,IAAI,EACR,AAAa,mBAAb,EAAI,IAAI,CACR,CAIA,EAAO,CAAM,CAAA,EAAa,GAAK,CAAM,CAAA,EAAa,EAElD,IAAM,EAAW,CAAM,CAAA,EAAQ,CAAC,MAAM,CAAC,CAAM,CAAA,EAAa,EAC1D,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAEnC,GAAa,EADG,CAAQ,CAAC,EAAE,CACG,GAEhC,EAAO,AAAkB,IAAlB,CAAM,CAAA,EAAO,CACtB,CACF,CAEA,SAAS,KACP,GAAM,CAAE,CAAA,EAAS,CAAE,CAAM,CAAE,CAAA,EAAS,CAAE,CAAM,CAAE,CAAG,IAAI,CAErD,GAAI,AAA6B,OAA7B,CAAM,CAAA,GAAkB,EACtB,EAAO,UAAU,EAAI,CAAC,EAAO,eAAe,CAAE,YAEhD,EAAO,iBAAiB,GAK5B,sDAAA,OAAA,CAAa,IAAI,CAAE,IAAA,EAAgB,oBAAqB,sDAAA,aAAA,CAAmB,IAAI,GACjF,CAEA,SAAS,KACP,GAAM,CAAE,CAAA,EAAS,CAAE,CAAM,CAAE,CAAA,EAAS,CAAE,CAAM,CAAE,CAAG,IAAI,AAEpB,CAAA,OAA7B,CAAM,CAAA,GAAkB,EAAa,IACnC,AAAC,IAAI,CAAA,EAAQ,GAAI,EAAO,UAAU,EAAK,EAAO,eAAe,EAE/D,EAAO,iBAAiB,GAG1B,IAAI,CAAA,EAAS,CAAC,OAAO,GACrB,IAAI,CAAA,EAAS,CAAG,MAGlB,IAAM,EAAM,IAAI,CAAA,EAAQ,EAAI,IAAA,EAAgB,SAAU,sDAAA,aAAA,CAAmB,IAAI,GAI7E,GAFA,CAAM,CAAA,EAAS,CAAG,KAEd,EAAO,SAAS,CAAE,CACpB,EAAO,AAAqB,IAArB,CAAM,CAAA,EAAU,EAGvB,IAAM,EAAW,CAAM,CAAA,EAAQ,CAAC,MAAM,CAAC,CAAM,CAAA,EAAa,EAC1D,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAEnC,GAAa,EADG,CAAQ,CAAC,EAAE,CACG,EAElC,MAAO,GAAI,CAAM,CAAA,EAAU,CAAG,GAAK,AAAa,iBAAb,EAAI,IAAI,CAAqB,CAE9D,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,AACnD,CAAA,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,GAAG,CAAG,KAExC,GAAa,EAAQ,EAAS,EAChC,CAEA,CAAM,CAAA,EAAa,CAAG,CAAM,CAAA,EAAa,CAEzC,EAAO,AAAqB,IAArB,CAAM,CAAA,EAAU,EAEvB,EAAO,IAAI,CAAC,aAAc,CAAM,CAAA,EAAM,CAAE,CAAC,EAAO,CAAE,GAElD,GAAO,EACT,CAEA,eAAe,GAAS,CAAM,EAC5B,EAAO,CAAC,CAAM,CAAA,EAAa,EAC3B,EAAO,CAAC,CAAM,CAAA,EAAS,EAEvB,GAAI,CAAA,KAAE,CAAI,CAAA,SAAE,CAAQ,CAAA,SAAE,CAAQ,CAAA,KAAE,CAAI,CAAE,CAAG,CAAM,CAAA,EAAM,CAGrD,GAAI,AAAgB,MAAhB,CAAQ,CAAC,EAAE,CAAU,CACvB,IAAM,EAAM,EAAS,OAAO,CAAC,KAE7B,EAAO,AAAQ,KAAR,GACP,IAAM,EAAK,EAAS,SAAS,CAAC,EAAG,GAEjC,EAAO,EAAS,IAChB,EAAW,CACb,CAEA,CAAM,CAAA,EAAa,CAAG,CAAA,EAElB,GAAS,aAAa,CAAC,cAAc,EACvC,GAAS,aAAa,CAAC,OAAO,CAAC,CAC7B,cAAe,CACb,KAAA,EACA,SAAA,EACA,SAAA,EACA,KAAA,EACA,WAAY,CAAM,CAAA,EAAa,CAC/B,aAAc,CAAM,CAAA,GAAe,AACrC,EACA,UAAW,CAAM,CAAA,GAAY,AAC/B,GAGF,GAAI,CACF,IAAM,EAAS,MAAM,IAAI,QAAQ,CAAC,EAAS,KACzC,CAAM,CAAA,GAAY,CAAC,CACjB,KAAA,EACA,SAAA,EACA,SAAA,EACA,KAAA,EACA,WAAY,CAAM,CAAA,EAAa,CAC/B,aAAc,CAAM,CAAA,GAAe,AACrC,EAAG,CAAC,EAAK,KACH,EACF,EAAO,GAEP,EAAQ,EAEZ,EACF,GAEA,GAAI,EAAO,SAAS,CAAE,YACpB,sDAAA,OAAA,CAAa,EAAO,EAAE,CAAC,QAAS,KAAO,GAAI,IAA3C,GASF,GALA,CAAM,CAAA,EAAa,CAAG,CAAA,EAEtB,EAAO,GAEM,AAAwB,OAAxB,EAAO,YAAY,CACtB,CACH,KACH,GAAuB,CAAA,EACvB,QAAQ,WAAW,CAAC,iEAAkE,CACpF,KAAM,WACR,IAGF,IAAM,EAAU,EAAM,OAAO,CAAC,CAAM,CAAA,EAAM,CAAE,CAC1C,iBAAkB,IAAM,EACxB,yBAA0B,CAAM,CAAA,GAAoB,CAAC,oBAAoB,AAC3E,EAEA,CAAA,CAAM,CAAA,GAAkB,CAAG,KAC3B,CAAO,CAAA,EAAS,CAAG,EACnB,CAAO,CAAA,EAAS,CAAG,EACnB,EAAQ,EAAE,CAAC,QAAS,IACpB,EAAQ,EAAE,CAAC,aAAc,IACzB,EAAQ,EAAE,CAAC,MAAO,IAClB,EAAQ,EAAE,CAAC,SAAU,IACrB,EAAQ,EAAE,CAAC,QAAS,IACpB,EAAQ,KAAK,GAEb,CAAM,CAAA,GAAe,CAAG,EACxB,CAAM,CAAA,GAAe,CAAG,CAC1B,MACO,KACH,GAAiB,MAAM,GACvB,GAAgB,MAGlB,CAAM,CAAA,EAAQ,CAAG,CAAA,EACjB,CAAM,CAAA,EAAU,CAAG,CAAA,EACnB,CAAM,CAAA,EAAQ,CAAG,CAAA,EACjB,CAAM,CAAA,EAAW,CAAG,CAAA,EACpB,CAAM,CAAA,EAAS,CAAG,IAAI,GAAO,EAAQ,EAAQ,GAG/C,CAAA,CAAM,CAAA,GAAU,CAAG,EACnB,CAAM,CAAA,GAAc,CAAG,CAAM,CAAA,GAAc,CAC3C,CAAM,CAAA,EAAS,CAAG,EAClB,CAAM,CAAA,EAAQ,CAAG,KAEjB,EACG,EAAE,CAAC,QAAS,IACZ,EAAE,CAAC,WAAY,IACf,EAAE,CAAC,MAAO,IACV,EAAE,CAAC,QAAS,IAEf,CAAM,CAAA,EAAS,CAAG,EAEd,GAAS,SAAS,CAAC,cAAc,EACnC,GAAS,SAAS,CAAC,OAAO,CAAC,CACzB,cAAe,CACb,KAAA,EACA,SAAA,EACA,SAAA,EACA,KAAA,EACA,WAAY,CAAM,CAAA,EAAa,CAC/B,aAAc,CAAM,CAAA,GAAe,AACrC,EACA,UAAW,CAAM,CAAA,GAAY,CAC7B,OAAA,CACF,GAEF,EAAO,IAAI,CAAC,UAAW,CAAM,CAAA,EAAM,CAAE,CAAC,EAAO,CAC/C,CAAE,MAAO,EAAK,CACZ,GAAI,EAAO,SAAS,CAClB,OAoBF,GAjBA,CAAM,CAAA,EAAa,CAAG,CAAA,EAElB,GAAS,YAAY,CAAC,cAAc,EACtC,GAAS,YAAY,CAAC,OAAO,CAAC,CAC5B,cAAe,CACb,KAAA,EACA,SAAA,EACA,SAAA,EACA,KAAA,EACA,WAAY,CAAM,CAAA,EAAa,CAC/B,aAAc,CAAM,CAAA,GAAe,AACrC,EACA,UAAW,CAAM,CAAA,GAAY,CAC7B,MAAO,CACT,GAGE,AAAa,iCAAb,EAAI,IAAI,CAEV,IADA,EAAO,AAAqB,IAArB,CAAM,CAAA,EAAU,EAChB,CAAM,CAAA,EAAU,CAAG,GAAK,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,CAAC,UAAU,GAAK,CAAM,CAAA,EAAa,EAAE,CACrG,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,GAAG,CACrD,GAAa,EAAQ,EAAS,EAChC,MAEA,GAAQ,EAAQ,GAGlB,EAAO,IAAI,CAAC,kBAAmB,CAAM,CAAA,EAAM,CAAE,CAAC,EAAO,CAAE,EACzD,CAEA,GAAO,EACT,CAEA,SAAS,GAAW,CAAM,EACxB,CAAM,CAAA,EAAY,CAAG,EACrB,EAAO,IAAI,CAAC,QAAS,CAAM,CAAA,EAAM,CAAE,CAAC,EAAO,CAC7C,CAEA,SAAS,GAAQ,CAAM,CAAE,CAAI,EACD,IAAtB,CAAM,CAAA,EAAW,GAIrB,CAAM,CAAA,EAAW,CAAG,EAEpB,AAUF,SAAkB,CAAM,CAAE,CAAI,EAC5B,OAAa,CACX,GAAI,EAAO,SAAS,CAAE,YACpB,EAAO,AAAqB,IAArB,CAAM,CAAA,EAAU,EAIzB,GAAI,CAAM,CAAC,GAAe,EAAI,CAAC,CAAM,CAAA,EAAO,CAAE,CAC5C,CAAM,CAAC,GAAe,GACtB,CAAM,CAAC,GAAe,CAAG,KACzB,MACF,CAEA,IAAM,EAAS,CAAM,CAAA,EAAS,CAE9B,GAAI,GAAU,CAAC,EAAO,SAAS,EAAI,AAAwB,OAAxB,EAAO,YAAY,CAWpD,CAAA,GAVI,AAAkB,IAAlB,CAAM,CAAA,EAAO,CACX,CAAC,CAAM,CAAA,EAAQ,EAAI,EAAO,KAAK,GACjC,EAAO,KAAK,GACZ,CAAM,CAAA,EAAQ,CAAG,CAAA,GAEV,CAAM,CAAA,EAAQ,EAAI,EAAO,GAAG,GACrC,EAAO,GAAG,GACV,CAAM,CAAA,EAAQ,CAAG,CAAA,GAGf,AAAkB,IAAlB,CAAM,CAAA,EAAO,CACX,AA9yBS,IA8yBT,CAAM,CAAA,EAAS,CAAC,WAAW,EAC7B,CAAM,CAAA,EAAS,CAAC,UAAU,CAAC,CAAM,CAAA,GAAwB,CA/yB9C,QAizBR,GAAI,CAAM,CAAA,EAAU,CAAG,GAAK,CAAM,CAAA,EAAS,CAAC,UAAU,CAAG,KAC1D,AApzBY,IAozBZ,CAAM,CAAA,EAAS,CAAC,WAAW,CAAsB,CACnD,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,CAC7C,EAAiB,AAA0B,MAA1B,EAAQ,cAAc,CACzC,EAAQ,cAAc,CACtB,CAAM,CAAA,GAAiB,CAC3B,CAAM,CAAA,EAAS,CAAC,UAAU,CAAC,EAzzBb,EA0zBhB,CAAA,CAIJ,GAAI,CAAM,CAAA,EAAO,CACf,CAAM,CAAA,EAAY,CAAG,OAChB,GAAI,AAAuB,IAAvB,CAAM,CAAA,EAAY,CAAQ,CAC/B,GACF,CAAM,CAAA,EAAY,CAAG,EACrB,QAAQ,QAAQ,CAAC,GAAW,IAE5B,GAAU,GAEZ,QACF,CAEA,GAAyB,IAArB,CAAM,CAAA,EAAU,EAIhB,CAAM,CAAA,EAAU,EAAK,CAAA,CAAM,CAAA,EAAa,EAAI,CAAA,EAH9C,OAOF,IAAM,EAAU,CAAM,CAAA,EAAQ,CAAC,CAAM,CAAA,EAAa,CAAC,CAEnD,GAAI,AAA0B,WAA1B,CAAM,CAAA,EAAM,CAAC,QAAQ,EAAiB,CAAM,CAAA,EAAa,GAAK,EAAQ,UAAU,CAAE,CACpF,GAAI,CAAM,CAAA,EAAU,CAAG,EACrB,OAKF,GAFA,CAAM,CAAA,EAAa,CAAG,EAAQ,UAAU,CAEpC,GAAU,EAAO,UAAU,GAAK,EAAQ,UAAU,CAAE,YACtD,sDAAA,OAAA,CAAa,EAAQ,IAAA,EAAuB,sBAGhD,CAEA,GAAI,CAAM,CAAA,EAAa,CACrB,OAGF,GAAI,CAAC,GAAU,CAAC,CAAM,CAAA,GAAe,CAAE,YACrC,GAAQ,GAIV,GAAI,EAAO,SAAS,EAAI,CAAM,CAAA,EAAU,EAAI,CAAM,CAAA,EAAQ,EAAI,CAAM,CAAA,EAAW,EAI3E,CAAM,CAAA,EAAU,CAAG,GAAK,CAAC,EAAQ,UAAU,EAO3C,CAAM,CAAA,EAAU,CAAG,GAAM,CAAA,EAAQ,OAAO,EAAI,AAAmB,YAAnB,EAAQ,MAAM,AAAK,GAO/D,CAAM,CAAA,EAAU,CAAG,GAAK,AAAkC,IAAlC,qDAAA,UAAA,CAAgB,EAAQ,IAAI,GACrD,CAAA,sDAAA,QAAA,CAAc,EAAQ,IAAI,GAAK,sDAAA,eAAA,CAAqB,EAAQ,IAAI,CAAA,EAlBjE,MA8BE,EAAC,EAAQ,OAAO,EAAI,AAa5B,SAAgB,CAAM,CAAE,CAAO,EAC7B,GAAI,AAA6B,OAA7B,CAAM,CAAA,GAAkB,CAAW,YACrC,AAmKJ,SAAkB,CAAM,CAAE,CAAO,CAAE,CAAO,EACxC,IAEI,EA2BA,EA7BE,CAAA,KAAE,CAAI,CAAA,OAAE,CAAM,CAAA,KAAE,CAAI,CAAA,KAAE,CAAI,CAAA,QAAE,CAAO,CAAA,eAAE,CAAc,CAAA,OAAE,CAAM,CAAE,QAAS,CAAU,CAAE,CAAG,EAM3F,GAHoC,EAAhC,AAAsB,UAAtB,OAAO,EAAmC,CAAO,CAAA,GAAmB,CAAC,EAAW,IAAI,IACzE,EAEX,EAEF,OADA,GAAa,EAAQ,EAAS,AAAI,MAAM,iCAI1C,GAAI,CAEF,EAAQ,SAAS,CAAC,AAAC,IACb,EAAQ,OAAO,EAAI,EAAQ,SAAS,EAIxC,GAAa,EAAQ,EAAS,GAAO,IAArC,EACF,EACF,CAAE,MAAO,EAAK,CACZ,GAAa,EAAQ,EAAS,EAChC,CAEA,GAAI,EAAQ,OAAO,CACjB,OAKF,IAAM,EAAU,CAAM,CAAA,GAAoB,CAK1C,GAHA,CAAO,CAAC,GAAuB,CAAG,GAAQ,CAAM,CAAA,GAAO,CACvD,CAAO,CAAC,GAAoB,CAAG,EAE3B,AAAW,YAAX,EAwBF,OAvBA,EAAQ,GAAG,GAOP,AAFJ,CAAA,EAAS,EAAQ,OAAO,CAAC,EAAS,CAAE,UAAW,CAAA,EAAO,OAAA,CAAO,EAAA,EAElD,EAAE,EAAI,CAAC,EAAO,OAAO,EAC9B,EAAQ,SAAS,CAAC,KAAM,KAAM,GAC9B,EAAE,EAAQ,WAAW,EAErB,EAAO,IAAI,CAAC,QAAS,KACnB,EAAQ,SAAS,CAAC,KAAM,KAAM,GAC9B,EAAE,EAAQ,WAAW,AACvB,GAGF,EAAO,IAAI,CAAC,QAAS,KACnB,EAAQ,WAAW,EAAI,EAEnB,AAAwB,IAAxB,EAAQ,WAAW,EAAQ,EAAQ,KAAK,EAC9C,EAQF,CAAA,CAAO,CAAC,GAAkB,CAAG,EAC7B,CAAO,CAAC,GAAoB,CAAG,QAW/B,IAAM,EACJ,AAAW,QAAX,GACA,AAAW,SAAX,GACA,AAAW,UAAX,CAGE,CAAA,GAAQ,AAAqB,YAArB,OAAO,EAAK,IAAI,EAE1B,EAAK,IAAI,CAAC,GAGZ,IAAI,EAAgB,qDAAA,UAAA,CAAgB,GAiBpC,GAfI,AAAiB,MAAjB,GACF,CAAA,EAAgB,EAAQ,aAAa,AAAb,EAGtB,AAAkB,IAAlB,GAAwB,GAM1B,CAAA,EAAgB,IAAhB,EAKE,GAAwB,IAAW,EAAgB,GAAK,AAAyB,MAAzB,EAAQ,aAAa,EAAY,EAAQ,aAAa,GAAK,EAAe,CACpI,GAAI,CAAM,CAAA,GAAsB,CAE9B,OADA,GAAa,EAAQ,EAAS,IAA9B,GAIF,QAAQ,WAAW,CAAC,IAApB,EACF,CAEqB,MAAjB,IACF,EAAO,EAAM,wCACb,CAAO,CAAC,GAA4B,CAAG,CAAA,EAAG,EAAA,CAAe,EAG3D,EAAQ,GAAG,GAEX,IAAM,EAAkB,AAAW,QAAX,GAAoB,AAAW,SAAX,EA4E5C,OA3EI,GACF,CAAO,CAAC,GAAoB,CAAG,eAG/B,AAFA,CAAA,EAAS,EAAQ,OAAO,CAAC,EAAS,CAAE,UAAW,EAAiB,OAAA,CAAO,EAAA,EAEhE,IAAI,CAAC,WAAY,KAExB,EAAS,EAAQ,OAAO,CAAC,EAAS,CAChC,UAAW,EACX,OAAA,CACF,GACA,KAIF,EAAE,EAAQ,WAAW,CAErB,EAAO,IAAI,CAAC,WAAY,AAAA,IACtB,GAAM,CAAE,CAAC,GAAoB,CAAE,CAAU,CAAE,GAAG,EAAa,CAAG,CAE1D,AAAuF,EAAA,IAAvF,EAAQ,SAAS,CAAC,OAAO,GAAa,EAAa,EAAO,MAAM,CAAC,IAAI,CAAC,GAAS,KACjF,EAAO,KAAK,EAEhB,GAEA,EAAO,IAAI,CAAC,MAAO,KACjB,EAAQ,UAAU,CAAC,EAAE,CACvB,GAEA,EAAO,EAAE,CAAC,OAAQ,AAAC,IACb,AAA0B,CAAA,IAA1B,EAAQ,MAAM,CAAC,IACjB,EAAO,KAAK,EAEhB,GAEA,EAAO,IAAI,CAAC,QAAS,KACnB,EAAQ,WAAW,EAAI,EAEnB,AAAwB,IAAxB,EAAQ,WAAW,EACrB,EAAQ,KAAK,EAEjB,GAEA,EAAO,IAAI,CAAC,QAAS,SAAU,CAAG,GAC5B,CAAM,CAAA,GAAe,EAAK,CAAM,CAAA,GAAe,CAAC,SAAS,EAAK,IAAI,CAAC,MAAM,EAAK,IAAI,CAAC,SAAS,GAC9F,EAAQ,OAAO,EAAI,EACnB,sDAAA,OAAA,CAAa,EAAQ,GAEzB,GAEA,EAAO,IAAI,CAAC,aAAc,CAAC,EAAM,KAC/B,IAAM,EAAM,IAAA,EAAuB,CAAC,qCAAqC,EAAE,EAAK,OAAO,EAAE,EAAA,CAAM,EAC/F,GAAa,EAAQ,EAAS,IAE1B,CAAM,CAAA,GAAe,EAAK,CAAM,CAAA,GAAe,CAAC,SAAS,EAAK,IAAI,CAAC,MAAM,EAAK,IAAI,CAAC,SAAS,GAC9F,EAAQ,OAAO,EAAI,EACnB,sDAAA,OAAA,CAAa,EAAQ,GAEzB,GAoBA,SAAS,IAEF,EAEM,sDAAA,QAAA,CAAc,IACvB,EAAO,IAAkB,EAAK,UAAU,CAAE,wCAC1C,EAAO,IAAI,GACX,EAAO,KAAK,CAAC,GACb,EAAO,MAAM,GACb,EAAO,GAAG,GACV,EAAQ,UAAU,CAAC,GACnB,EAAQ,aAAa,IACZ,sDAAA,UAAA,CAAgB,GACrB,AAAuB,YAAvB,OAAO,EAAK,MAAM,CACpB,GAAc,CACZ,OAAA,EACA,QAAA,EACA,cAAA,EACA,SAAU,EACV,eAAA,EACA,KAAM,EAAK,MAAM,GACjB,OAAQ,CAAM,CAAA,EAAS,CACvB,OAAQ,EACV,GAEA,GAAU,CACR,KAAA,EACA,OAAA,EACA,QAAA,EACA,cAAA,EACA,eAAA,EACA,SAAU,EACV,OAAQ,GACR,OAAQ,CAAM,CAAA,EAAS,AACzB,GAEO,sDAAA,QAAA,CAAc,GACvB,GAAY,CACV,KAAA,EACA,OAAA,EACA,QAAA,EACA,cAAA,EACA,eAAA,EACA,OAAQ,CAAM,CAAA,EAAS,CACvB,SAAU,EACV,OAAQ,EACV,GACS,sDAAA,UAAA,CAAgB,GACzB,GAAc,CACZ,KAAA,EACA,OAAA,EACA,QAAA,EACA,cAAA,EACA,eAAA,EACA,OAAQ,GACR,SAAU,EACV,OAAQ,CAAM,CAAA,EAAS,AACzB,GAEA,EAAO,CAAA,GAxDP,EAAQ,aAAa,EA0DzB,CACF,EAzaY,EAAQ,CAAM,CAAA,GAAe,CAAE,GAIzC,GAAM,CAAA,KAAE,CAAI,CAAA,OAAE,CAAM,CAAA,KAAE,CAAI,CAAA,KAAE,CAAI,CAAA,QAAE,CAAO,CAAA,QAAE,CAAO,CAAA,SAAE,CAAQ,CAAA,MAAE,CAAK,CAAE,CAAG,EAWlE,EACJ,AAAW,QAAX,GACA,AAAW,SAAX,GACA,AAAW,UAAX,CAGE,CAAA,GAAQ,AAAqB,YAArB,OAAO,EAAK,IAAI,EAE1B,EAAK,IAAI,CAAC,GAGZ,IAAM,EAAa,qDAAA,UAAA,CAAgB,GAE/B,EAAgB,EAiBpB,GAfI,AAAkB,OAAlB,GACF,CAAA,EAAgB,EAAQ,aAAa,AAAb,EAGtB,AAAkB,IAAlB,GAAwB,GAM1B,CAAA,EAAgB,IAAhB,EAKE,GAAwB,IAAW,EAAgB,GAAK,AAA0B,OAA1B,EAAQ,aAAa,EAAa,EAAQ,aAAa,GAAK,EAAe,CACrI,GAAI,CAAM,CAAA,GAAsB,CAE9B,OADA,GAAa,EAAQ,EAAS,IAA9B,GACO,CAAA,EAGT,QAAQ,WAAW,CAAC,IAApB,EACF,CAEA,IAAM,EAAS,CAAM,CAAA,EAAS,CAE9B,GAAI,CACF,EAAQ,SAAS,CAAC,AAAC,IACb,EAAQ,OAAO,EAAI,EAAQ,SAAS,GAIxC,GAAa,EAAQ,EAAS,GAAO,IAArC,GAEA,sDAAA,OAAA,CAAa,EAAQ,IAAA,EAAuB,YAC9C,EACF,CAAE,MAAO,EAAK,CACZ,GAAa,EAAQ,EAAS,EAChC,CAEA,GAAI,EAAQ,OAAO,CACjB,MAAO,CAAA,CAGL,AAAW,CAAA,SAAX,GAKF,CAAA,CAAM,CAAA,EAAQ,CAAG,CAAA,CAAjB,EAGE,CAAA,GAAW,AAAW,YAAX,CAAW,GAIxB,CAAA,CAAM,CAAA,EAAQ,CAAG,CAAA,CAAjB,EAGE,AAAS,MAAT,GACF,CAAA,CAAM,CAAA,EAAQ,CAAG,CADnB,EAII,CAAM,CAAA,GAAc,EAAI,CAAM,CAAA,GAAU,IAAM,CAAM,CAAA,GAAc,EACpE,CAAA,CAAM,CAAA,EAAQ,CAAG,CAAA,CADnB,EAII,GACF,CAAA,CAAM,CAAA,EAAW,CAAG,CAAA,CADtB,EAIA,IAAI,EAAS,CAAA,EAAG,EAAO,CAAC,EAAE,EAAK;AAAa,CAAC,CA2D7C,MAzDI,AAAgB,UAAhB,OAAO,EACT,GAAU,CAAC,MAAM,EAAE,EAAK;AAAI,CAAC,CAE7B,GAAU,CAAM,CAAA,EAAa,CAG3B,EACF,GAAU,CAAC;AAAA,SAAgC,EAAE,EAAQ;AAAI,CAAC,CACjD,CAAM,CAAA,EAAa,EAAI,CAAC,CAAM,CAAA,EAAQ,CAC/C,GAAU,6BAEV,GAAU,wBAGR,GACF,CAAA,GAAU,CADZ,EAII,GAAS,WAAW,CAAC,cAAc,EACrC,GAAS,WAAW,CAAC,OAAO,CAAC,CAAE,QAAA,EAAS,QAAS,EAAQ,OAAA,CAAO,GAI9D,AAAC,GAAQ,AAAe,IAAf,EAQF,sDAAA,QAAA,CAAc,IACvB,EAAO,IAAkB,EAAK,UAAU,CAAE,wCAE1C,EAAO,IAAI,GACX,EAAO,KAAK,CAAC,CAAA,EAAG,EAAO,gBAAgB,EAAE,EAAc;AAAA;AAAQ,CAAC,CAAE,UAClE,EAAO,KAAK,CAAC,GACb,EAAO,MAAM,GACb,EAAQ,UAAU,CAAC,GACnB,EAAQ,aAAa,GACjB,AAAC,GACH,CAAA,CAAM,CAAA,EAAQ,CAAG,CAAA,CADnB,GAGS,sDAAA,UAAA,CAAgB,GACrB,AAAuB,YAAvB,OAAO,EAAK,MAAM,CACpB,GAAc,CAAE,KAAM,EAAK,MAAM,GAAI,OAAA,EAAQ,QAAA,EAAS,OAAA,EAAQ,cAAA,EAAe,OAAA,EAAQ,eAAA,CAAe,GAEpG,GAAU,CAAE,KAAA,EAAM,OAAA,EAAQ,QAAA,EAAS,OAAA,EAAQ,cAAA,EAAe,OAAA,EAAQ,eAAA,CAAe,GAE1E,sDAAA,QAAA,CAAc,GACvB,GAAY,CAAE,KAAA,EAAM,OAAA,EAAQ,QAAA,EAAS,OAAA,EAAQ,cAAA,EAAe,OAAA,EAAQ,eAAA,CAAe,GAC1E,sDAAA,UAAA,CAAgB,GACzB,GAAc,CAAE,KAAA,EAAM,OAAA,EAAQ,QAAA,EAAS,OAAA,EAAQ,cAAA,EAAe,OAAA,EAAQ,eAAA,CAAe,GAErF,EAAO,CAAA,IA9BH,AAAkB,IAAlB,EACF,EAAO,KAAK,CAAC,CAAA,EAAG,EAAO;AAAA;AAAyB,CAAC,CAAE,WAEnD,EAAO,AAAkB,OAAlB,EAAwB,wCAC/B,EAAO,KAAK,CAAC,CAAA,EAAG,EAAO;AAAI,CAAC,CAAE,WAEhC,EAAQ,aAAa,IA2BhB,CAAA,CACT,EAhLkC,EAAQ,GACpC,CAAM,CAAA,EAAa,GAEnB,CAAM,CAAA,EAAQ,CAAC,MAAM,CAAC,CAAM,CAAA,EAAa,CAAE,EAE/C,CACF,EApIU,EAAQ,GAChB,CAAM,CAAA,EAAW,CAAG,EAEhB,CAAM,CAAA,EAAa,CAAG,MACxB,CAAM,CAAA,EAAQ,CAAC,MAAM,CAAC,EAAG,CAAM,CAAA,EAAa,EAC5C,CAAM,CAAA,EAAa,EAAI,CAAM,CAAA,EAAa,CAC1C,CAAM,CAAA,EAAa,CAAG,GAE1B,CA+HA,SAAS,GAAyB,CAAM,EACtC,MAAO,AAAW,QAAX,GAAoB,AAAW,SAAX,GAAqB,AAAW,YAAX,GAAwB,AAAW,UAAX,GAAsB,AAAW,YAAX,CAChG,CA+aA,SAAS,GAAa,CAAA,SAAE,CAAQ,CAAA,KAAE,CAAI,CAAA,OAAE,CAAM,CAAA,QAAE,CAAO,CAAA,OAAE,CAAM,CAAA,cAAE,CAAa,CAAA,OAAE,CAAM,CAAA,eAAE,CAAc,CAAE,EAGtG,GAFA,EAAO,AAAkB,IAAlB,GAAuB,AAAqB,IAArB,CAAM,CAAA,EAAU,CAAQ,mCAElD,AAA6B,OAA7B,CAAM,CAAA,GAAkB,CAAW,CAErC,IAAM,EAAO,AAh3DX,EAi3DA,EACA,EACA,AAAC,IACK,GACF,sDAAA,OAAA,CAAa,EAAM,GACnB,sDAAA,OAAA,CAAa,EAAU,IAEvB,EAAQ,aAAa,EAEzB,GASF,SAAS,EAAY,CAAK,EACxB,EAAQ,UAAU,CAAC,EACrB,CARA,EAAK,EAAE,CAAC,OAAQ,GAChB,EAAK,IAAI,CAAC,MAAO,KACf,EAAK,cAAc,CAAC,OAAQ,GAC5B,sDAAA,OAAA,CAAa,EACf,GAMA,MACF,CAEA,IAAI,EAAW,CAAA,EAET,EAAS,IAAI,GAAY,CAAE,OAAA,EAAQ,QAAA,EAAS,cAAA,EAAe,OAAA,EAAQ,eAAA,EAAgB,OAAA,CAAO,GAE1F,EAAS,SAAU,CAAK,EAC5B,IAAI,EAIJ,GAAI,CACE,CAAC,EAAO,KAAK,CAAC,IAAU,IAAI,CAAC,KAAK,EACpC,IAAI,CAAC,KAAK,EAEd,CAAE,MAAO,EAAK,CACZ,sDAAA,OAAA,CAAa,IAAI,CAAE,EACrB,CACF,EACM,EAAU,YACV,GAIA,EAAK,MAAM,EACb,EAAK,MAAM,EAEf,EACM,EAAU,WACd,GAAI,EACF,OAEF,IAAM,EAAM,IAAZ,EACA,eAAe,IAAM,EAAW,GAClC,EACM,EAAa,SAAU,CAAG,EAC9B,IAAI,GAkBJ,GAdA,EAAW,CAAA,EAEX,EAAO,EAAO,SAAS,EAAK,CAAM,CAAA,EAAU,EAAI,CAAM,CAAA,EAAU,EAAI,GAEpE,EACG,GAAG,CAAC,QAAS,GACb,GAAG,CAAC,QAAS,GAEhB,EACG,cAAc,CAAC,OAAQ,GACvB,cAAc,CAAC,MAAO,GACtB,cAAc,CAAC,QAAS,GACxB,cAAc,CAAC,QAAS,GAEvB,CAAC,EACH,GAAI,CACF,EAAO,GAAG,EACZ,CAAE,MAAO,EAAI,CACX,EAAM,CACR,CAGF,EAAO,OAAO,CAAC,GAEX,GAAQ,CAAA,AAAa,iBAAb,EAAI,IAAI,EAAuB,AAAgB,UAAhB,EAAI,OAAO,AAAK,EACzD,sDAAA,OAAA,CAAa,EAAM,GAEnB,sDAAA,OAAA,CAAa,GAEjB,EAEA,EACG,EAAE,CAAC,OAAQ,GACX,EAAE,CAAC,MAAO,GACV,EAAE,CAAC,QAAS,GACZ,EAAE,CAAC,QAAS,GAEX,EAAK,MAAM,EACb,EAAK,MAAM,GAGb,EACG,EAAE,CAAC,QAAS,GACZ,EAAE,CAAC,QAAS,EACjB,CAEA,eAAe,GAAW,CAAA,SAAE,CAAQ,CAAA,KAAE,CAAI,CAAA,OAAE,CAAM,CAAA,QAAE,CAAO,CAAA,OAAE,CAAM,CAAA,cAAE,CAAa,CAAA,OAAE,CAAM,CAAA,eAAE,CAAc,CAAE,EAC1G,EAAO,IAAkB,EAAK,IAAI,CAAE,sCAEpC,IAAM,EAAO,AAA6B,OAA7B,CAAM,CAAA,GAAkB,CACrC,GAAI,CACF,GAAI,AAAiB,MAAjB,GAAyB,IAAkB,EAAK,IAAI,CACtD,MAAM,IADR,EAIA,IAAM,EAAS,OAAO,IAAI,CAAC,MAAM,EAAK,WAAW,IAE7C,GACF,EAAS,IAAI,GACb,EAAS,KAAK,CAAC,GACf,EAAS,MAAM,KAEf,EAAO,IAAI,GACX,EAAO,KAAK,CAAC,CAAA,EAAG,EAAO,gBAAgB,EAAE,EAAc;AAAA;AAAQ,CAAC,CAAE,UAClE,EAAO,KAAK,CAAC,GACb,EAAO,MAAM,IAGf,EAAQ,UAAU,CAAC,GACnB,EAAQ,aAAa,GAEjB,AAAC,GACH,CAAA,CAAM,CAAA,EAAQ,CAAG,CAAA,CADnB,EAIA,GAAO,EACT,CAAE,MAAO,EAAK,CACZ,sDAAA,OAAA,CAAa,EAAO,EAAW,EAAQ,EACzC,CACF,CAEA,eAAe,GAAe,CAAA,SAAE,CAAQ,CAAA,KAAE,CAAI,CAAA,OAAE,CAAM,CAAA,QAAE,CAAO,CAAA,OAAE,CAAM,CAAA,cAAE,CAAa,CAAA,OAAE,CAAM,CAAA,eAAE,CAAc,CAAE,EAC9G,EAAO,AAAkB,IAAlB,GAAuB,AAAqB,IAArB,CAAM,CAAA,EAAU,CAAQ,qCAEtD,IAAI,EAAW,KACf,SAAS,IACP,GAAI,EAAU,CACZ,IAAM,EAAK,EACX,EAAW,KACX,GACF,CACF,CAEA,IAAM,EAAe,IAAM,IAAI,QAAQ,CAAC,EAAS,KAC/C,EAAO,AAAa,OAAb,GAEH,CAAM,CAAA,EAAQ,CAChB,EAAO,CAAM,CAAA,EAAQ,EAErB,EAAW,CAEf,GAEA,GAAI,AAA6B,OAA7B,CAAM,CAAA,GAAkB,CAAW,CACrC,EACG,EAAE,CAAC,QAAS,GACZ,EAAE,CAAC,QAAS,GAEf,GAAI,CAEF,UAAW,IAAM,KAAS,EAAM,CAC9B,GAAI,CAAM,CAAA,EAAQ,CAChB,MAAM,CAAM,CAAA,EAAQ,CAGtB,IAAM,EAAM,EAAS,KAAK,CAAC,GAC3B,EAAQ,UAAU,CAAC,GACf,AAAC,GACH,MAAM,GAEV,CACF,CAAE,MAAO,EAAK,CACZ,EAAS,OAAO,CAAC,EACnB,QAAU,CACR,EAAQ,aAAa,GACrB,EAAS,GAAG,GACZ,EACG,GAAG,CAAC,QAAS,GACb,GAAG,CAAC,QAAS,EAClB,CAEA,MACF,CAEA,EACG,EAAE,CAAC,QAAS,GACZ,EAAE,CAAC,QAAS,GAEf,IAAM,EAAS,IAAI,GAAY,CAAE,OAAA,EAAQ,QAAA,EAAS,cAAA,EAAe,OAAA,EAAQ,eAAA,EAAgB,OAAA,CAAO,GAChG,GAAI,CAEF,UAAW,IAAM,KAAS,EAAM,CAC9B,GAAI,CAAM,CAAA,EAAQ,CAChB,MAAM,CAAM,CAAA,EAAQ,AAGlB,CAAC,EAAO,KAAK,CAAC,IAChB,MAAM,GAEV,CAEA,EAAO,GAAG,EACZ,CAAE,MAAO,EAAK,CACZ,EAAO,OAAO,CAAC,EACjB,QAAU,CACR,EACG,GAAG,CAAC,QAAS,GACb,GAAG,CAAC,QAAS,EAClB,CACF,CAEA,MAAM,GACJ,YAAa,CAAA,OAAE,CAAM,CAAA,QAAE,CAAO,CAAA,cAAE,CAAa,CAAA,OAAE,CAAM,CAAA,eAAE,CAAc,CAAA,OAAE,CAAM,CAAE,CAAE,CAC/E,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,aAAa,CAAG,EACrB,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,YAAY,CAAG,EACpB,IAAI,CAAC,cAAc,CAAG,EACtB,IAAI,CAAC,MAAM,CAAG,EAEd,CAAM,CAAA,EAAU,CAAG,CAAA,CACrB,CAEA,MAAO,CAAK,CAAE,CACZ,GAAM,CAAA,OAAE,CAAM,CAAA,QAAE,CAAO,CAAA,cAAE,CAAa,CAAA,OAAE,CAAM,CAAA,aAAE,CAAY,CAAA,eAAE,CAAc,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,CAE7F,GAAI,CAAM,CAAA,EAAQ,CAChB,MAAM,CAAM,CAAA,EAAQ,CAGtB,GAAI,EAAO,SAAS,CAClB,MAAO,CAAA,EAGT,IAAM,EAAM,OAAO,UAAU,CAAC,GAC9B,GAAI,CAAC,EACH,MAAO,CAAA,EAIT,GAAI,AAAkB,OAAlB,GAA0B,EAAe,EAAM,EAAe,CAChE,GAAI,CAAM,CAAA,GAAsB,CAC9B,MAAM,IADR,EAIA,QAAQ,WAAW,CAAC,IAApB,EACF,CAEA,EAAO,IAAI,GAEU,IAAjB,IACE,AAAC,GACH,CAAA,CAAM,CAAA,EAAQ,CAAG,CAAA,CADnB,EAII,AAAkB,OAAlB,EACF,EAAO,KAAK,CAAC,CAAA,EAAG,EAAO;AAA8B,CAAC,CAAE,UAExD,EAAO,KAAK,CAAC,CAAA,EAAG,EAAO,gBAAgB,EAAE,EAAc;AAAA;AAAQ,CAAC,CAAE,WAIlE,AAAkB,OAAlB,GACF,EAAO,KAAK,CAAC,CAAC;AAAI,EAAE,EAAI,QAAQ,CAAC,IAAI;AAAI,CAAC,CAAE,UAG9C,IAAI,CAAC,YAAY,EAAI,EAErB,IAAM,EAAM,EAAO,KAAK,CAAC,GAezB,OAbA,EAAO,MAAM,GAEb,EAAQ,UAAU,CAAC,GAEf,CAAC,GACC,CAAM,CAAA,EAAS,CAAC,OAAO,EAAI,AA1mDb,IA0mDa,CAAM,CAAA,EAAS,CAAC,WAAW,EAEpD,CAAM,CAAA,EAAS,CAAC,OAAO,CAAC,OAAO,EACjC,CAAM,CAAA,EAAS,CAAC,OAAO,CAAC,OAAO,GAK9B,CACT,CAEA,KAAO,CACL,GAAM,CAAA,OAAE,CAAM,CAAA,cAAE,CAAa,CAAA,OAAE,CAAM,CAAA,aAAE,CAAY,CAAA,eAAE,CAAc,CAAA,OAAE,CAAM,CAAA,QAAE,CAAO,CAAE,CAAG,IAAI,CAK7F,GAJA,EAAQ,aAAa,GAErB,CAAM,CAAA,EAAU,CAAG,CAAA,EAEf,CAAM,CAAA,EAAQ,CAChB,MAAM,CAAM,CAAA,EAAQ,CAGtB,IAAI,EAAO,SAAS,EAmBpB,GAfI,AAAiB,IAAjB,EACE,EAMF,EAAO,KAAK,CAAC,CAAA,EAAG,EAAO;AAAA;AAAyB,CAAC,CAAE,UAEnD,EAAO,KAAK,CAAC,CAAA,EAAG,EAAO;AAAI,CAAC,CAAE,UAEvB,AAAkB,OAAlB,GACT,EAAO,KAAK,CAAC,gBAAiB,UAG5B,AAAkB,OAAlB,GAA0B,IAAiB,EAC7C,GAAI,CAAM,CAAA,GAAsB,CAC9B,MAAM,IADR,OAGE,QAAQ,WAAW,CAAC,IAApB,EAIA,CAAA,CAAM,CAAA,EAAS,CAAC,OAAO,EAAI,AA1pDX,IA0pDW,CAAM,CAAA,EAAS,CAAC,WAAW,EAEpD,CAAM,CAAA,EAAS,CAAC,OAAO,CAAC,OAAO,EACjC,CAAM,CAAA,EAAS,CAAC,OAAO,CAAC,OAAO,GAInC,GAAO,GACT,CAEA,QAAS,CAAG,CAAE,CACZ,GAAM,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAE,CAAG,IAAI,AAE/B,CAAA,CAAM,CAAA,EAAU,CAAG,CAAA,EAEf,IACF,EAAO,CAAM,CAAA,EAAU,EAAI,EAAG,6CAC9B,sDAAA,OAAA,CAAa,EAAQ,GAEzB,CACF,CAEA,SAAS,GAAc,CAAM,CAAE,CAAO,CAAE,CAAG,EACzC,GAAI,CACF,EAAQ,OAAO,CAAC,GAChB,EAAO,EAAQ,OAAO,CACxB,CAAE,MAAO,EAAK,CACZ,EAAO,IAAI,CAAC,QAAS,EACvB,CACF,CAEA,EA1mEA,cAAqB,EAMnB,YAAa,CAAG,CAAE,CAAA,aAChB,CAAY,CAAA,cACZ,CAAa,CAAA,eACb,CAAc,CAAA,cACd,CAAa,CAAA,eACb,CAAc,CAAA,eACd,CAAc,CAAA,YACd,CAAW,CAAA,YACX,CAAW,CAAA,UACX,CAAS,CAAA,iBACT,CAAgB,CAAA,oBAChB,CAAmB,CAAA,oBACnB,CAAmB,CAAA,0BACnB,CAAyB,CAAA,WACzB,CAAU,CAAA,WACV,CAAU,CAAA,IACV,CAAG,CAAA,oBACH,CAAmB,CAAA,kBACnB,CAAiB,CAAA,gBACjB,CAAe,CAAA,QACf,CAAO,CAAA,qBACP,CAAoB,CAAA,aACpB,CAAY,CAAA,gBACZ,CAAe,CAAA,iBACf,CAAgB,CAAA,+BAChB,CAA8B,CAAA,QAE9B,CAAO,CAAA,qBACP,CAAoB,CACrB,CAAG,CAAC,CAAC,CAAE,CAGN,GAFA,KAAK,GAED,AAAc,KAAA,IAAd,EACF,MAAM,IAAA,EAAyB,mDAGjC,GAAI,AAAkB,KAAA,IAAlB,EACF,MAAM,IAAA,EAAyB,uEAGjC,GAAI,AAAmB,KAAA,IAAnB,EACF,MAAM,IAAA,EAAyB,wEAGjC,GAAI,AAAgB,KAAA,IAAhB,EACF,MAAM,IAAA,EAAyB,yDAGjC,GAAI,AAAwB,KAAA,IAAxB,EACF,MAAM,IAAA,EAAyB,oEAGjC,GAAI,AAAiB,MAAjB,GAAyB,CAAC,OAAO,QAAQ,CAAC,GAC5C,MAAM,IAAA,EAAyB,yBAGjC,GAAI,AAAc,MAAd,GAAsB,AAAsB,UAAtB,OAAO,EAC/B,MAAM,IAAA,EAAyB,sBAGjC,GAAI,AAAkB,MAAlB,GAA2B,CAAA,CAAC,OAAO,QAAQ,CAAC,IAAmB,EAAiB,CAAA,EAClF,MAAM,IAAA,EAAyB,0BAGjC,GAAI,AAAoB,MAApB,GAA6B,CAAA,CAAC,OAAO,QAAQ,CAAC,IAAqB,GAAoB,CAAA,EACzF,MAAM,IAAA,EAAyB,4BAGjC,GAAI,AAAuB,MAAvB,GAAgC,CAAA,CAAC,OAAO,QAAQ,CAAC,IAAwB,GAAuB,CAAA,EAClG,MAAM,IAAA,EAAyB,+BAGjC,GAAI,AAA6B,MAA7B,GAAqC,CAAC,OAAO,QAAQ,CAAC,GACxD,MAAM,IAAA,EAAyB,qCAGjC,GAAI,AAAkB,MAAlB,GAA2B,CAAA,CAAC,OAAO,SAAS,CAAC,IAAmB,EAAiB,CAAA,EACnF,MAAM,IAAA,EAAyB,qDAGjC,GAAI,AAAe,MAAf,GAAwB,CAAA,CAAC,OAAO,SAAS,CAAC,IAAgB,EAAc,CAAA,EAC1E,MAAM,IAAA,EAAyB,kDAGjC,GAAI,AAAW,MAAX,GAAmB,AAAmB,YAAnB,OAAO,GAA0B,AAAmB,UAAnB,OAAO,EAC7D,MAAM,IAAA,EAAyB,2CAGjC,GAAI,AAAmB,MAAnB,GAA4B,CAAA,CAAC,OAAO,SAAS,CAAC,IAAoB,EAAkB,CAAA,EACtF,MAAM,IAAA,EAAyB,6CAGjC,GAAI,AAAwB,MAAxB,GAAiC,CAAA,CAAC,OAAO,SAAS,CAAC,IAAyB,EAAuB,CAAA,EACrG,MAAM,IAAA,EAAyB,kDAGjC,GAAI,AAAgB,MAAhB,GAAyB,CAAA,AAAwB,UAAxB,OAAO,GAA6B,AAA2B,IAA3B,EAAS,EAAkB,EAC1F,MAAM,IAAA,EAAyB,gDAGjC,GAAI,AAAmB,MAAnB,GAA4B,CAAA,CAAC,OAAO,SAAS,CAAC,IAAoB,EAAkB,EAAA,EACtF,MAAM,IAAA,EAAyB,6CAGjC,GACE,AAAkC,MAAlC,GACC,CAAA,CAAC,OAAO,SAAS,CAAC,IAAmC,EAAiC,EAAA,EAEvF,MAAM,IAAA,EAAyB,4DAIjC,GAAI,AAAW,MAAX,GAAmB,AAAmB,WAAnB,OAAO,EAC5B,MAAM,IAAA,EAAyB,yCAGjC,GAAI,AAAwB,MAAxB,GAAiC,CAAA,AAAgC,UAAhC,OAAO,GAAqC,EAAuB,CAAA,EACtG,MAAM,IAAA,EAAyB,mEAG7B,AAAmB,CAAA,YAAnB,OAAO,GACT,CAAA,EAAU,EAAe,CACvB,GAAG,CAAG,CACN,kBAAA,EACA,QAAA,EACA,WAAA,EACA,QAAS,EACT,GAAI,sDAAA,uBAAA,EAAgC,EAAmB,CAAE,iBAAA,EAAkB,+BAAA,CAA+B,EAAI,KAAA,CAAS,CACvH,GAAG,CAAO,AACZ,EAAA,EAGF,IAAI,CAAA,GAAe,CAAG,GAAgB,EAAa,MAAM,EAAI,MAAM,OAAO,CAAC,EAAa,MAAM,EAC1F,EAAa,MAAM,CACnB,CAAC,EAA0B,CAAE,gBAAA,CAAgB,GAAG,CACpD,IAAI,CAAA,EAAM,CAAG,EAAA,WAAA,CAAiB,GAC9B,IAAI,CAAA,GAAY,CAAG,EACnB,IAAI,CAAA,EAAS,CAAG,KAChB,IAAI,CAAA,EAAa,CAAG,AAAc,MAAd,EAAqB,EAAa,EACtD,IAAI,CAAA,GAAiB,CAAG,GAAiB,EACzC,IAAI,CAAA,EAA0B,CAAG,AAAoB,MAApB,EAA2B,IAAM,EAClE,IAAI,CAAA,GAAsB,CAAG,AAAuB,MAAvB,EAA8B,IAAQ,EACnE,IAAI,CAAA,GAA4B,CAAG,AAA6B,MAA7B,EAAoC,IAAM,EAC7E,IAAI,CAAA,GAAwB,CAAG,IAAI,CAAA,EAA0B,CAC7D,IAAI,CAAA,EAAa,CAAG,KACpB,IAAI,CAAA,GAAe,CAAG,AAAgB,MAAhB,EAAuB,EAAe,KAC5D,IAAI,CAAA,EAAW,CAAG,EAClB,IAAI,CAAA,EAAY,CAAG,EACnB,IAAI,CAAA,EAAa,CAAG,CAAC,MAAM,EAAE,IAAI,CAAA,EAAM,CAAC,QAAQ,CAAA,EAAG,IAAI,CAAA,EAAM,CAAC,IAAI,CAAG,CAAC,CAAC,EAAE,IAAI,CAAA,EAAM,CAAC,IAAI,CAAA,CAAE,CAAG,GAAG;AAAI,CAAC,CACrG,IAAI,CAAA,GAAc,CAAG,AAAe,MAAf,EAAsB,EAAc,IACzD,IAAI,CAAA,GAAiB,CAAG,AAAkB,MAAlB,EAAyB,EAAiB,IAClE,IAAI,CAAA,GAAsB,CAAG,AAAuB,MAAvB,GAAqC,EAClE,IAAI,CAAA,GAAkB,CAAG,EACzB,IAAI,CAAA,GAAc,CAAG,EACrB,IAAI,CAAC,GAAe,CAAG,KACvB,IAAI,CAAA,GAAkB,CAAG,EAAkB,GAAK,EAAkB,GAClE,IAAI,CAAA,GAAkB,CAAG,KAGzB,IAAI,CAAA,GAAe,CAAG,KACtB,IAAI,CAAA,GAAoB,CAAG,AAAC,EAExB,CAEE,YAAa,EACb,qBAAsB,AAAwB,MAAxB,EAA+B,EAAuB,GAC9E,EALA,KAMJ,IAAI,CAAA,GAAO,CAAG,CAAA,EAAG,IAAI,CAAA,EAAM,CAAC,QAAQ,CAAA,EAAG,IAAI,CAAA,EAAM,CAAC,IAAI,CAAG,CAAC,CAAC,EAAE,IAAI,CAAA,EAAM,CAAC,IAAI,CAAA,CAAE,CAAG,GAAA,CAAI,CAWrF,IAAI,CAAA,EAAQ,CAAG,EAAE,CACjB,IAAI,CAAA,EAAa,CAAG,EACpB,IAAI,CAAA,EAAa,CAAG,CACtB,CAEA,IAAI,YAAc,CAChB,OAAO,IAAI,CAAA,EAAa,AAC1B,CAEA,IAAI,WAAY,CAAK,CAAE,CACrB,IAAI,CAAA,EAAa,CAAG,EACpB,GAAO,IAAI,CAAE,CAAA,EACf,CAEA,GAAI,CAAA,EAAU,EAAI,CAChB,OAAO,IAAI,CAAA,EAAQ,CAAC,MAAM,CAAG,IAAI,CAAA,EAAa,AAChD,CAEA,GAAI,CAAA,EAAU,EAAI,CAChB,OAAO,IAAI,CAAA,EAAa,CAAG,IAAI,CAAA,EAAa,AAC9C,CAEA,GAAI,CAAA,EAAO,EAAI,CACb,OAAO,IAAI,CAAA,EAAQ,CAAC,MAAM,CAAG,IAAI,CAAA,EAAa,AAChD,CAEA,GAAI,CAAA,EAAY,EAAI,CAClB,MAAO,CAAC,CAAC,IAAI,CAAA,EAAS,EAAI,CAAC,IAAI,CAAA,EAAa,EAAI,CAAC,IAAI,CAAA,EAAS,CAAC,SAAS,AAC1E,CAEA,GAAI,CAAA,EAAO,EAAI,CACb,IAAM,EAAS,IAAI,CAAA,EAAS,CAC5B,OACE,GAAY,CAAA,CAAM,CAAA,EAAQ,EAAI,CAAM,CAAA,EAAU,EAAI,CAAM,CAAA,EAAU,AAAV,GACvD,IAAI,CAAA,EAAO,EAAK,CAAA,IAAI,CAAA,EAAa,EAAI,CAAA,GACtC,IAAI,CAAA,EAAU,CAAG,CAErB,CAGA,CAAA,EAAU,CAAE,CAAE,CAAE,CACd,GAAQ,IAAI,EACZ,IAAI,CAAC,IAAI,CAAC,UAAW,EACvB,CAEA,CAAA,GAAW,CAAE,CAAI,CAAE,CAAO,CAAE,CAC1B,IAAM,EAAS,EAAK,MAAM,EAAI,IAAI,CAAA,EAAM,CAAC,MAAM,CAEzC,EAAU,AAA2B,OAA3B,IAAI,CAAA,GAAkB,CAClC,CAAO,CAAA,GAAoB,CAAC,EAAQ,EAAM,GAC1C,CAAO,CAAA,GAAoB,CAAC,EAAQ,EAAM,GAiB9C,OAfA,IAAI,CAAA,EAAQ,CAAC,IAAI,CAAC,GACd,IAAI,CAAA,EAAW,GAER,AAAiC,MAAjC,qDAAA,UAAA,CAAgB,EAAQ,IAAI,GAAa,sDAAA,UAAA,CAAgB,EAAQ,IAAI,GAE9E,IAAI,CAAA,EAAW,CAAG,EAClB,QAAQ,QAAQ,CAAC,GAAQ,IAAI,GAE7B,GAAO,IAAI,CAAE,CAAA,IAGX,IAAI,CAAA,EAAW,EAAI,AAAqB,IAArB,IAAI,CAAA,EAAY,EAAU,IAAI,CAAA,EAAO,EAC1D,CAAA,IAAI,CAAA,EAAY,CAAG,CAAA,EAGd,IAAI,CAAA,EAAY,CAAG,CAC5B,CAEA,MAAM,CAAA,GAAQ,EAAI,CAGhB,OAAO,IAAI,QAAQ,AAAC,IACb,IAAI,CAAA,EAAO,CAGd,IAAI,CAAC,GAAe,CAAG,EAFvB,EAAQ,KAIZ,EACF,CAEA,MAAM,CAAA,GAAU,CAAE,CAAG,CAAE,CACrB,OAAO,IAAI,QAAQ,AAAC,IAClB,IAAM,EAAW,IAAI,CAAA,EAAQ,CAAC,MAAM,CAAC,IAAI,CAAA,EAAa,EACtD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAEnC,GAAa,IAAI,CADD,CAAQ,CAAC,EAAE,CACC,GAG9B,IAAM,EAAW,KACX,IAAI,CAAC,GAAe,GAEtB,IAAI,CAAC,GAAe,GACpB,IAAI,CAAC,GAAe,CAAG,MAEzB,GACF,CAE2B,OAAvB,IAAI,CAAA,GAAe,GACrB,sDAAA,OAAA,CAAa,IAAI,CAAA,GAAe,CAAE,GAClC,IAAI,CAAA,GAAe,CAAG,KACtB,IAAI,CAAA,GAAoB,CAAG,MAGxB,IAAI,CAAA,EAAS,CAGhB,sDAAA,OAAA,CAAa,IAAI,CAAA,EAAS,CAAC,EAAE,CAAC,QAAS,GAAW,GAFlD,eAAe,GAKjB,GAAO,IAAI,CACb,EACF,CACF,S,K,O","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js"],"sourcesContent":["import $16nGk$pythonversioncheck7ed1514ejs10 from \"./python-version-check.7ed1514e.js\";\nimport $16nGk$pythonversioncheck715a24bajs1 from \"./python-version-check.715a24ba.js\";\nimport $16nGk$pythonversioncheck2f514258js from \"./python-version-check.2f514258.js\";\nimport $16nGk$pythonversioncheck8185b27fjs from \"./python-version-check.8185b27f.js\";\nimport $16nGk$pythonversioncheckdba5a2d4js11 from \"./python-version-check.dba5a2d4.js\";\nimport $16nGk$pythonversioncheck091f3542js from \"./python-version-check.091f3542.js\";\nimport $16nGk$pythonversioncheckebf2a848js48 from \"./python-version-check.ebf2a848.js\";\nimport $16nGk$pythonversioncheck67e8c7c6js1 from \"./python-version-check.67e8c7c6.js\";\nimport $16nGk$pythonversioncheckdb32945bjs from \"./python-version-check.db32945b.js\";\nimport $16nGk$pythonversionchecke57c179ejs from \"./python-version-check.e57c179e.js\";\nimport $16nGk$pythonversioncheckf30ce740js from \"./python-version-check.f30ce740.js\";\nimport * as $16nGk$assert from \"assert\";\nimport {isIP as $16nGk$isIP} from \"net\";\nimport {maxHeaderSize as $16nGk$maxHeaderSize} from \"http\";\nimport {pipeline as $16nGk$pipeline} from \"stream\";\n\nvar $5c97a5b8760057fe$exports = {};\n// @ts-check\n'use strict';\n\n\n\n\nvar $5c97a5b8760057fe$require$pipeline = $16nGk$pipeline;\n\n\n\n\n\nvar $5c97a5b8760057fe$require$RequestContentLengthMismatchError = $16nGk$pythonversioncheckdba5a2d4js8.RequestContentLengthMismatchError;\nvar $5c97a5b8760057fe$require$ResponseContentLengthMismatchError = $16nGk$pythonversioncheckdba5a2d4js9.ResponseContentLengthMismatchError;\nvar $5c97a5b8760057fe$require$InvalidArgumentError = $16nGk$pythonversioncheckdba5a2d4js6.InvalidArgumentError;\nvar $5c97a5b8760057fe$require$RequestAbortedError = $16nGk$pythonversioncheckdba5a2d4js7.RequestAbortedError;\nvar $5c97a5b8760057fe$require$HeadersTimeoutError = $16nGk$pythonversioncheckdba5a2d4js3.HeadersTimeoutError;\nvar $5c97a5b8760057fe$require$HeadersOverflowError = $16nGk$pythonversioncheckdba5a2d4js2.HeadersOverflowError;\nvar $5c97a5b8760057fe$require$SocketError = $16nGk$pythonversioncheckdba5a2d4js11.SocketError;\nvar $5c97a5b8760057fe$require$InformationalError = $16nGk$pythonversioncheckdba5a2d4js5.InformationalError;\nvar $5c97a5b8760057fe$require$BodyTimeoutError = $16nGk$pythonversioncheckdba5a2d4js.BodyTimeoutError;\nvar $5c97a5b8760057fe$require$HTTPParserError = $16nGk$pythonversioncheckdba5a2d4js4.HTTPParserError;\nvar $5c97a5b8760057fe$require$ResponseExceededMaxSizeError = $16nGk$pythonversioncheckdba5a2d4js10.ResponseExceededMaxSizeError;\nvar $5c97a5b8760057fe$require$ClientDestroyedError = $16nGk$pythonversioncheckdba5a2d4js1.ClientDestroyedError;\n\n\nvar $5c97a5b8760057fe$require$kUrl = $16nGk$pythonversioncheckebf2a848js47.kUrl;\nvar $5c97a5b8760057fe$require$kReset = $16nGk$pythonversioncheckebf2a848js39.kReset;\nvar $5c97a5b8760057fe$require$kServerName = $16nGk$pythonversioncheckebf2a848js43.kServerName;\nvar $5c97a5b8760057fe$require$kClient = $16nGk$pythonversioncheckebf2a848js3.kClient;\nvar $5c97a5b8760057fe$require$kBusy = $16nGk$pythonversioncheckebf2a848js2.kBusy;\nvar $5c97a5b8760057fe$require$kParser = $16nGk$pythonversioncheckebf2a848js34.kParser;\nvar $5c97a5b8760057fe$require$kConnect = $16nGk$pythonversioncheckebf2a848js5.kConnect;\nvar $5c97a5b8760057fe$require$kBlocking = $16nGk$pythonversioncheckebf2a848js.kBlocking;\nvar $5c97a5b8760057fe$require$kResuming = $16nGk$pythonversioncheckebf2a848js40.kResuming;\nvar $5c97a5b8760057fe$require$kRunning = $16nGk$pythonversioncheckebf2a848js41.kRunning;\nvar $5c97a5b8760057fe$require$kPending = $16nGk$pythonversioncheckebf2a848js35.kPending;\nvar $5c97a5b8760057fe$require$kSize = $16nGk$pythonversioncheckebf2a848js44.kSize;\nvar $5c97a5b8760057fe$require$kWriting = $16nGk$pythonversioncheckebf2a848js48.kWriting;\nvar $5c97a5b8760057fe$require$kQueue = $16nGk$pythonversioncheckebf2a848js38.kQueue;\nvar $5c97a5b8760057fe$require$kConnected = $16nGk$pythonversioncheckebf2a848js6.kConnected;\nvar $5c97a5b8760057fe$require$kConnecting = $16nGk$pythonversioncheckebf2a848js7.kConnecting;\nvar $5c97a5b8760057fe$require$kNeedDrain = $16nGk$pythonversioncheckebf2a848js32.kNeedDrain;\nvar $5c97a5b8760057fe$require$kNoRef = $16nGk$pythonversioncheckebf2a848js33.kNoRef;\nvar $5c97a5b8760057fe$require$kKeepAliveDefaultTimeout = $16nGk$pythonversioncheckebf2a848js23.kKeepAliveDefaultTimeout;\nvar $5c97a5b8760057fe$require$kHostHeader = $16nGk$pythonversioncheckebf2a848js15.kHostHeader;\nvar $5c97a5b8760057fe$require$kPendingIdx = $16nGk$pythonversioncheckebf2a848js36.kPendingIdx;\nvar $5c97a5b8760057fe$require$kRunningIdx = $16nGk$pythonversioncheckebf2a848js42.kRunningIdx;\nvar $5c97a5b8760057fe$require$kError = $16nGk$pythonversioncheckebf2a848js12.kError;\nvar $5c97a5b8760057fe$require$kPipelining = $16nGk$pythonversioncheckebf2a848js37.kPipelining;\nvar $5c97a5b8760057fe$require$kSocket = $16nGk$pythonversioncheckebf2a848js45.kSocket;\nvar $5c97a5b8760057fe$require$kKeepAliveTimeoutValue = $16nGk$pythonversioncheckebf2a848js26.kKeepAliveTimeoutValue;\nvar $5c97a5b8760057fe$require$kMaxHeadersSize = $16nGk$pythonversioncheckebf2a848js28.kMaxHeadersSize;\nvar $5c97a5b8760057fe$require$kKeepAliveMaxTimeout = $16nGk$pythonversioncheckebf2a848js24.kKeepAliveMaxTimeout;\nvar $5c97a5b8760057fe$require$kKeepAliveTimeoutThreshold = $16nGk$pythonversioncheckebf2a848js25.kKeepAliveTimeoutThreshold;\nvar $5c97a5b8760057fe$require$kHeadersTimeout = $16nGk$pythonversioncheckebf2a848js13.kHeadersTimeout;\nvar $5c97a5b8760057fe$require$kBodyTimeout = $16nGk$pythonversioncheckebf2a848js1.kBodyTimeout;\nvar $5c97a5b8760057fe$require$kStrictContentLength = $16nGk$pythonversioncheckebf2a848js46.kStrictContentLength;\nvar $5c97a5b8760057fe$require$kConnector = $16nGk$pythonversioncheckebf2a848js8.kConnector;\nvar $5c97a5b8760057fe$require$kMaxRedirections = $16nGk$pythonversioncheckebf2a848js29.kMaxRedirections;\nvar $5c97a5b8760057fe$require$kMaxRequests = $16nGk$pythonversioncheckebf2a848js30.kMaxRequests;\nvar $5c97a5b8760057fe$require$kCounter = $16nGk$pythonversioncheckebf2a848js9.kCounter;\nvar $5c97a5b8760057fe$require$kClose = $16nGk$pythonversioncheckebf2a848js4.kClose;\nvar $5c97a5b8760057fe$require$kDestroy = $16nGk$pythonversioncheckebf2a848js10.kDestroy;\nvar $5c97a5b8760057fe$require$kDispatch = $16nGk$pythonversioncheckebf2a848js11.kDispatch;\nvar $5c97a5b8760057fe$require$kInterceptors = $16nGk$pythonversioncheckebf2a848js22.kInterceptors;\nvar $5c97a5b8760057fe$require$kLocalAddress = $16nGk$pythonversioncheckebf2a848js27.kLocalAddress;\nvar $5c97a5b8760057fe$require$kMaxResponseSize = $16nGk$pythonversioncheckebf2a848js31.kMaxResponseSize;\nvar $5c97a5b8760057fe$require$kHTTPConnVersion = $16nGk$pythonversioncheckebf2a848js21.kHTTPConnVersion;\nvar $5c97a5b8760057fe$require$kHost = $16nGk$pythonversioncheckebf2a848js14.kHost;\nvar $5c97a5b8760057fe$require$kHTTP2Session = $16nGk$pythonversioncheckebf2a848js19.kHTTP2Session;\nvar $5c97a5b8760057fe$require$kHTTP2SessionState = $16nGk$pythonversioncheckebf2a848js20.kHTTP2SessionState;\nvar $5c97a5b8760057fe$require$kHTTP2BuildRequest = $16nGk$pythonversioncheckebf2a848js17.kHTTP2BuildRequest;\nvar $5c97a5b8760057fe$require$kHTTP2CopyHeaders = $16nGk$pythonversioncheckebf2a848js18.kHTTP2CopyHeaders;\nvar $5c97a5b8760057fe$require$kHTTP1BuildRequest = $16nGk$pythonversioncheckebf2a848js16.kHTTP1BuildRequest;\n/** @type {import('http2')} */ let $5c97a5b8760057fe$var$http2;\n\ntry {\n    $5c97a5b8760057fe$var$http2 = $5c97a5b8760057fe$import$7690c58d6bf1df8f;\n} catch  {\n    // @ts-ignore\n    $5c97a5b8760057fe$var$http2 = {\n        constants: {}\n    };\n}\nconst { constants: { HTTP2_HEADER_AUTHORITY: $5c97a5b8760057fe$var$HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD: $5c97a5b8760057fe$var$HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH: $5c97a5b8760057fe$var$HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME: $5c97a5b8760057fe$var$HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH: $5c97a5b8760057fe$var$HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT: $5c97a5b8760057fe$var$HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS: $5c97a5b8760057fe$var$HTTP2_HEADER_STATUS } } = $5c97a5b8760057fe$var$http2;\n// Experimental\nlet $5c97a5b8760057fe$var$h2ExperimentalWarned = false;\nconst $5c97a5b8760057fe$var$FastBuffer = Buffer[Symbol.species];\nconst $5c97a5b8760057fe$var$kClosedResolve = Symbol('kClosedResolve');\nconst $5c97a5b8760057fe$var$channels = {};\n\ntry {\n    const diagnosticsChannel = $5c97a5b8760057fe$import$b63e509c7dd4e53f;\n    $5c97a5b8760057fe$var$channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');\n    $5c97a5b8760057fe$var$channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');\n    $5c97a5b8760057fe$var$channels.connectError = diagnosticsChannel.channel('undici:client:connectError');\n    $5c97a5b8760057fe$var$channels.connected = diagnosticsChannel.channel('undici:client:connected');\n} catch  {\n    $5c97a5b8760057fe$var$channels.sendHeaders = {\n        hasSubscribers: false\n    };\n    $5c97a5b8760057fe$var$channels.beforeConnect = {\n        hasSubscribers: false\n    };\n    $5c97a5b8760057fe$var$channels.connectError = {\n        hasSubscribers: false\n    };\n    $5c97a5b8760057fe$var$channels.connected = {\n        hasSubscribers: false\n    };\n}\n/**\n * @type {import('../types/client').default}\n */ class $5c97a5b8760057fe$var$Client extends $16nGk$pythonversioncheck8185b27fjs {\n    /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */ constructor(url, { interceptors: interceptors, maxHeaderSize: maxHeaderSize, headersTimeout: headersTimeout, socketTimeout: socketTimeout, requestTimeout: requestTimeout, connectTimeout: connectTimeout, bodyTimeout: bodyTimeout, idleTimeout: idleTimeout, keepAlive: keepAlive, keepAliveTimeout: keepAliveTimeout, maxKeepAliveTimeout: maxKeepAliveTimeout, keepAliveMaxTimeout: keepAliveMaxTimeout, keepAliveTimeoutThreshold: keepAliveTimeoutThreshold, socketPath: socketPath, pipelining: pipelining, tls: tls, strictContentLength: strictContentLength, maxCachedSessions: maxCachedSessions, maxRedirections: maxRedirections, connect: connect, maxRequestsPerClient: maxRequestsPerClient, localAddress: localAddress, maxResponseSize: maxResponseSize, autoSelectFamily: autoSelectFamily, autoSelectFamilyAttemptTimeout: autoSelectFamilyAttemptTimeout, allowH2: // h2\n    allowH2, maxConcurrentStreams: maxConcurrentStreams } = {}){\n        super();\n        if (keepAlive !== undefined) throw new $5c97a5b8760057fe$require$InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n        if (socketTimeout !== undefined) throw new $5c97a5b8760057fe$require$InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n        if (requestTimeout !== undefined) throw new $5c97a5b8760057fe$require$InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n        if (idleTimeout !== undefined) throw new $5c97a5b8760057fe$require$InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n        if (maxKeepAliveTimeout !== undefined) throw new $5c97a5b8760057fe$require$InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('invalid maxHeaderSize');\n        if (socketPath != null && typeof socketPath !== 'string') throw new $5c97a5b8760057fe$require$InvalidArgumentError('invalid socketPath');\n        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('invalid connectTimeout');\n        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('invalid keepAliveTimeout');\n        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('invalid keepAliveMaxTimeout');\n        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('headersTimeout must be a positive integer or zero');\n        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n        if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') throw new $5c97a5b8760057fe$require$InvalidArgumentError('connect must be a function or an object');\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('maxRedirections must be a positive number');\n        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('maxRequestsPerClient must be a positive number');\n        if (localAddress != null && (typeof localAddress !== 'string' || $16nGk$isIP(localAddress) === 0)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('localAddress must be valid string IP address');\n        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('maxResponseSize must be a positive number');\n        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');\n        // h2\n        if (allowH2 != null && typeof allowH2 !== 'boolean') throw new $5c97a5b8760057fe$require$InvalidArgumentError('allowH2 must be a valid boolean value');\n        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) throw new $5c97a5b8760057fe$require$InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0');\n        if (typeof connect !== 'function') connect = $16nGk$pythonversioncheck091f3542js({\n            ...tls,\n            maxCachedSessions: maxCachedSessions,\n            allowH2: allowH2,\n            socketPath: socketPath,\n            timeout: connectTimeout,\n            ...$16nGk$pythonversioncheck7ed1514ejs8.nodeHasAutoSelectFamily && autoSelectFamily ? {\n                autoSelectFamily: autoSelectFamily,\n                autoSelectFamilyAttemptTimeout: autoSelectFamilyAttemptTimeout\n            } : undefined,\n            ...connect\n        });\n        this[$5c97a5b8760057fe$require$kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [\n            $16nGk$pythonversioncheckdb32945bjs({\n                maxRedirections: maxRedirections\n            })\n        ];\n        this[$5c97a5b8760057fe$require$kUrl] = $16nGk$pythonversioncheck7ed1514ejs10.parseOrigin(url);\n        this[$5c97a5b8760057fe$require$kConnector] = connect;\n        this[$5c97a5b8760057fe$require$kSocket] = null;\n        this[$5c97a5b8760057fe$require$kPipelining] = pipelining != null ? pipelining : 1;\n        this[$5c97a5b8760057fe$require$kMaxHeadersSize] = maxHeaderSize || $16nGk$maxHeaderSize;\n        this[$5c97a5b8760057fe$require$kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n        this[$5c97a5b8760057fe$require$kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n        this[$5c97a5b8760057fe$require$kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n        this[$5c97a5b8760057fe$require$kKeepAliveTimeoutValue] = this[$5c97a5b8760057fe$require$kKeepAliveDefaultTimeout];\n        this[$5c97a5b8760057fe$require$kServerName] = null;\n        this[$5c97a5b8760057fe$require$kLocalAddress] = localAddress != null ? localAddress : null;\n        this[$5c97a5b8760057fe$require$kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n        ;\n        this[$5c97a5b8760057fe$require$kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n        ;\n        this[$5c97a5b8760057fe$require$kHostHeader] = `host: ${this[$5c97a5b8760057fe$require$kUrl].hostname}${this[$5c97a5b8760057fe$require$kUrl].port ? `:${this[$5c97a5b8760057fe$require$kUrl].port}` : ''}\\r\\n`;\n        this[$5c97a5b8760057fe$require$kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n        this[$5c97a5b8760057fe$require$kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n        this[$5c97a5b8760057fe$require$kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n        this[$5c97a5b8760057fe$require$kMaxRedirections] = maxRedirections;\n        this[$5c97a5b8760057fe$require$kMaxRequests] = maxRequestsPerClient;\n        this[$5c97a5b8760057fe$var$kClosedResolve] = null;\n        this[$5c97a5b8760057fe$require$kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n        this[$5c97a5b8760057fe$require$kHTTPConnVersion] = 'h1';\n        // HTTP/2\n        this[$5c97a5b8760057fe$require$kHTTP2Session] = null;\n        this[$5c97a5b8760057fe$require$kHTTP2SessionState] = !allowH2 ? null : {\n            // streams: null, // Fixed queue of streams - For future support of `push`\n            openStreams: 0,\n            maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n        };\n        this[$5c97a5b8760057fe$require$kHost] = `${this[$5c97a5b8760057fe$require$kUrl].hostname}${this[$5c97a5b8760057fe$require$kUrl].port ? `:${this[$5c97a5b8760057fe$require$kUrl].port}` : ''}`;\n        // kQueue is built up of 3 sections separated by\n        // the kRunningIdx and kPendingIdx indices.\n        // |   complete   |   running   |   pending   |\n        //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n        // kRunningIdx points to the first running element.\n        // kPendingIdx points to the first pending element.\n        // This implements a fast queue with an amortized\n        // time of O(1).\n        this[$5c97a5b8760057fe$require$kQueue] = [];\n        this[$5c97a5b8760057fe$require$kRunningIdx] = 0;\n        this[$5c97a5b8760057fe$require$kPendingIdx] = 0;\n    }\n    get pipelining() {\n        return this[$5c97a5b8760057fe$require$kPipelining];\n    }\n    set pipelining(value) {\n        this[$5c97a5b8760057fe$require$kPipelining] = value;\n        $5c97a5b8760057fe$var$resume(this, true);\n    }\n    get [$5c97a5b8760057fe$require$kPending]() {\n        return this[$5c97a5b8760057fe$require$kQueue].length - this[$5c97a5b8760057fe$require$kPendingIdx];\n    }\n    get [$5c97a5b8760057fe$require$kRunning]() {\n        return this[$5c97a5b8760057fe$require$kPendingIdx] - this[$5c97a5b8760057fe$require$kRunningIdx];\n    }\n    get [$5c97a5b8760057fe$require$kSize]() {\n        return this[$5c97a5b8760057fe$require$kQueue].length - this[$5c97a5b8760057fe$require$kRunningIdx];\n    }\n    get [$5c97a5b8760057fe$require$kConnected]() {\n        return !!this[$5c97a5b8760057fe$require$kSocket] && !this[$5c97a5b8760057fe$require$kConnecting] && !this[$5c97a5b8760057fe$require$kSocket].destroyed;\n    }\n    get [$5c97a5b8760057fe$require$kBusy]() {\n        const socket = this[$5c97a5b8760057fe$require$kSocket];\n        return socket && (socket[$5c97a5b8760057fe$require$kReset] || socket[$5c97a5b8760057fe$require$kWriting] || socket[$5c97a5b8760057fe$require$kBlocking]) || this[$5c97a5b8760057fe$require$kSize] >= (this[$5c97a5b8760057fe$require$kPipelining] || 1) || this[$5c97a5b8760057fe$require$kPending] > 0;\n    }\n    /* istanbul ignore: only used for test */ [$5c97a5b8760057fe$require$kConnect](cb) {\n        $5c97a5b8760057fe$var$connect(this);\n        this.once('connect', cb);\n    }\n    [$5c97a5b8760057fe$require$kDispatch](opts, handler) {\n        const origin = opts.origin || this[$5c97a5b8760057fe$require$kUrl].origin;\n        const request = this[$5c97a5b8760057fe$require$kHTTPConnVersion] === 'h2' ? $16nGk$pythonversioncheck2f514258js[$5c97a5b8760057fe$require$kHTTP2BuildRequest](origin, opts, handler) : $16nGk$pythonversioncheck2f514258js[$5c97a5b8760057fe$require$kHTTP1BuildRequest](origin, opts, handler);\n        this[$5c97a5b8760057fe$require$kQueue].push(request);\n        if (this[$5c97a5b8760057fe$require$kResuming]) ;\n        else if ($16nGk$pythonversioncheck7ed1514ejs.bodyLength(request.body) == null && $16nGk$pythonversioncheck7ed1514ejs6.isIterable(request.body)) {\n            // Wait a tick in case stream/iterator is ended in the same tick.\n            this[$5c97a5b8760057fe$require$kResuming] = 1;\n            process.nextTick($5c97a5b8760057fe$var$resume, this);\n        } else $5c97a5b8760057fe$var$resume(this, true);\n        if (this[$5c97a5b8760057fe$require$kResuming] && this[$5c97a5b8760057fe$require$kNeedDrain] !== 2 && this[$5c97a5b8760057fe$require$kBusy]) this[$5c97a5b8760057fe$require$kNeedDrain] = 2;\n        return this[$5c97a5b8760057fe$require$kNeedDrain] < 2;\n    }\n    async [$5c97a5b8760057fe$require$kClose]() {\n        // TODO: for H2 we need to gracefully flush the remaining enqueued\n        // request and close each stream.\n        return new Promise((resolve)=>{\n            if (!this[$5c97a5b8760057fe$require$kSize]) resolve(null);\n            else this[$5c97a5b8760057fe$var$kClosedResolve] = resolve;\n        });\n    }\n    async [$5c97a5b8760057fe$require$kDestroy](err) {\n        return new Promise((resolve)=>{\n            const requests = this[$5c97a5b8760057fe$require$kQueue].splice(this[$5c97a5b8760057fe$require$kPendingIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                $5c97a5b8760057fe$var$errorRequest(this, request, err);\n            }\n            const callback = ()=>{\n                if (this[$5c97a5b8760057fe$var$kClosedResolve]) {\n                    // TODO (fix): Should we error here with ClientDestroyedError?\n                    this[$5c97a5b8760057fe$var$kClosedResolve]();\n                    this[$5c97a5b8760057fe$var$kClosedResolve] = null;\n                }\n                resolve();\n            };\n            if (this[$5c97a5b8760057fe$require$kHTTP2Session] != null) {\n                $16nGk$pythonversioncheck7ed1514ejs1.destroy(this[$5c97a5b8760057fe$require$kHTTP2Session], err);\n                this[$5c97a5b8760057fe$require$kHTTP2Session] = null;\n                this[$5c97a5b8760057fe$require$kHTTP2SessionState] = null;\n            }\n            if (!this[$5c97a5b8760057fe$require$kSocket]) queueMicrotask(callback);\n            else $16nGk$pythonversioncheck7ed1514ejs1.destroy(this[$5c97a5b8760057fe$require$kSocket].on('close', callback), err);\n            $5c97a5b8760057fe$var$resume(this);\n        });\n    }\n}\nfunction $5c97a5b8760057fe$var$onHttp2SessionError(err) {\n    $16nGk$assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n    this[$5c97a5b8760057fe$require$kSocket][$5c97a5b8760057fe$require$kError] = err;\n    $5c97a5b8760057fe$var$onError(this[$5c97a5b8760057fe$require$kClient], err);\n}\nfunction $5c97a5b8760057fe$var$onHttp2FrameError(type, code, id) {\n    const err = new $5c97a5b8760057fe$require$InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n    if (id === 0) {\n        this[$5c97a5b8760057fe$require$kSocket][$5c97a5b8760057fe$require$kError] = err;\n        $5c97a5b8760057fe$var$onError(this[$5c97a5b8760057fe$require$kClient], err);\n    }\n}\nfunction $5c97a5b8760057fe$var$onHttp2SessionEnd() {\n    $16nGk$pythonversioncheck7ed1514ejs1.destroy(this, new $5c97a5b8760057fe$require$SocketError('other side closed'));\n    $16nGk$pythonversioncheck7ed1514ejs1.destroy(this[$5c97a5b8760057fe$require$kSocket], new $5c97a5b8760057fe$require$SocketError('other side closed'));\n}\nfunction $5c97a5b8760057fe$var$onHTTP2GoAway(code) {\n    const client = this[$5c97a5b8760057fe$require$kClient];\n    const err = new $5c97a5b8760057fe$require$InformationalError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`);\n    client[$5c97a5b8760057fe$require$kSocket] = null;\n    client[$5c97a5b8760057fe$require$kHTTP2Session] = null;\n    if (client.destroyed) {\n        $16nGk$assert(this[$5c97a5b8760057fe$require$kPending] === 0);\n        // Fail entire queue.\n        const requests = client[$5c97a5b8760057fe$require$kQueue].splice(client[$5c97a5b8760057fe$require$kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            $5c97a5b8760057fe$var$errorRequest(this, request, err);\n        }\n    } else if (client[$5c97a5b8760057fe$require$kRunning] > 0) {\n        // Fail head of pipeline.\n        const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]];\n        client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]++] = null;\n        $5c97a5b8760057fe$var$errorRequest(client, request, err);\n    }\n    client[$5c97a5b8760057fe$require$kPendingIdx] = client[$5c97a5b8760057fe$require$kRunningIdx];\n    $16nGk$assert(client[$5c97a5b8760057fe$require$kRunning] === 0);\n    client.emit('disconnect', client[$5c97a5b8760057fe$require$kUrl], [\n        client\n    ], err);\n    $5c97a5b8760057fe$var$resume(client);\n}\n\n\nconst $5c97a5b8760057fe$var$EMPTY_BUF = Buffer.alloc(0);\n\n\n\nasync function $5c97a5b8760057fe$var$lazyllhttp() {\n    const llhttpWasmData = process.env.JEST_WORKER_ID ? $16nGk$pythonversionchecke57c179ejs : undefined;\n    let mod;\n    try {\n        mod = await WebAssembly.compile(Buffer.from($16nGk$pythonversioncheckf30ce740js, 'base64'));\n    } catch (e) {\n        /* istanbul ignore next */ // We could check if the error was caused by the simd option not\n        // being enabled, but the occurring of this other error\n        // * https://github.com/emscripten-core/emscripten/issues/11495\n        // got me to remove that check to avoid breaking Node 12.\n        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || $16nGk$pythonversionchecke57c179ejs, 'base64'));\n    }\n    return await WebAssembly.instantiate(mod, {\n        env: {\n            /* eslint-disable camelcase */ wasm_on_url: (p, at, len)=>{\n                /* istanbul ignore next */ return 0;\n            },\n            wasm_on_status: (p, at, len)=>{\n                $16nGk$assert.strictEqual($5c97a5b8760057fe$var$currentParser.ptr, p);\n                const start = at - $5c97a5b8760057fe$var$currentBufferPtr + $5c97a5b8760057fe$var$currentBufferRef.byteOffset;\n                return $5c97a5b8760057fe$var$currentParser.onStatus(new $5c97a5b8760057fe$var$FastBuffer($5c97a5b8760057fe$var$currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_begin: (p)=>{\n                $16nGk$assert.strictEqual($5c97a5b8760057fe$var$currentParser.ptr, p);\n                return $5c97a5b8760057fe$var$currentParser.onMessageBegin() || 0;\n            },\n            wasm_on_header_field: (p, at, len)=>{\n                $16nGk$assert.strictEqual($5c97a5b8760057fe$var$currentParser.ptr, p);\n                const start = at - $5c97a5b8760057fe$var$currentBufferPtr + $5c97a5b8760057fe$var$currentBufferRef.byteOffset;\n                return $5c97a5b8760057fe$var$currentParser.onHeaderField(new $5c97a5b8760057fe$var$FastBuffer($5c97a5b8760057fe$var$currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_header_value: (p, at, len)=>{\n                $16nGk$assert.strictEqual($5c97a5b8760057fe$var$currentParser.ptr, p);\n                const start = at - $5c97a5b8760057fe$var$currentBufferPtr + $5c97a5b8760057fe$var$currentBufferRef.byteOffset;\n                return $5c97a5b8760057fe$var$currentParser.onHeaderValue(new $5c97a5b8760057fe$var$FastBuffer($5c97a5b8760057fe$var$currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive)=>{\n                $16nGk$assert.strictEqual($5c97a5b8760057fe$var$currentParser.ptr, p);\n                return $5c97a5b8760057fe$var$currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n            },\n            wasm_on_body: (p, at, len)=>{\n                $16nGk$assert.strictEqual($5c97a5b8760057fe$var$currentParser.ptr, p);\n                const start = at - $5c97a5b8760057fe$var$currentBufferPtr + $5c97a5b8760057fe$var$currentBufferRef.byteOffset;\n                return $5c97a5b8760057fe$var$currentParser.onBody(new $5c97a5b8760057fe$var$FastBuffer($5c97a5b8760057fe$var$currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_complete: (p)=>{\n                $16nGk$assert.strictEqual($5c97a5b8760057fe$var$currentParser.ptr, p);\n                return $5c97a5b8760057fe$var$currentParser.onMessageComplete() || 0;\n            }\n        }\n    });\n}\nlet $5c97a5b8760057fe$var$llhttpInstance = null;\nlet $5c97a5b8760057fe$var$llhttpPromise = $5c97a5b8760057fe$var$lazyllhttp();\n$5c97a5b8760057fe$var$llhttpPromise.catch();\nlet $5c97a5b8760057fe$var$currentParser = null;\nlet $5c97a5b8760057fe$var$currentBufferRef = null;\nlet $5c97a5b8760057fe$var$currentBufferSize = 0;\nlet $5c97a5b8760057fe$var$currentBufferPtr = null;\nconst $5c97a5b8760057fe$var$TIMEOUT_HEADERS = 1;\nconst $5c97a5b8760057fe$var$TIMEOUT_BODY = 2;\nconst $5c97a5b8760057fe$var$TIMEOUT_IDLE = 3;\nclass $5c97a5b8760057fe$var$Parser {\n    constructor(client, socket, { exports: exports }){\n        $16nGk$assert(Number.isFinite(client[$5c97a5b8760057fe$require$kMaxHeadersSize]) && client[$5c97a5b8760057fe$require$kMaxHeadersSize] > 0);\n        this.llhttp = exports;\n        this.ptr = this.llhttp.llhttp_alloc($16nGk$pythonversioncheck67e8c7c6js1.TYPE.RESPONSE);\n        this.client = client;\n        this.socket = socket;\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.statusCode = null;\n        this.statusText = '';\n        this.upgrade = false;\n        this.headers = [];\n        this.headersSize = 0;\n        this.headersMaxSize = client[$5c97a5b8760057fe$require$kMaxHeadersSize];\n        this.shouldKeepAlive = false;\n        this.paused = false;\n        this.resume = this.resume.bind(this);\n        this.bytesRead = 0;\n        this.keepAlive = '';\n        this.contentLength = '';\n        this.connection = '';\n        this.maxResponseSize = client[$5c97a5b8760057fe$require$kMaxResponseSize];\n    }\n    setTimeout(value, type) {\n        this.timeoutType = type;\n        if (value !== this.timeoutValue) {\n            $16nGk$pythonversioncheck715a24bajs.clearTimeout(this.timeout);\n            if (value) {\n                this.timeout = $16nGk$pythonversioncheck715a24bajs1.setTimeout($5c97a5b8760057fe$var$onParserTimeout, value, this);\n                // istanbul ignore else: only for jest\n                if (this.timeout.unref) this.timeout.unref();\n            } else this.timeout = null;\n            this.timeoutValue = value;\n        } else if (this.timeout) // istanbul ignore else: only for jest\n        {\n            if (this.timeout.refresh) this.timeout.refresh();\n        }\n    }\n    resume() {\n        if (this.socket.destroyed || !this.paused) return;\n        $16nGk$assert(this.ptr != null);\n        $16nGk$assert($5c97a5b8760057fe$var$currentParser == null);\n        this.llhttp.llhttp_resume(this.ptr);\n        $16nGk$assert(this.timeoutType === $5c97a5b8760057fe$var$TIMEOUT_BODY);\n        if (this.timeout) // istanbul ignore else: only for jest\n        {\n            if (this.timeout.refresh) this.timeout.refresh();\n        }\n        this.paused = false;\n        this.execute(this.socket.read() || $5c97a5b8760057fe$var$EMPTY_BUF) // Flush parser.\n        ;\n        this.readMore();\n    }\n    readMore() {\n        while(!this.paused && this.ptr){\n            const chunk = this.socket.read();\n            if (chunk === null) break;\n            this.execute(chunk);\n        }\n    }\n    execute(data) {\n        $16nGk$assert(this.ptr != null);\n        $16nGk$assert($5c97a5b8760057fe$var$currentParser == null);\n        $16nGk$assert(!this.paused);\n        const { socket: socket, llhttp: llhttp } = this;\n        if (data.length > $5c97a5b8760057fe$var$currentBufferSize) {\n            if ($5c97a5b8760057fe$var$currentBufferPtr) llhttp.free($5c97a5b8760057fe$var$currentBufferPtr);\n            $5c97a5b8760057fe$var$currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n            $5c97a5b8760057fe$var$currentBufferPtr = llhttp.malloc($5c97a5b8760057fe$var$currentBufferSize);\n        }\n        new Uint8Array(llhttp.memory.buffer, $5c97a5b8760057fe$var$currentBufferPtr, $5c97a5b8760057fe$var$currentBufferSize).set(data);\n        // Call `execute` on the wasm parser.\n        // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n        // and finally the length of bytes to parse.\n        // The return value is an error code or `constants.ERROR.OK`.\n        try {\n            let ret;\n            try {\n                $5c97a5b8760057fe$var$currentBufferRef = data;\n                $5c97a5b8760057fe$var$currentParser = this;\n                ret = llhttp.llhttp_execute(this.ptr, $5c97a5b8760057fe$var$currentBufferPtr, data.length);\n            /* eslint-disable-next-line no-useless-catch */ } catch (err) {\n                /* istanbul ignore next: difficult to make a test case for */ throw err;\n            } finally{\n                $5c97a5b8760057fe$var$currentParser = null;\n                $5c97a5b8760057fe$var$currentBufferRef = null;\n            }\n            const offset = llhttp.llhttp_get_error_pos(this.ptr) - $5c97a5b8760057fe$var$currentBufferPtr;\n            if (ret === $16nGk$pythonversioncheck67e8c7c6js.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));\n            else if (ret === $16nGk$pythonversioncheck67e8c7c6js.ERROR.PAUSED) {\n                this.paused = true;\n                socket.unshift(data.slice(offset));\n            } else if (ret !== $16nGk$pythonversioncheck67e8c7c6js.ERROR.OK) {\n                const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n                let message = '';\n                /* istanbul ignore else: difficult to make a test case for */ if (ptr) {\n                    const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n                    message = 'Response does not match the HTTP/1.1 protocol (' + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ')';\n                }\n                throw new $5c97a5b8760057fe$require$HTTPParserError(message, $16nGk$pythonversioncheck67e8c7c6js.ERROR[ret], data.slice(offset));\n            }\n        } catch (err) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, err);\n        }\n    }\n    destroy() {\n        $16nGk$assert(this.ptr != null);\n        $16nGk$assert($5c97a5b8760057fe$var$currentParser == null);\n        this.llhttp.llhttp_free(this.ptr);\n        this.ptr = null;\n        $16nGk$pythonversioncheck715a24bajs.clearTimeout(this.timeout);\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.paused = false;\n    }\n    onStatus(buf) {\n        this.statusText = buf.toString();\n    }\n    onMessageBegin() {\n        const { socket: socket, client: client } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) return -1;\n        const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]];\n        if (!request) return -1;\n    }\n    onHeaderField(buf) {\n        const len = this.headers.length;\n        if ((len & 1) === 0) this.headers.push(buf);\n        else this.headers[len - 1] = Buffer.concat([\n            this.headers[len - 1],\n            buf\n        ]);\n        this.trackHeader(buf.length);\n    }\n    onHeaderValue(buf) {\n        let len = this.headers.length;\n        if ((len & 1) === 1) {\n            this.headers.push(buf);\n            len += 1;\n        } else this.headers[len - 1] = Buffer.concat([\n            this.headers[len - 1],\n            buf\n        ]);\n        const key = this.headers[len - 2];\n        if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') this.keepAlive += buf.toString();\n        else if (key.length === 10 && key.toString().toLowerCase() === 'connection') this.connection += buf.toString();\n        else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') this.contentLength += buf.toString();\n        this.trackHeader(buf.length);\n    }\n    trackHeader(len) {\n        this.headersSize += len;\n        if (this.headersSize >= this.headersMaxSize) $16nGk$pythonversioncheck7ed1514ejs1.destroy(this.socket, new $5c97a5b8760057fe$require$HeadersOverflowError());\n    }\n    onUpgrade(head) {\n        const { upgrade: upgrade, client: client, socket: socket, headers: headers, statusCode: statusCode } = this;\n        $16nGk$assert(upgrade);\n        const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]];\n        $16nGk$assert(request);\n        $16nGk$assert(!socket.destroyed);\n        $16nGk$assert(socket === client[$5c97a5b8760057fe$require$kSocket]);\n        $16nGk$assert(!this.paused);\n        $16nGk$assert(request.upgrade || request.method === 'CONNECT');\n        this.statusCode = null;\n        this.statusText = '';\n        this.shouldKeepAlive = null;\n        $16nGk$assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        socket.unshift(head);\n        socket[$5c97a5b8760057fe$require$kParser].destroy();\n        socket[$5c97a5b8760057fe$require$kParser] = null;\n        socket[$5c97a5b8760057fe$require$kClient] = null;\n        socket[$5c97a5b8760057fe$require$kError] = null;\n        socket.removeListener('error', $5c97a5b8760057fe$var$onSocketError).removeListener('readable', $5c97a5b8760057fe$var$onSocketReadable).removeListener('end', $5c97a5b8760057fe$var$onSocketEnd).removeListener('close', $5c97a5b8760057fe$var$onSocketClose);\n        client[$5c97a5b8760057fe$require$kSocket] = null;\n        client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]++] = null;\n        client.emit('disconnect', client[$5c97a5b8760057fe$require$kUrl], [\n            client\n        ], new $5c97a5b8760057fe$require$InformationalError('upgrade'));\n        try {\n            request.onUpgrade(statusCode, headers, socket);\n        } catch (err) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, err);\n        }\n        $5c97a5b8760057fe$var$resume(client);\n    }\n    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n        const { client: client, socket: socket, headers: headers, statusText: statusText } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) return -1;\n        const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]];\n        /* istanbul ignore next: difficult to make a test case for */ if (!request) return -1;\n        $16nGk$assert(!this.upgrade);\n        $16nGk$assert(this.statusCode < 200);\n        if (statusCode === 100) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$SocketError('bad response', $16nGk$pythonversioncheck7ed1514ejs2.getSocketInfo(socket)));\n            return -1;\n        }\n        /* this can only happen if server is misbehaving */ if (upgrade && !request.upgrade) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$SocketError('bad upgrade', $16nGk$pythonversioncheck7ed1514ejs2.getSocketInfo(socket)));\n            return -1;\n        }\n        $16nGk$assert.strictEqual(this.timeoutType, $5c97a5b8760057fe$var$TIMEOUT_HEADERS);\n        this.statusCode = statusCode;\n        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.\n        request.method === 'HEAD' && !socket[$5c97a5b8760057fe$require$kReset] && this.connection.toLowerCase() === 'keep-alive';\n        if (this.statusCode >= 200) {\n            const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[$5c97a5b8760057fe$require$kBodyTimeout];\n            this.setTimeout(bodyTimeout, $5c97a5b8760057fe$var$TIMEOUT_BODY);\n        } else if (this.timeout) // istanbul ignore else: only for jest\n        {\n            if (this.timeout.refresh) this.timeout.refresh();\n        }\n        if (request.method === 'CONNECT') {\n            $16nGk$assert(client[$5c97a5b8760057fe$require$kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        if (upgrade) {\n            $16nGk$assert(client[$5c97a5b8760057fe$require$kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        $16nGk$assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (this.shouldKeepAlive && client[$5c97a5b8760057fe$require$kPipelining]) {\n            const keepAliveTimeout = this.keepAlive ? $16nGk$pythonversioncheck7ed1514ejs9.parseKeepAliveTimeout(this.keepAlive) : null;\n            if (keepAliveTimeout != null) {\n                const timeout = Math.min(keepAliveTimeout - client[$5c97a5b8760057fe$require$kKeepAliveTimeoutThreshold], client[$5c97a5b8760057fe$require$kKeepAliveMaxTimeout]);\n                if (timeout <= 0) socket[$5c97a5b8760057fe$require$kReset] = true;\n                else client[$5c97a5b8760057fe$require$kKeepAliveTimeoutValue] = timeout;\n            } else client[$5c97a5b8760057fe$require$kKeepAliveTimeoutValue] = client[$5c97a5b8760057fe$require$kKeepAliveDefaultTimeout];\n        } else // Stop more requests from being dispatched.\n        socket[$5c97a5b8760057fe$require$kReset] = true;\n        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n        if (request.aborted) return -1;\n        if (request.method === 'HEAD') return 1;\n        if (statusCode < 200) return 1;\n        if (socket[$5c97a5b8760057fe$require$kBlocking]) {\n            socket[$5c97a5b8760057fe$require$kBlocking] = false;\n            $5c97a5b8760057fe$var$resume(client);\n        }\n        return pause ? $16nGk$pythonversioncheck67e8c7c6js.ERROR.PAUSED : 0;\n    }\n    onBody(buf) {\n        const { client: client, socket: socket, statusCode: statusCode, maxResponseSize: maxResponseSize } = this;\n        if (socket.destroyed) return -1;\n        const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]];\n        $16nGk$assert(request);\n        $16nGk$assert.strictEqual(this.timeoutType, $5c97a5b8760057fe$var$TIMEOUT_BODY);\n        if (this.timeout) // istanbul ignore else: only for jest\n        {\n            if (this.timeout.refresh) this.timeout.refresh();\n        }\n        $16nGk$assert(statusCode >= 200);\n        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$ResponseExceededMaxSizeError());\n            return -1;\n        }\n        this.bytesRead += buf.length;\n        if (request.onData(buf) === false) return $16nGk$pythonversioncheck67e8c7c6js.ERROR.PAUSED;\n    }\n    onMessageComplete() {\n        const { client: client, socket: socket, statusCode: statusCode, upgrade: upgrade, headers: headers, contentLength: contentLength, bytesRead: bytesRead, shouldKeepAlive: shouldKeepAlive } = this;\n        if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;\n        if (upgrade) return;\n        const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]];\n        $16nGk$assert(request);\n        $16nGk$assert(statusCode >= 100);\n        this.statusCode = null;\n        this.statusText = '';\n        this.bytesRead = 0;\n        this.contentLength = '';\n        this.keepAlive = '';\n        this.connection = '';\n        $16nGk$assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (statusCode < 200) return;\n        /* istanbul ignore next: should be handled by llhttp? */ if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$ResponseContentLengthMismatchError());\n            return -1;\n        }\n        request.onComplete(headers);\n        client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]++] = null;\n        if (socket[$5c97a5b8760057fe$require$kWriting]) {\n            $16nGk$assert.strictEqual(client[$5c97a5b8760057fe$require$kRunning], 0);\n            // Response completed before request.\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$InformationalError('reset'));\n            return $16nGk$pythonversioncheck67e8c7c6js.ERROR.PAUSED;\n        } else if (!shouldKeepAlive) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$InformationalError('reset'));\n            return $16nGk$pythonversioncheck67e8c7c6js.ERROR.PAUSED;\n        } else if (socket[$5c97a5b8760057fe$require$kReset] && client[$5c97a5b8760057fe$require$kRunning] === 0) {\n            // Destroy socket once all requests have completed.\n            // The request at the tail of the pipeline is the one\n            // that requested reset and no further requests should\n            // have been queued since then.\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$InformationalError('reset'));\n            return $16nGk$pythonversioncheck67e8c7c6js.ERROR.PAUSED;\n        } else if (client[$5c97a5b8760057fe$require$kPipelining] === 1) // We must wait a full event loop cycle to reuse this socket to make sure\n        // that non-spec compliant servers are not closing the connection even if they\n        // said they won't.\n        setImmediate($5c97a5b8760057fe$var$resume, client);\n        else $5c97a5b8760057fe$var$resume(client);\n    }\n}\nfunction $5c97a5b8760057fe$var$onParserTimeout(parser) {\n    const { socket: socket, timeoutType: timeoutType, client: client } = parser;\n    /* istanbul ignore else */ if (timeoutType === $5c97a5b8760057fe$var$TIMEOUT_HEADERS) {\n        if (!socket[$5c97a5b8760057fe$require$kWriting] || socket.writableNeedDrain || client[$5c97a5b8760057fe$require$kRunning] > 1) {\n            $16nGk$assert(!parser.paused, 'cannot be paused while waiting for headers');\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$HeadersTimeoutError());\n        }\n    } else if (timeoutType === $5c97a5b8760057fe$var$TIMEOUT_BODY) {\n        if (!parser.paused) $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$BodyTimeoutError());\n    } else if (timeoutType === $5c97a5b8760057fe$var$TIMEOUT_IDLE) {\n        $16nGk$assert(client[$5c97a5b8760057fe$require$kRunning] === 0 && client[$5c97a5b8760057fe$require$kKeepAliveTimeoutValue]);\n        $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$InformationalError('socket idle timeout'));\n    }\n}\nfunction $5c97a5b8760057fe$var$onSocketReadable() {\n    const { [$5c97a5b8760057fe$require$kParser]: parser } = this;\n    if (parser) parser.readMore();\n}\nfunction $5c97a5b8760057fe$var$onSocketError(err) {\n    const { [$5c97a5b8760057fe$require$kClient]: client, [$5c97a5b8760057fe$require$kParser]: parser } = this;\n    $16nGk$assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n    if (client[$5c97a5b8760057fe$require$kHTTPConnVersion] !== 'h2') // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    {\n        if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so for as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n    }\n    this[$5c97a5b8760057fe$require$kError] = err;\n    $5c97a5b8760057fe$var$onError(this[$5c97a5b8760057fe$require$kClient], err);\n}\nfunction $5c97a5b8760057fe$var$onError(client, err) {\n    if (client[$5c97a5b8760057fe$require$kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n        // Error is not caused by running request and not a recoverable\n        // socket error.\n        $16nGk$assert(client[$5c97a5b8760057fe$require$kPendingIdx] === client[$5c97a5b8760057fe$require$kRunningIdx]);\n        const requests = client[$5c97a5b8760057fe$require$kQueue].splice(client[$5c97a5b8760057fe$require$kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            $5c97a5b8760057fe$var$errorRequest(client, request, err);\n        }\n        $16nGk$assert(client[$5c97a5b8760057fe$require$kSize] === 0);\n    }\n}\nfunction $5c97a5b8760057fe$var$onSocketEnd() {\n    const { [$5c97a5b8760057fe$require$kParser]: parser, [$5c97a5b8760057fe$require$kClient]: client } = this;\n    if (client[$5c97a5b8760057fe$require$kHTTPConnVersion] !== 'h2') {\n        if (parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n    }\n    $16nGk$pythonversioncheck7ed1514ejs1.destroy(this, new $5c97a5b8760057fe$require$SocketError('other side closed', $16nGk$pythonversioncheck7ed1514ejs2.getSocketInfo(this)));\n}\nfunction $5c97a5b8760057fe$var$onSocketClose() {\n    const { [$5c97a5b8760057fe$require$kClient]: client, [$5c97a5b8760057fe$require$kParser]: parser } = this;\n    if (client[$5c97a5b8760057fe$require$kHTTPConnVersion] === 'h1' && parser) {\n        if (!this[$5c97a5b8760057fe$require$kError] && parser.statusCode && !parser.shouldKeepAlive) // We treat all incoming data so far as a valid response.\n        parser.onMessageComplete();\n        this[$5c97a5b8760057fe$require$kParser].destroy();\n        this[$5c97a5b8760057fe$require$kParser] = null;\n    }\n    const err = this[$5c97a5b8760057fe$require$kError] || new $5c97a5b8760057fe$require$SocketError('closed', $16nGk$pythonversioncheck7ed1514ejs2.getSocketInfo(this));\n    client[$5c97a5b8760057fe$require$kSocket] = null;\n    if (client.destroyed) {\n        $16nGk$assert(client[$5c97a5b8760057fe$require$kPending] === 0);\n        // Fail entire queue.\n        const requests = client[$5c97a5b8760057fe$require$kQueue].splice(client[$5c97a5b8760057fe$require$kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            $5c97a5b8760057fe$var$errorRequest(client, request, err);\n        }\n    } else if (client[$5c97a5b8760057fe$require$kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n        // Fail head of pipeline.\n        const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]];\n        client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]++] = null;\n        $5c97a5b8760057fe$var$errorRequest(client, request, err);\n    }\n    client[$5c97a5b8760057fe$require$kPendingIdx] = client[$5c97a5b8760057fe$require$kRunningIdx];\n    $16nGk$assert(client[$5c97a5b8760057fe$require$kRunning] === 0);\n    client.emit('disconnect', client[$5c97a5b8760057fe$require$kUrl], [\n        client\n    ], err);\n    $5c97a5b8760057fe$var$resume(client);\n}\nasync function $5c97a5b8760057fe$var$connect(client) {\n    $16nGk$assert(!client[$5c97a5b8760057fe$require$kConnecting]);\n    $16nGk$assert(!client[$5c97a5b8760057fe$require$kSocket]);\n    let { host: host, hostname: hostname, protocol: protocol, port: port } = client[$5c97a5b8760057fe$require$kUrl];\n    // Resolve ipv6\n    if (hostname[0] === '[') {\n        const idx = hostname.indexOf(']');\n        $16nGk$assert(idx !== -1);\n        const ip = hostname.substring(1, idx);\n        $16nGk$assert($16nGk$isIP(ip));\n        hostname = ip;\n    }\n    client[$5c97a5b8760057fe$require$kConnecting] = true;\n    if ($5c97a5b8760057fe$var$channels.beforeConnect.hasSubscribers) $5c97a5b8760057fe$var$channels.beforeConnect.publish({\n        connectParams: {\n            host: host,\n            hostname: hostname,\n            protocol: protocol,\n            port: port,\n            servername: client[$5c97a5b8760057fe$require$kServerName],\n            localAddress: client[$5c97a5b8760057fe$require$kLocalAddress]\n        },\n        connector: client[$5c97a5b8760057fe$require$kConnector]\n    });\n    try {\n        const socket = await new Promise((resolve, reject)=>{\n            client[$5c97a5b8760057fe$require$kConnector]({\n                host: host,\n                hostname: hostname,\n                protocol: protocol,\n                port: port,\n                servername: client[$5c97a5b8760057fe$require$kServerName],\n                localAddress: client[$5c97a5b8760057fe$require$kLocalAddress]\n            }, (err, socket)=>{\n                if (err) reject(err);\n                else resolve(socket);\n            });\n        });\n        if (client.destroyed) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket.on('error', ()=>{}), new $5c97a5b8760057fe$require$ClientDestroyedError());\n            return;\n        }\n        client[$5c97a5b8760057fe$require$kConnecting] = false;\n        $16nGk$assert(socket);\n        const isH2 = socket.alpnProtocol === 'h2';\n        if (isH2) {\n            if (!$5c97a5b8760057fe$var$h2ExperimentalWarned) {\n                $5c97a5b8760057fe$var$h2ExperimentalWarned = true;\n                process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n                    code: 'UNDICI-H2'\n                });\n            }\n            const session = $5c97a5b8760057fe$var$http2.connect(client[$5c97a5b8760057fe$require$kUrl], {\n                createConnection: ()=>socket,\n                peerMaxConcurrentStreams: client[$5c97a5b8760057fe$require$kHTTP2SessionState].maxConcurrentStreams\n            });\n            client[$5c97a5b8760057fe$require$kHTTPConnVersion] = 'h2';\n            session[$5c97a5b8760057fe$require$kClient] = client;\n            session[$5c97a5b8760057fe$require$kSocket] = socket;\n            session.on('error', $5c97a5b8760057fe$var$onHttp2SessionError);\n            session.on('frameError', $5c97a5b8760057fe$var$onHttp2FrameError);\n            session.on('end', $5c97a5b8760057fe$var$onHttp2SessionEnd);\n            session.on('goaway', $5c97a5b8760057fe$var$onHTTP2GoAway);\n            session.on('close', $5c97a5b8760057fe$var$onSocketClose);\n            session.unref();\n            client[$5c97a5b8760057fe$require$kHTTP2Session] = session;\n            socket[$5c97a5b8760057fe$require$kHTTP2Session] = session;\n        } else {\n            if (!$5c97a5b8760057fe$var$llhttpInstance) {\n                $5c97a5b8760057fe$var$llhttpInstance = await $5c97a5b8760057fe$var$llhttpPromise;\n                $5c97a5b8760057fe$var$llhttpPromise = null;\n            }\n            socket[$5c97a5b8760057fe$require$kNoRef] = false;\n            socket[$5c97a5b8760057fe$require$kWriting] = false;\n            socket[$5c97a5b8760057fe$require$kReset] = false;\n            socket[$5c97a5b8760057fe$require$kBlocking] = false;\n            socket[$5c97a5b8760057fe$require$kParser] = new $5c97a5b8760057fe$var$Parser(client, socket, $5c97a5b8760057fe$var$llhttpInstance);\n        }\n        socket[$5c97a5b8760057fe$require$kCounter] = 0;\n        socket[$5c97a5b8760057fe$require$kMaxRequests] = client[$5c97a5b8760057fe$require$kMaxRequests];\n        socket[$5c97a5b8760057fe$require$kClient] = client;\n        socket[$5c97a5b8760057fe$require$kError] = null;\n        socket.on('error', $5c97a5b8760057fe$var$onSocketError).on('readable', $5c97a5b8760057fe$var$onSocketReadable).on('end', $5c97a5b8760057fe$var$onSocketEnd).on('close', $5c97a5b8760057fe$var$onSocketClose);\n        client[$5c97a5b8760057fe$require$kSocket] = socket;\n        if ($5c97a5b8760057fe$var$channels.connected.hasSubscribers) $5c97a5b8760057fe$var$channels.connected.publish({\n            connectParams: {\n                host: host,\n                hostname: hostname,\n                protocol: protocol,\n                port: port,\n                servername: client[$5c97a5b8760057fe$require$kServerName],\n                localAddress: client[$5c97a5b8760057fe$require$kLocalAddress]\n            },\n            connector: client[$5c97a5b8760057fe$require$kConnector],\n            socket: socket\n        });\n        client.emit('connect', client[$5c97a5b8760057fe$require$kUrl], [\n            client\n        ]);\n    } catch (err) {\n        if (client.destroyed) return;\n        client[$5c97a5b8760057fe$require$kConnecting] = false;\n        if ($5c97a5b8760057fe$var$channels.connectError.hasSubscribers) $5c97a5b8760057fe$var$channels.connectError.publish({\n            connectParams: {\n                host: host,\n                hostname: hostname,\n                protocol: protocol,\n                port: port,\n                servername: client[$5c97a5b8760057fe$require$kServerName],\n                localAddress: client[$5c97a5b8760057fe$require$kLocalAddress]\n            },\n            connector: client[$5c97a5b8760057fe$require$kConnector],\n            error: err\n        });\n        if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            $16nGk$assert(client[$5c97a5b8760057fe$require$kRunning] === 0);\n            while(client[$5c97a5b8760057fe$require$kPending] > 0 && client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kPendingIdx]].servername === client[$5c97a5b8760057fe$require$kServerName]){\n                const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kPendingIdx]++];\n                $5c97a5b8760057fe$var$errorRequest(client, request, err);\n            }\n        } else $5c97a5b8760057fe$var$onError(client, err);\n        client.emit('connectionError', client[$5c97a5b8760057fe$require$kUrl], [\n            client\n        ], err);\n    }\n    $5c97a5b8760057fe$var$resume(client);\n}\nfunction $5c97a5b8760057fe$var$emitDrain(client) {\n    client[$5c97a5b8760057fe$require$kNeedDrain] = 0;\n    client.emit('drain', client[$5c97a5b8760057fe$require$kUrl], [\n        client\n    ]);\n}\nfunction $5c97a5b8760057fe$var$resume(client, sync) {\n    if (client[$5c97a5b8760057fe$require$kResuming] === 2) return;\n    client[$5c97a5b8760057fe$require$kResuming] = 2;\n    $5c97a5b8760057fe$var$_resume(client, sync);\n    client[$5c97a5b8760057fe$require$kResuming] = 0;\n    if (client[$5c97a5b8760057fe$require$kRunningIdx] > 256) {\n        client[$5c97a5b8760057fe$require$kQueue].splice(0, client[$5c97a5b8760057fe$require$kRunningIdx]);\n        client[$5c97a5b8760057fe$require$kPendingIdx] -= client[$5c97a5b8760057fe$require$kRunningIdx];\n        client[$5c97a5b8760057fe$require$kRunningIdx] = 0;\n    }\n}\nfunction $5c97a5b8760057fe$var$_resume(client, sync) {\n    while(true){\n        if (client.destroyed) {\n            $16nGk$assert(client[$5c97a5b8760057fe$require$kPending] === 0);\n            return;\n        }\n        if (client[$5c97a5b8760057fe$var$kClosedResolve] && !client[$5c97a5b8760057fe$require$kSize]) {\n            client[$5c97a5b8760057fe$var$kClosedResolve]();\n            client[$5c97a5b8760057fe$var$kClosedResolve] = null;\n            return;\n        }\n        const socket = client[$5c97a5b8760057fe$require$kSocket];\n        if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {\n            if (client[$5c97a5b8760057fe$require$kSize] === 0) {\n                if (!socket[$5c97a5b8760057fe$require$kNoRef] && socket.unref) {\n                    socket.unref();\n                    socket[$5c97a5b8760057fe$require$kNoRef] = true;\n                }\n            } else if (socket[$5c97a5b8760057fe$require$kNoRef] && socket.ref) {\n                socket.ref();\n                socket[$5c97a5b8760057fe$require$kNoRef] = false;\n            }\n            if (client[$5c97a5b8760057fe$require$kSize] === 0) {\n                if (socket[$5c97a5b8760057fe$require$kParser].timeoutType !== $5c97a5b8760057fe$var$TIMEOUT_IDLE) socket[$5c97a5b8760057fe$require$kParser].setTimeout(client[$5c97a5b8760057fe$require$kKeepAliveTimeoutValue], $5c97a5b8760057fe$var$TIMEOUT_IDLE);\n            } else if (client[$5c97a5b8760057fe$require$kRunning] > 0 && socket[$5c97a5b8760057fe$require$kParser].statusCode < 200) {\n                if (socket[$5c97a5b8760057fe$require$kParser].timeoutType !== $5c97a5b8760057fe$var$TIMEOUT_HEADERS) {\n                    const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kRunningIdx]];\n                    const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[$5c97a5b8760057fe$require$kHeadersTimeout];\n                    socket[$5c97a5b8760057fe$require$kParser].setTimeout(headersTimeout, $5c97a5b8760057fe$var$TIMEOUT_HEADERS);\n                }\n            }\n        }\n        if (client[$5c97a5b8760057fe$require$kBusy]) client[$5c97a5b8760057fe$require$kNeedDrain] = 2;\n        else if (client[$5c97a5b8760057fe$require$kNeedDrain] === 2) {\n            if (sync) {\n                client[$5c97a5b8760057fe$require$kNeedDrain] = 1;\n                process.nextTick($5c97a5b8760057fe$var$emitDrain, client);\n            } else $5c97a5b8760057fe$var$emitDrain(client);\n            continue;\n        }\n        if (client[$5c97a5b8760057fe$require$kPending] === 0) return;\n        if (client[$5c97a5b8760057fe$require$kRunning] >= (client[$5c97a5b8760057fe$require$kPipelining] || 1)) return;\n        const request = client[$5c97a5b8760057fe$require$kQueue][client[$5c97a5b8760057fe$require$kPendingIdx]];\n        if (client[$5c97a5b8760057fe$require$kUrl].protocol === 'https:' && client[$5c97a5b8760057fe$require$kServerName] !== request.servername) {\n            if (client[$5c97a5b8760057fe$require$kRunning] > 0) return;\n            client[$5c97a5b8760057fe$require$kServerName] = request.servername;\n            if (socket && socket.servername !== request.servername) {\n                $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$InformationalError('servername changed'));\n                return;\n            }\n        }\n        if (client[$5c97a5b8760057fe$require$kConnecting]) return;\n        if (!socket && !client[$5c97a5b8760057fe$require$kHTTP2Session]) {\n            $5c97a5b8760057fe$var$connect(client);\n            return;\n        }\n        if (socket.destroyed || socket[$5c97a5b8760057fe$require$kWriting] || socket[$5c97a5b8760057fe$require$kReset] || socket[$5c97a5b8760057fe$require$kBlocking]) return;\n        if (client[$5c97a5b8760057fe$require$kRunning] > 0 && !request.idempotent) // Non-idempotent request cannot be retried.\n        // Ensure that no other requests are inflight and\n        // could cause failure.\n        return;\n        if (client[$5c97a5b8760057fe$require$kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) // Don't dispatch an upgrade until all preceding requests have completed.\n        // A misbehaving server might upgrade the connection before all pipelined\n        // request has completed.\n        return;\n        if (client[$5c97a5b8760057fe$require$kRunning] > 0 && $16nGk$pythonversioncheck7ed1514ejs.bodyLength(request.body) !== 0 && ($16nGk$pythonversioncheck7ed1514ejs7.isStream(request.body) || $16nGk$pythonversioncheck7ed1514ejs3.isAsyncIterable(request.body))) // Request with stream or iterator body can error while other requests\n        // are inflight and indirectly error those as well.\n        // Ensure this doesn't happen by waiting for inflight\n        // to complete before dispatching.\n        // Request with stream or iterator body cannot be retried.\n        // Ensure that no other requests are inflight and\n        // could cause failure.\n        return;\n        if (!request.aborted && $5c97a5b8760057fe$var$write(client, request)) client[$5c97a5b8760057fe$require$kPendingIdx]++;\n        else client[$5c97a5b8760057fe$require$kQueue].splice(client[$5c97a5b8760057fe$require$kPendingIdx], 1);\n    }\n}\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction $5c97a5b8760057fe$var$shouldSendContentLength(method) {\n    return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT';\n}\nfunction $5c97a5b8760057fe$var$write(client, request) {\n    if (client[$5c97a5b8760057fe$require$kHTTPConnVersion] === 'h2') {\n        $5c97a5b8760057fe$var$writeH2(client, client[$5c97a5b8760057fe$require$kHTTP2Session], request);\n        return;\n    }\n    const { body: body, method: method, path: path, host: host, upgrade: upgrade, headers: headers, blocking: blocking, reset: reset } = request;\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n    if (body && typeof body.read === 'function') // Try to read EOF in order to get length.\n    body.read(0);\n    const bodyLength = $16nGk$pythonversioncheck7ed1514ejs.bodyLength(body);\n    let contentLength = bodyLength;\n    if (contentLength === null) contentLength = request.contentLength;\n    if (contentLength === 0 && !expectsPayload) // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n    contentLength = null;\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if ($5c97a5b8760057fe$var$shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n        if (client[$5c97a5b8760057fe$require$kStrictContentLength]) {\n            $5c97a5b8760057fe$var$errorRequest(client, request, new $5c97a5b8760057fe$require$RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new $5c97a5b8760057fe$require$RequestContentLengthMismatchError());\n    }\n    const socket = client[$5c97a5b8760057fe$require$kSocket];\n    try {\n        request.onConnect((err)=>{\n            if (request.aborted || request.completed) return;\n            $5c97a5b8760057fe$var$errorRequest(client, request, err || new $5c97a5b8760057fe$require$RequestAbortedError());\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, new $5c97a5b8760057fe$require$InformationalError('aborted'));\n        });\n    } catch (err) {\n        $5c97a5b8760057fe$var$errorRequest(client, request, err);\n    }\n    if (request.aborted) return false;\n    if (method === 'HEAD') // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n    socket[$5c97a5b8760057fe$require$kReset] = true;\n    if (upgrade || method === 'CONNECT') // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n    socket[$5c97a5b8760057fe$require$kReset] = true;\n    if (reset != null) socket[$5c97a5b8760057fe$require$kReset] = reset;\n    if (client[$5c97a5b8760057fe$require$kMaxRequests] && socket[$5c97a5b8760057fe$require$kCounter]++ >= client[$5c97a5b8760057fe$require$kMaxRequests]) socket[$5c97a5b8760057fe$require$kReset] = true;\n    if (blocking) socket[$5c97a5b8760057fe$require$kBlocking] = true;\n    let header = `${method} ${path} HTTP/1.1\\r\\n`;\n    if (typeof host === 'string') header += `host: ${host}\\r\\n`;\n    else header += client[$5c97a5b8760057fe$require$kHostHeader];\n    if (upgrade) header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n    else if (client[$5c97a5b8760057fe$require$kPipelining] && !socket[$5c97a5b8760057fe$require$kReset]) header += 'connection: keep-alive\\r\\n';\n    else header += 'connection: close\\r\\n';\n    if (headers) header += headers;\n    if ($5c97a5b8760057fe$var$channels.sendHeaders.hasSubscribers) $5c97a5b8760057fe$var$channels.sendHeaders.publish({\n        request: request,\n        headers: header,\n        socket: socket\n    });\n    /* istanbul ignore else: assertion */ if (!body || bodyLength === 0) {\n        if (contentLength === 0) socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n        else {\n            $16nGk$assert(contentLength === null, 'no body must not have content length');\n            socket.write(`${header}\\r\\n`, 'latin1');\n        }\n        request.onRequestSent();\n    } else if ($16nGk$pythonversioncheck7ed1514ejs5.isBuffer(body)) {\n        $16nGk$assert(contentLength === body.byteLength, 'buffer body must have content length');\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n        socket.write(body);\n        socket.uncork();\n        request.onBodySent(body);\n        request.onRequestSent();\n        if (!expectsPayload) socket[$5c97a5b8760057fe$require$kReset] = true;\n    } else if ($16nGk$pythonversioncheck7ed1514ejs4.isBlobLike(body)) {\n        if (typeof body.stream === 'function') $5c97a5b8760057fe$var$writeIterable({\n            body: body.stream(),\n            client: client,\n            request: request,\n            socket: socket,\n            contentLength: contentLength,\n            header: header,\n            expectsPayload: expectsPayload\n        });\n        else $5c97a5b8760057fe$var$writeBlob({\n            body: body,\n            client: client,\n            request: request,\n            socket: socket,\n            contentLength: contentLength,\n            header: header,\n            expectsPayload: expectsPayload\n        });\n    } else if ($16nGk$pythonversioncheck7ed1514ejs7.isStream(body)) $5c97a5b8760057fe$var$writeStream({\n        body: body,\n        client: client,\n        request: request,\n        socket: socket,\n        contentLength: contentLength,\n        header: header,\n        expectsPayload: expectsPayload\n    });\n    else if ($16nGk$pythonversioncheck7ed1514ejs6.isIterable(body)) $5c97a5b8760057fe$var$writeIterable({\n        body: body,\n        client: client,\n        request: request,\n        socket: socket,\n        contentLength: contentLength,\n        header: header,\n        expectsPayload: expectsPayload\n    });\n    else $16nGk$assert(false);\n    return true;\n}\nfunction $5c97a5b8760057fe$var$writeH2(client, session, request) {\n    const { body: body, method: method, path: path, host: host, upgrade: upgrade, expectContinue: expectContinue, signal: signal, headers: reqHeaders } = request;\n    let headers;\n    if (typeof reqHeaders === 'string') headers = $16nGk$pythonversioncheck2f514258js[$5c97a5b8760057fe$require$kHTTP2CopyHeaders](reqHeaders.trim());\n    else headers = reqHeaders;\n    if (upgrade) {\n        $5c97a5b8760057fe$var$errorRequest(client, request, new Error('Upgrade not supported for H2'));\n        return false;\n    }\n    try {\n        // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?\n        request.onConnect((err)=>{\n            if (request.aborted || request.completed) return;\n            $5c97a5b8760057fe$var$errorRequest(client, request, err || new $5c97a5b8760057fe$require$RequestAbortedError());\n        });\n    } catch (err) {\n        $5c97a5b8760057fe$var$errorRequest(client, request, err);\n    }\n    if (request.aborted) return false;\n    /** @type {import('node:http2').ClientHttp2Stream} */ let stream;\n    const h2State = client[$5c97a5b8760057fe$require$kHTTP2SessionState];\n    headers[$5c97a5b8760057fe$var$HTTP2_HEADER_AUTHORITY] = host || client[$5c97a5b8760057fe$require$kHost];\n    headers[$5c97a5b8760057fe$var$HTTP2_HEADER_METHOD] = method;\n    if (method === 'CONNECT') {\n        session.ref();\n        // we are already connected, streams are pending, first request\n        // will create a new stream. We trigger a request to create the stream and wait until\n        // `ready` event is triggered\n        // We disabled endStream to allow the user to write to the stream\n        stream = session.request(headers, {\n            endStream: false,\n            signal: signal\n        });\n        if (stream.id && !stream.pending) {\n            request.onUpgrade(null, null, stream);\n            ++h2State.openStreams;\n        } else stream.once('ready', ()=>{\n            request.onUpgrade(null, null, stream);\n            ++h2State.openStreams;\n        });\n        stream.once('close', ()=>{\n            h2State.openStreams -= 1;\n            // TODO(HTTP/2): unref only if current streams count is 0\n            if (h2State.openStreams === 0) session.unref();\n        });\n        return true;\n    }\n    // https://tools.ietf.org/html/rfc7540#section-8.3\n    // :path and :scheme headers must be omited when sending CONNECT\n    headers[$5c97a5b8760057fe$var$HTTP2_HEADER_PATH] = path;\n    headers[$5c97a5b8760057fe$var$HTTP2_HEADER_SCHEME] = 'https';\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n    if (body && typeof body.read === 'function') // Try to read EOF in order to get length.\n    body.read(0);\n    let contentLength = $16nGk$pythonversioncheck7ed1514ejs.bodyLength(body);\n    if (contentLength == null) contentLength = request.contentLength;\n    if (contentLength === 0 || !expectsPayload) // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n    contentLength = null;\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if ($5c97a5b8760057fe$var$shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n        if (client[$5c97a5b8760057fe$require$kStrictContentLength]) {\n            $5c97a5b8760057fe$var$errorRequest(client, request, new $5c97a5b8760057fe$require$RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new $5c97a5b8760057fe$require$RequestContentLengthMismatchError());\n    }\n    if (contentLength != null) {\n        $16nGk$assert(body, 'no body must not have content length');\n        headers[$5c97a5b8760057fe$var$HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;\n    }\n    session.ref();\n    const shouldEndStream = method === 'GET' || method === 'HEAD';\n    if (expectContinue) {\n        headers[$5c97a5b8760057fe$var$HTTP2_HEADER_EXPECT] = '100-continue';\n        stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal: signal\n        });\n        stream.once('continue', writeBodyH2);\n    } else {\n        stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal: signal\n        });\n        writeBodyH2();\n    }\n    // Increment counter as we have new several streams open\n    ++h2State.openStreams;\n    stream.once('response', (headers)=>{\n        const { [$5c97a5b8760057fe$var$HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;\n        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '') === false) stream.pause();\n    });\n    stream.once('end', ()=>{\n        request.onComplete([]);\n    });\n    stream.on('data', (chunk)=>{\n        if (request.onData(chunk) === false) stream.pause();\n    });\n    stream.once('close', ()=>{\n        h2State.openStreams -= 1;\n        // TODO(HTTP/2): unref only if current streams count is 0\n        if (h2State.openStreams === 0) session.unref();\n    });\n    stream.once('error', function(err) {\n        if (client[$5c97a5b8760057fe$require$kHTTP2Session] && !client[$5c97a5b8760057fe$require$kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n            h2State.streams -= 1;\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(stream, err);\n        }\n    });\n    stream.once('frameError', (type, code)=>{\n        const err = new $5c97a5b8760057fe$require$InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n        $5c97a5b8760057fe$var$errorRequest(client, request, err);\n        if (client[$5c97a5b8760057fe$require$kHTTP2Session] && !client[$5c97a5b8760057fe$require$kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n            h2State.streams -= 1;\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(stream, err);\n        }\n    });\n    // stream.on('aborted', () => {\n    //   // TODO(HTTP/2): Support aborted\n    // })\n    // stream.on('timeout', () => {\n    //   // TODO(HTTP/2): Support timeout\n    // })\n    // stream.on('push', headers => {\n    //   // TODO(HTTP/2): Suppor push\n    // })\n    // stream.on('trailers', headers => {\n    //   // TODO(HTTP/2): Support trailers\n    // })\n    return true;\n    function writeBodyH2() {\n        /* istanbul ignore else: assertion */ if (!body) request.onRequestSent();\n        else if ($16nGk$pythonversioncheck7ed1514ejs5.isBuffer(body)) {\n            $16nGk$assert(contentLength === body.byteLength, 'buffer body must have content length');\n            stream.cork();\n            stream.write(body);\n            stream.uncork();\n            stream.end();\n            request.onBodySent(body);\n            request.onRequestSent();\n        } else if ($16nGk$pythonversioncheck7ed1514ejs4.isBlobLike(body)) {\n            if (typeof body.stream === 'function') $5c97a5b8760057fe$var$writeIterable({\n                client: client,\n                request: request,\n                contentLength: contentLength,\n                h2stream: stream,\n                expectsPayload: expectsPayload,\n                body: body.stream(),\n                socket: client[$5c97a5b8760057fe$require$kSocket],\n                header: ''\n            });\n            else $5c97a5b8760057fe$var$writeBlob({\n                body: body,\n                client: client,\n                request: request,\n                contentLength: contentLength,\n                expectsPayload: expectsPayload,\n                h2stream: stream,\n                header: '',\n                socket: client[$5c97a5b8760057fe$require$kSocket]\n            });\n        } else if ($16nGk$pythonversioncheck7ed1514ejs7.isStream(body)) $5c97a5b8760057fe$var$writeStream({\n            body: body,\n            client: client,\n            request: request,\n            contentLength: contentLength,\n            expectsPayload: expectsPayload,\n            socket: client[$5c97a5b8760057fe$require$kSocket],\n            h2stream: stream,\n            header: ''\n        });\n        else if ($16nGk$pythonversioncheck7ed1514ejs6.isIterable(body)) $5c97a5b8760057fe$var$writeIterable({\n            body: body,\n            client: client,\n            request: request,\n            contentLength: contentLength,\n            expectsPayload: expectsPayload,\n            header: '',\n            h2stream: stream,\n            socket: client[$5c97a5b8760057fe$require$kSocket]\n        });\n        else $16nGk$assert(false);\n    }\n}\nfunction $5c97a5b8760057fe$var$writeStream({ h2stream: h2stream, body: body, client: client, request: request, socket: socket, contentLength: contentLength, header: header, expectsPayload: expectsPayload }) {\n    $16nGk$assert(contentLength !== 0 || client[$5c97a5b8760057fe$require$kRunning] === 0, 'stream body cannot be pipelined');\n    if (client[$5c97a5b8760057fe$require$kHTTPConnVersion] === 'h2') {\n        // For HTTP/2, is enough to pipe the stream\n        const pipe = $5c97a5b8760057fe$require$pipeline(body, h2stream, (err)=>{\n            if (err) {\n                $16nGk$pythonversioncheck7ed1514ejs1.destroy(body, err);\n                $16nGk$pythonversioncheck7ed1514ejs1.destroy(h2stream, err);\n            } else request.onRequestSent();\n        });\n        pipe.on('data', onPipeData);\n        pipe.once('end', ()=>{\n            pipe.removeListener('data', onPipeData);\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(pipe);\n        });\n        function onPipeData(chunk) {\n            request.onBodySent(chunk);\n        }\n        return;\n    }\n    let finished = false;\n    const writer = new $5c97a5b8760057fe$var$AsyncWriter({\n        socket: socket,\n        request: request,\n        contentLength: contentLength,\n        client: client,\n        expectsPayload: expectsPayload,\n        header: header\n    });\n    const onData = function(chunk) {\n        if (finished) return;\n        try {\n            if (!writer.write(chunk) && this.pause) this.pause();\n        } catch (err) {\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(this, err);\n        }\n    };\n    const onDrain = function() {\n        if (finished) return;\n        if (body.resume) body.resume();\n    };\n    const onAbort = function() {\n        if (finished) return;\n        const err = new $5c97a5b8760057fe$require$RequestAbortedError();\n        queueMicrotask(()=>onFinished(err));\n    };\n    const onFinished = function(err) {\n        if (finished) return;\n        finished = true;\n        $16nGk$assert(socket.destroyed || socket[$5c97a5b8760057fe$require$kWriting] && client[$5c97a5b8760057fe$require$kRunning] <= 1);\n        socket.off('drain', onDrain).off('error', onFinished);\n        body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);\n        if (!err) try {\n            writer.end();\n        } catch (er) {\n            err = er;\n        }\n        writer.destroy(err);\n        if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) $16nGk$pythonversioncheck7ed1514ejs1.destroy(body, err);\n        else $16nGk$pythonversioncheck7ed1514ejs1.destroy(body);\n    };\n    body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);\n    if (body.resume) body.resume();\n    socket.on('drain', onDrain).on('error', onFinished);\n}\nasync function $5c97a5b8760057fe$var$writeBlob({ h2stream: h2stream, body: body, client: client, request: request, socket: socket, contentLength: contentLength, header: header, expectsPayload: expectsPayload }) {\n    $16nGk$assert(contentLength === body.size, 'blob body must have content length');\n    const isH2 = client[$5c97a5b8760057fe$require$kHTTPConnVersion] === 'h2';\n    try {\n        if (contentLength != null && contentLength !== body.size) throw new $5c97a5b8760057fe$require$RequestContentLengthMismatchError();\n        const buffer = Buffer.from(await body.arrayBuffer());\n        if (isH2) {\n            h2stream.cork();\n            h2stream.write(buffer);\n            h2stream.uncork();\n        } else {\n            socket.cork();\n            socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n            socket.write(buffer);\n            socket.uncork();\n        }\n        request.onBodySent(buffer);\n        request.onRequestSent();\n        if (!expectsPayload) socket[$5c97a5b8760057fe$require$kReset] = true;\n        $5c97a5b8760057fe$var$resume(client);\n    } catch (err) {\n        $16nGk$pythonversioncheck7ed1514ejs1.destroy(isH2 ? h2stream : socket, err);\n    }\n}\nasync function $5c97a5b8760057fe$var$writeIterable({ h2stream: h2stream, body: body, client: client, request: request, socket: socket, contentLength: contentLength, header: header, expectsPayload: expectsPayload }) {\n    $16nGk$assert(contentLength !== 0 || client[$5c97a5b8760057fe$require$kRunning] === 0, 'iterator body cannot be pipelined');\n    let callback = null;\n    function onDrain() {\n        if (callback) {\n            const cb = callback;\n            callback = null;\n            cb();\n        }\n    }\n    const waitForDrain = ()=>new Promise((resolve, reject)=>{\n            $16nGk$assert(callback === null);\n            if (socket[$5c97a5b8760057fe$require$kError]) reject(socket[$5c97a5b8760057fe$require$kError]);\n            else callback = resolve;\n        });\n    if (client[$5c97a5b8760057fe$require$kHTTPConnVersion] === 'h2') {\n        h2stream.on('close', onDrain).on('drain', onDrain);\n        try {\n            // It's up to the user to somehow abort the async iterable.\n            for await (const chunk of body){\n                if (socket[$5c97a5b8760057fe$require$kError]) throw socket[$5c97a5b8760057fe$require$kError];\n                const res = h2stream.write(chunk);\n                request.onBodySent(chunk);\n                if (!res) await waitForDrain();\n            }\n        } catch (err) {\n            h2stream.destroy(err);\n        } finally{\n            request.onRequestSent();\n            h2stream.end();\n            h2stream.off('close', onDrain).off('drain', onDrain);\n        }\n        return;\n    }\n    socket.on('close', onDrain).on('drain', onDrain);\n    const writer = new $5c97a5b8760057fe$var$AsyncWriter({\n        socket: socket,\n        request: request,\n        contentLength: contentLength,\n        client: client,\n        expectsPayload: expectsPayload,\n        header: header\n    });\n    try {\n        // It's up to the user to somehow abort the async iterable.\n        for await (const chunk of body){\n            if (socket[$5c97a5b8760057fe$require$kError]) throw socket[$5c97a5b8760057fe$require$kError];\n            if (!writer.write(chunk)) await waitForDrain();\n        }\n        writer.end();\n    } catch (err) {\n        writer.destroy(err);\n    } finally{\n        socket.off('close', onDrain).off('drain', onDrain);\n    }\n}\nclass $5c97a5b8760057fe$var$AsyncWriter {\n    constructor({ socket: socket, request: request, contentLength: contentLength, client: client, expectsPayload: expectsPayload, header: header }){\n        this.socket = socket;\n        this.request = request;\n        this.contentLength = contentLength;\n        this.client = client;\n        this.bytesWritten = 0;\n        this.expectsPayload = expectsPayload;\n        this.header = header;\n        socket[$5c97a5b8760057fe$require$kWriting] = true;\n    }\n    write(chunk) {\n        const { socket: socket, request: request, contentLength: contentLength, client: client, bytesWritten: bytesWritten, expectsPayload: expectsPayload, header: header } = this;\n        if (socket[$5c97a5b8760057fe$require$kError]) throw socket[$5c97a5b8760057fe$require$kError];\n        if (socket.destroyed) return false;\n        const len = Buffer.byteLength(chunk);\n        if (!len) return true;\n        // We should defer writing chunks.\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n            if (client[$5c97a5b8760057fe$require$kStrictContentLength]) throw new $5c97a5b8760057fe$require$RequestContentLengthMismatchError();\n            process.emitWarning(new $5c97a5b8760057fe$require$RequestContentLengthMismatchError());\n        }\n        socket.cork();\n        if (bytesWritten === 0) {\n            if (!expectsPayload) socket[$5c97a5b8760057fe$require$kReset] = true;\n            if (contentLength === null) socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1');\n            else socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n        }\n        if (contentLength === null) socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1');\n        this.bytesWritten += len;\n        const ret = socket.write(chunk);\n        socket.uncork();\n        request.onBodySent(chunk);\n        if (!ret) {\n            if (socket[$5c97a5b8760057fe$require$kParser].timeout && socket[$5c97a5b8760057fe$require$kParser].timeoutType === $5c97a5b8760057fe$var$TIMEOUT_HEADERS) // istanbul ignore else: only for jest\n            {\n                if (socket[$5c97a5b8760057fe$require$kParser].timeout.refresh) socket[$5c97a5b8760057fe$require$kParser].timeout.refresh();\n            }\n        }\n        return ret;\n    }\n    end() {\n        const { socket: socket, contentLength: contentLength, client: client, bytesWritten: bytesWritten, expectsPayload: expectsPayload, header: header, request: request } = this;\n        request.onRequestSent();\n        socket[$5c97a5b8760057fe$require$kWriting] = false;\n        if (socket[$5c97a5b8760057fe$require$kError]) throw socket[$5c97a5b8760057fe$require$kError];\n        if (socket.destroyed) return;\n        if (bytesWritten === 0) {\n            if (expectsPayload) // https://tools.ietf.org/html/rfc7230#section-3.3.2\n            // A user agent SHOULD send a Content-Length in a request message when\n            // no Transfer-Encoding is sent and the request method defines a meaning\n            // for an enclosed payload body.\n            socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n            else socket.write(`${header}\\r\\n`, 'latin1');\n        } else if (contentLength === null) socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1');\n        if (contentLength !== null && bytesWritten !== contentLength) {\n            if (client[$5c97a5b8760057fe$require$kStrictContentLength]) throw new $5c97a5b8760057fe$require$RequestContentLengthMismatchError();\n            else process.emitWarning(new $5c97a5b8760057fe$require$RequestContentLengthMismatchError());\n        }\n        if (socket[$5c97a5b8760057fe$require$kParser].timeout && socket[$5c97a5b8760057fe$require$kParser].timeoutType === $5c97a5b8760057fe$var$TIMEOUT_HEADERS) // istanbul ignore else: only for jest\n        {\n            if (socket[$5c97a5b8760057fe$require$kParser].timeout.refresh) socket[$5c97a5b8760057fe$require$kParser].timeout.refresh();\n        }\n        $5c97a5b8760057fe$var$resume(client);\n    }\n    destroy(err) {\n        const { socket: socket, client: client } = this;\n        socket[$5c97a5b8760057fe$require$kWriting] = false;\n        if (err) {\n            $16nGk$assert(client[$5c97a5b8760057fe$require$kRunning] <= 1, 'pipeline should only contain this request');\n            $16nGk$pythonversioncheck7ed1514ejs1.destroy(socket, err);\n        }\n    }\n}\nfunction $5c97a5b8760057fe$var$errorRequest(client, request, err) {\n    try {\n        request.onError(err);\n        $16nGk$assert(request.aborted);\n    } catch (err) {\n        client.emit('error', err);\n    }\n}\n$5c97a5b8760057fe$exports = $5c97a5b8760057fe$var$Client;\n\n\nexport {$5c97a5b8760057fe$exports as default};\n//# sourceMappingURL=python-version-check.171f2d6c.js.map\n","// @ts-check\n\n'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst http = require('http')\nconst { pipeline } = require('stream')\nconst util = require('./core/util')\nconst timers = require('./timers')\nconst Request = require('./core/request')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError,\n  ClientDestroyedError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kHTTPConnVersion,\n  // HTTP2\n  kHost,\n  kHTTP2Session,\n  kHTTP2SessionState,\n  kHTTP2BuildRequest,\n  kHTTP2CopyHeaders,\n  kHTTP1BuildRequest\n} = require('./core/symbols')\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = require('http2')\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\n// Experimental\nlet h2ExperimentalWarned = false\n\nconst FastBuffer = Buffer[Symbol.species]\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\n/**\n * @type {import('../types/client').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    allowH2,\n    maxConcurrentStreams\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)\n      ? interceptors.Client\n      : [createRedirectInterceptor({ maxRedirections })]\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kHTTPConnVersion] = 'h1'\n\n    // HTTP/2\n    this[kHTTP2Session] = null\n    this[kHTTP2SessionState] = !allowH2\n      ? null\n      : {\n        // streams: null, // Fixed queue of streams - For future support of `push`\n          openStreams: 0, // Keep track of them to decide wether or not unref the session\n          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n        }\n    this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n\n    const request = this[kHTTPConnVersion] === 'h2'\n      ? Request[kHTTP2BuildRequest](origin, opts, handler)\n      : Request[kHTTP1BuildRequest](origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      process.nextTick(resume, this)\n    } else {\n      resume(this, true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (!this[kSize]) {\n        resolve(null)\n      } else {\n        this[kClosedResolve] = resolve\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve()\n      }\n\n      if (this[kHTTP2Session] != null) {\n        util.destroy(this[kHTTP2Session], err)\n        this[kHTTP2Session] = null\n        this[kHTTP2SessionState] = null\n      }\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback)\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err)\n      }\n\n      resume(this)\n    })\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n\n  if (id === 0) {\n    this[kSocket][kError] = err\n    onError(this[kClient], err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  util.destroy(this, new SocketError('other side closed'))\n  util.destroy(this[kSocket], new SocketError('other side closed'))\n}\n\nfunction onHTTP2GoAway (code) {\n  const client = this[kClient]\n  const err = new InformationalError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`)\n  client[kSocket] = null\n  client[kHTTP2Session] = null\n\n  if (client.destroyed) {\n    assert(this[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(this, request, err)\n    }\n  } else if (client[kRunning] > 0) {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect',\n    client[kUrl],\n    [client],\n    err\n  )\n\n  resume(client)\n}\n\nconst constants = require('./llhttp/constants')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp-wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd-wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp-wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message =\n            'Response does not match the HTTP/1.1 protocol (' +\n            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n            ')'\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {\n      this.connection += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client)\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  if (parser) {\n    parser.readMore()\n  }\n}\n\nfunction onSocketError (err) {\n  const { [kClient]: client, [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  if (client[kHTTPConnVersion] !== 'h2') {\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser, [kClient]: client } = this\n\n  if (client[kHTTPConnVersion] !== 'h2') {\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client, [kParser]: parser } = this\n\n  if (client[kHTTPConnVersion] === 'h1' && parser) {\n    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n    }\n\n    this[kParser].destroy()\n    this[kParser] = null\n  }\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError())\n      return\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    const isH2 = socket.alpnProtocol === 'h2'\n    if (isH2) {\n      if (!h2ExperimentalWarned) {\n        h2ExperimentalWarned = true\n        process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n          code: 'UNDICI-H2'\n        })\n      }\n\n      const session = http2.connect(client[kUrl], {\n        createConnection: () => socket,\n        peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams\n      })\n\n      client[kHTTPConnVersion] = 'h2'\n      session[kClient] = client\n      session[kSocket] = socket\n      session.on('error', onHttp2SessionError)\n      session.on('frameError', onHttp2FrameError)\n      session.on('end', onHttp2SessionEnd)\n      session.on('goaway', onHTTP2GoAway)\n      session.on('close', onSocketClose)\n      session.unref()\n\n      client[kHTTP2Session] = session\n      socket[kHTTP2Session] = session\n    } else {\n      if (!llhttpInstance) {\n        llhttpInstance = await llhttpPromise\n        llhttpPromise = null\n      }\n\n      socket[kNoRef] = false\n      socket[kWriting] = false\n      socket[kReset] = false\n      socket[kBlocking] = false\n      socket[kParser] = new Parser(client, socket, llhttpInstance)\n    }\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    client[kSocket] = socket\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    const socket = client[kSocket]\n\n    if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket && !client[kHTTP2Session]) {\n      connect(client)\n      return\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction write (client, request) {\n  if (client[kHTTPConnVersion] === 'h2') {\n    writeH2(client, client[kHTTP2Session], request)\n    return\n  }\n\n  const { body, method, path, host, upgrade, headers, blocking, reset } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  let contentLength = bodyLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'latin1')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeH2 (client, session, request) {\n  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request\n\n  let headers\n  if (typeof reqHeaders === 'string') headers = Request[kHTTP2CopyHeaders](reqHeaders.trim())\n  else headers = reqHeaders\n\n  if (upgrade) {\n    errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  try {\n    // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream\n  const h2State = client[kHTTP2SessionState]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost]\n  headers[HTTP2_HEADER_METHOD] = method\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // we are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++h2State.openStreams\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++h2State.openStreams\n      })\n    }\n\n    stream.once('close', () => {\n      h2State.openStreams -= 1\n      // TODO(HTTP/2): unref only if current streams count is 0\n      if (h2State.openStreams === 0) session.unref()\n    })\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omited when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  const shouldEndStream = method === 'GET' || method === 'HEAD'\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new several streams open\n  ++h2State.openStreams\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n\n    if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n  })\n\n  stream.once('end', () => {\n    request.onComplete([])\n  })\n\n  stream.on('data', (chunk) => {\n    if (request.onData(chunk) === false) {\n      stream.pause()\n    }\n  })\n\n  stream.once('close', () => {\n    h2State.openStreams -= 1\n    // TODO(HTTP/2): unref only if current streams count is 0\n    if (h2State.openStreams === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n      h2State.streams -= 1\n      util.destroy(stream, err)\n    }\n  })\n\n  stream.once('frameError', (type, code) => {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    errorRequest(client, request, err)\n\n    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n      h2State.streams -= 1\n      util.destroy(stream, err)\n    }\n  })\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Suppor push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body) {\n      request.onRequestSent()\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      stream.cork()\n      stream.write(body)\n      stream.uncork()\n      stream.end()\n      request.onBodySent(body)\n      request.onRequestSent()\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable({\n          client,\n          request,\n          contentLength,\n          h2stream: stream,\n          expectsPayload,\n          body: body.stream(),\n          socket: client[kSocket],\n          header: ''\n        })\n      } else {\n        writeBlob({\n          body,\n          client,\n          request,\n          contentLength,\n          expectsPayload,\n          h2stream: stream,\n          header: '',\n          socket: client[kSocket]\n        })\n      }\n    } else if (util.isStream(body)) {\n      writeStream({\n        body,\n        client,\n        request,\n        contentLength,\n        expectsPayload,\n        socket: client[kSocket],\n        h2stream: stream,\n        header: ''\n      })\n    } else if (util.isIterable(body)) {\n      writeIterable({\n        body,\n        client,\n        request,\n        contentLength,\n        expectsPayload,\n        header: '',\n        h2stream: stream,\n        socket: client[kSocket]\n      })\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeStream ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  if (client[kHTTPConnVersion] === 'h2') {\n    // For HTTP/2, is enough to pipe the stream\n    const pipe = pipeline(\n      body,\n      h2stream,\n      (err) => {\n        if (err) {\n          util.destroy(body, err)\n          util.destroy(h2stream, err)\n        } else {\n          request.onRequestSent()\n        }\n      }\n    )\n\n    pipe.on('data', onPipeData)\n    pipe.once('end', () => {\n      pipe.removeListener('data', onPipeData)\n      util.destroy(pipe)\n    })\n\n    function onPipeData (chunk) {\n      request.onBodySent(chunk)\n    }\n\n    return\n  }\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    if (finished) {\n      return\n    }\n    const err = new RequestAbortedError()\n    queueMicrotask(() => onFinished(err))\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  const isH2 = client[kHTTPConnVersion] === 'h2'\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    if (isH2) {\n      h2stream.cork()\n      h2stream.write(buffer)\n      h2stream.uncork()\n    } else {\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(buffer)\n      socket.uncork()\n    }\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(isH2 ? h2stream : socket, err)\n  }\n}\n\nasync function writeIterable ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  if (client[kHTTPConnVersion] === 'h2') {\n    h2stream\n      .on('close', onDrain)\n      .on('drain', onDrain)\n\n    try {\n      // It's up to the user to somehow abort the async iterable.\n      for await (const chunk of body) {\n        if (socket[kError]) {\n          throw socket[kError]\n        }\n\n        const res = h2stream.write(chunk)\n        request.onBodySent(chunk)\n        if (!res) {\n          await waitForDrain()\n        }\n      }\n    } catch (err) {\n      h2stream.destroy(err)\n    } finally {\n      request.onRequestSent()\n      h2stream.end()\n      h2stream\n        .off('close', onDrain)\n        .off('drain', onDrain)\n    }\n\n    return\n  }\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n"],"names":["$5c97a5b8760057fe$var$http2","$16nGk$pythonversioncheck7ed1514ejs10","$16nGk$pythonversioncheck715a24bajs1","$16nGk$pythonversioncheck2f514258js","$16nGk$pythonversioncheck8185b27fjs","$16nGk$pythonversioncheckdba5a2d4js11","$16nGk$pythonversioncheck091f3542js","$16nGk$pythonversioncheckebf2a848js48","$16nGk$pythonversioncheck67e8c7c6js1","$16nGk$pythonversioncheckdb32945bjs","$16nGk$pythonversionchecke57c179ejs","$16nGk$pythonversioncheckf30ce740js","$16nGk$assert","isIP","$16nGk$isIP","maxHeaderSize","$16nGk$maxHeaderSize","pipeline","$16nGk$pipeline","$5c97a5b8760057fe$exports","$5c97a5b8760057fe$require$RequestContentLengthMismatchError","$16nGk$pythonversioncheckdba5a2d4js8","RequestContentLengthMismatchError","$5c97a5b8760057fe$require$ResponseContentLengthMismatchError","$16nGk$pythonversioncheckdba5a2d4js9","ResponseContentLengthMismatchError","$5c97a5b8760057fe$require$InvalidArgumentError","$16nGk$pythonversioncheckdba5a2d4js6","InvalidArgumentError","$5c97a5b8760057fe$require$RequestAbortedError","$16nGk$pythonversioncheckdba5a2d4js7","RequestAbortedError","$5c97a5b8760057fe$require$HeadersTimeoutError","$16nGk$pythonversioncheckdba5a2d4js3","HeadersTimeoutError","$5c97a5b8760057fe$require$HeadersOverflowError","$16nGk$pythonversioncheckdba5a2d4js2","HeadersOverflowError","$5c97a5b8760057fe$require$SocketError","SocketError","$5c97a5b8760057fe$require$InformationalError","$16nGk$pythonversioncheckdba5a2d4js5","InformationalError","$5c97a5b8760057fe$require$BodyTimeoutError","$16nGk$pythonversioncheckdba5a2d4js","BodyTimeoutError","$5c97a5b8760057fe$require$HTTPParserError","$16nGk$pythonversioncheckdba5a2d4js4","HTTPParserError","$5c97a5b8760057fe$require$ResponseExceededMaxSizeError","$16nGk$pythonversioncheckdba5a2d4js10","ResponseExceededMaxSizeError","$5c97a5b8760057fe$require$ClientDestroyedError","$16nGk$pythonversioncheckdba5a2d4js1","ClientDestroyedError","$5c97a5b8760057fe$require$kUrl","$16nGk$pythonversioncheckebf2a848js47","kUrl","$5c97a5b8760057fe$require$kReset","$16nGk$pythonversioncheckebf2a848js39","kReset","$5c97a5b8760057fe$require$kServerName","$16nGk$pythonversioncheckebf2a848js43","kServerName","$5c97a5b8760057fe$require$kClient","$16nGk$pythonversioncheckebf2a848js3","kClient","$5c97a5b8760057fe$require$kBusy","$16nGk$pythonversioncheckebf2a848js2","kBusy","$5c97a5b8760057fe$require$kParser","$16nGk$pythonversioncheckebf2a848js34","kParser","$5c97a5b8760057fe$require$kConnect","$16nGk$pythonversioncheckebf2a848js5","kConnect","$5c97a5b8760057fe$require$kBlocking","$16nGk$pythonversioncheckebf2a848js","kBlocking","$5c97a5b8760057fe$require$kResuming","$16nGk$pythonversioncheckebf2a848js40","kResuming","$5c97a5b8760057fe$require$kRunning","$16nGk$pythonversioncheckebf2a848js41","kRunning","$5c97a5b8760057fe$require$kPending","$16nGk$pythonversioncheckebf2a848js35","kPending","$5c97a5b8760057fe$require$kSize","$16nGk$pythonversioncheckebf2a848js44","kSize","$5c97a5b8760057fe$require$kWriting","kWriting","$5c97a5b8760057fe$require$kQueue","$16nGk$pythonversioncheckebf2a848js38","kQueue","$5c97a5b8760057fe$require$kConnected","$16nGk$pythonversioncheckebf2a848js6","kConnected","$5c97a5b8760057fe$require$kConnecting","$16nGk$pythonversioncheckebf2a848js7","kConnecting","$5c97a5b8760057fe$require$kNeedDrain","$16nGk$pythonversioncheckebf2a848js32","kNeedDrain","$5c97a5b8760057fe$require$kNoRef","$16nGk$pythonversioncheckebf2a848js33","kNoRef","$5c97a5b8760057fe$require$kKeepAliveDefaultTimeout","$16nGk$pythonversioncheckebf2a848js23","kKeepAliveDefaultTimeout","$5c97a5b8760057fe$require$kHostHeader","$16nGk$pythonversioncheckebf2a848js15","kHostHeader","$5c97a5b8760057fe$require$kPendingIdx","$16nGk$pythonversioncheckebf2a848js36","kPendingIdx","$5c97a5b8760057fe$require$kRunningIdx","$16nGk$pythonversioncheckebf2a848js42","kRunningIdx","$5c97a5b8760057fe$require$kError","$16nGk$pythonversioncheckebf2a848js12","kError","$5c97a5b8760057fe$require$kPipelining","$16nGk$pythonversioncheckebf2a848js37","kPipelining","$5c97a5b8760057fe$require$kSocket","$16nGk$pythonversioncheckebf2a848js45","kSocket","$5c97a5b8760057fe$require$kKeepAliveTimeoutValue","$16nGk$pythonversioncheckebf2a848js26","kKeepAliveTimeoutValue","$5c97a5b8760057fe$require$kMaxHeadersSize","$16nGk$pythonversioncheckebf2a848js28","kMaxHeadersSize","$5c97a5b8760057fe$require$kKeepAliveMaxTimeout","$16nGk$pythonversioncheckebf2a848js24","kKeepAliveMaxTimeout","$5c97a5b8760057fe$require$kKeepAliveTimeoutThreshold","$16nGk$pythonversioncheckebf2a848js25","kKeepAliveTimeoutThreshold","$5c97a5b8760057fe$require$kHeadersTimeout","$16nGk$pythonversioncheckebf2a848js13","kHeadersTimeout","$5c97a5b8760057fe$require$kBodyTimeout","$16nGk$pythonversioncheckebf2a848js1","kBodyTimeout","$5c97a5b8760057fe$require$kStrictContentLength","$16nGk$pythonversioncheckebf2a848js46","kStrictContentLength","$5c97a5b8760057fe$require$kConnector","$16nGk$pythonversioncheckebf2a848js8","kConnector","$5c97a5b8760057fe$require$kMaxRedirections","$16nGk$pythonversioncheckebf2a848js29","kMaxRedirections","$5c97a5b8760057fe$require$kMaxRequests","$16nGk$pythonversioncheckebf2a848js30","kMaxRequests","$5c97a5b8760057fe$require$kCounter","$16nGk$pythonversioncheckebf2a848js9","kCounter","$5c97a5b8760057fe$require$kClose","$16nGk$pythonversioncheckebf2a848js4","kClose","$5c97a5b8760057fe$require$kDestroy","$16nGk$pythonversioncheckebf2a848js10","kDestroy","$5c97a5b8760057fe$require$kDispatch","$16nGk$pythonversioncheckebf2a848js11","kDispatch","$5c97a5b8760057fe$require$kInterceptors","$16nGk$pythonversioncheckebf2a848js22","kInterceptors","$5c97a5b8760057fe$require$kLocalAddress","$16nGk$pythonversioncheckebf2a848js27","kLocalAddress","$5c97a5b8760057fe$require$kMaxResponseSize","$16nGk$pythonversioncheckebf2a848js31","kMaxResponseSize","$5c97a5b8760057fe$require$kHTTPConnVersion","$16nGk$pythonversioncheckebf2a848js21","kHTTPConnVersion","$5c97a5b8760057fe$require$kHost","$16nGk$pythonversioncheckebf2a848js14","kHost","$5c97a5b8760057fe$require$kHTTP2Session","$16nGk$pythonversioncheckebf2a848js19","kHTTP2Session","$5c97a5b8760057fe$require$kHTTP2SessionState","$16nGk$pythonversioncheckebf2a848js20","kHTTP2SessionState","$5c97a5b8760057fe$require$kHTTP2BuildRequest","$16nGk$pythonversioncheckebf2a848js17","kHTTP2BuildRequest","$5c97a5b8760057fe$require$kHTTP2CopyHeaders","$16nGk$pythonversioncheckebf2a848js18","kHTTP2CopyHeaders","$5c97a5b8760057fe$require$kHTTP1BuildRequest","$16nGk$pythonversioncheckebf2a848js16","kHTTP1BuildRequest","$5c97a5b8760057fe$import$7690c58d6bf1df8f","constants","HTTP2_HEADER_AUTHORITY","$5c97a5b8760057fe$var$HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_METHOD","$5c97a5b8760057fe$var$HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","$5c97a5b8760057fe$var$HTTP2_HEADER_PATH","HTTP2_HEADER_SCHEME","$5c97a5b8760057fe$var$HTTP2_HEADER_SCHEME","HTTP2_HEADER_CONTENT_LENGTH","$5c97a5b8760057fe$var$HTTP2_HEADER_CONTENT_LENGTH","HTTP2_HEADER_EXPECT","$5c97a5b8760057fe$var$HTTP2_HEADER_EXPECT","HTTP2_HEADER_STATUS","$5c97a5b8760057fe$var$HTTP2_HEADER_STATUS","$5c97a5b8760057fe$var$h2ExperimentalWarned","$5c97a5b8760057fe$var$FastBuffer","Buffer","Symbol","species","$5c97a5b8760057fe$var$kClosedResolve","$5c97a5b8760057fe$var$channels","diagnosticsChannel","$5c97a5b8760057fe$import$b63e509c7dd4e53f","sendHeaders","channel","beforeConnect","connectError","connected","hasSubscribers","$5c97a5b8760057fe$var$onHttp2SessionError","err","code","$5c97a5b8760057fe$var$onError","$5c97a5b8760057fe$var$onHttp2FrameError","type","id","$5c97a5b8760057fe$var$onHttp2SessionEnd","$16nGk$pythonversioncheck7ed1514ejs1","destroy","$5c97a5b8760057fe$var$onHTTP2GoAway","client","destroyed","requests","splice","i","length","$5c97a5b8760057fe$var$errorRequest","request","emit","$5c97a5b8760057fe$var$resume","$5c97a5b8760057fe$var$EMPTY_BUF","alloc","$5c97a5b8760057fe$var$llhttpInstance","$5c97a5b8760057fe$var$llhttpPromise","$5c97a5b8760057fe$var$lazyllhttp","mod","llhttpWasmData","process","env","JEST_WORKER_ID","undefined","WebAssembly","compile","from","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","$5c97a5b8760057fe$var$currentParser","ptr","start","$5c97a5b8760057fe$var$currentBufferPtr","$5c97a5b8760057fe$var$currentBufferRef","byteOffset","onStatus","buffer","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","catch","$5c97a5b8760057fe$var$currentBufferSize","$5c97a5b8760057fe$var$Parser","socket","exports","Number","isFinite","llhttp","llhttp_alloc","TYPE","RESPONSE","timeout","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","resume","bind","bytesRead","keepAlive","contentLength","connection","maxResponseSize","setTimeout","value","$16nGk$pythonversioncheck715a24bajs","clearTimeout","$5c97a5b8760057fe$var$onParserTimeout","unref","refresh","llhttp_resume","execute","read","readMore","chunk","data","free","Math","ceil","malloc","Uint8Array","memory","set","ret","llhttp_execute","offset","llhttp_get_error_pos","$16nGk$pythonversioncheck67e8c7c6js","ERROR","PAUSED_UPGRADE","onUpgrade","slice","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","toString","llhttp_free","buf","push","concat","trackHeader","key","toLowerCase","head","method","removeListener","$5c97a5b8760057fe$var$onSocketError","$5c97a5b8760057fe$var$onSocketReadable","$5c97a5b8760057fe$var$onSocketEnd","$5c97a5b8760057fe$var$onSocketClose","$16nGk$pythonversioncheck7ed1514ejs2","getSocketInfo","bodyTimeout","keepAliveTimeout","$16nGk$pythonversioncheck7ed1514ejs9","parseKeepAliveTimeout","min","pause","onHeaders","aborted","onData","parseInt","onComplete","setImmediate","parser","writableNeedDrain","$5c97a5b8760057fe$var$connect","host","hostname","protocol","port","idx","ip","substring","publish","connectParams","servername","localAddress","connector","Promise","resolve","reject","on","alpnProtocol","emitWarning","session","connect","createConnection","peerMaxConcurrentStreams","maxConcurrentStreams","error","$5c97a5b8760057fe$var$emitDrain","sync","$5c97a5b8760057fe$var$_resume","ref","headersTimeout","nextTick","idempotent","$16nGk$pythonversioncheck7ed1514ejs","bodyLength","body","$16nGk$pythonversioncheck7ed1514ejs7","isStream","$16nGk$pythonversioncheck7ed1514ejs3","isAsyncIterable","$5c97a5b8760057fe$var$write","$5c97a5b8760057fe$var$writeH2","stream","path","expectContinue","signal","reqHeaders","trim","Error","onConnect","completed","h2State","endStream","pending","openStreams","once","expectsPayload","$5c97a5b8760057fe$var$shouldSendContentLength","shouldEndStream","writeBodyH2","realHeaders","closed","streams","$16nGk$pythonversioncheck7ed1514ejs5","isBuffer","byteLength","cork","write","uncork","end","onBodySent","onRequestSent","$16nGk$pythonversioncheck7ed1514ejs4","isBlobLike","$5c97a5b8760057fe$var$writeIterable","h2stream","header","$5c97a5b8760057fe$var$writeBlob","$5c97a5b8760057fe$var$writeStream","$16nGk$pythonversioncheck7ed1514ejs6","isIterable","blocking","reset","pipe","$5c97a5b8760057fe$require$pipeline","onPipeData","finished","writer","$5c97a5b8760057fe$var$AsyncWriter","onDrain","onAbort","queueMicrotask","onFinished","off","er","size","isH2","arrayBuffer","callback","cb","waitForDrain","res","bytesWritten","onError","url","interceptors","socketTimeout","requestTimeout","connectTimeout","idleTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","maxRequestsPerClient","autoSelectFamily","autoSelectFamilyAttemptTimeout","allowH2","isInteger","$16nGk$pythonversioncheck7ed1514ejs8","nodeHasAutoSelectFamily","Client","Array","isArray","parseOrigin","opts","handler","origin","default"],"version":3,"file":"python-version-check.171f2d6c.js.map","sourceRoot":"../"}