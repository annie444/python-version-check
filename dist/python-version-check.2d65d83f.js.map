{"mappings":"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","sources":["<anon>","node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"],"sourcesContent":["import {EventEmitter as $dfzmk$EventEmitter} from \"node:events\";\nimport {inherits as $dfzmk$inherits} from \"node:util\";\n\nvar $b3561955aa1940ac$exports = {};\n'use strict';\n\nvar $b3561955aa1940ac$require$EventEmitter = $dfzmk$EventEmitter;\n\nvar $b3561955aa1940ac$require$inherits = $dfzmk$inherits;\nfunction $b3561955aa1940ac$var$SBMH(needle) {\n    if (typeof needle === 'string') needle = Buffer.from(needle);\n    if (!Buffer.isBuffer(needle)) throw new TypeError('The needle has to be a String or a Buffer.');\n    const needleLength = needle.length;\n    if (needleLength === 0) throw new Error('The needle cannot be an empty String/Buffer.');\n    if (needleLength > 256) throw new Error('The needle cannot have a length bigger than 256.');\n    this.maxMatches = Infinity;\n    this.matches = 0;\n    this._occ = new Array(256).fill(needleLength) // Initialize occurrence table.\n    ;\n    this._lookbehind_size = 0;\n    this._needle = needle;\n    this._bufpos = 0;\n    this._lookbehind = Buffer.alloc(needleLength);\n    // Populate occurrence table with analysis of the needle,\n    // ignoring last letter.\n    for(var i = 0; i < needleLength - 1; ++i)this._occ[needle[i]] = needleLength - 1 - i;\n}\n$b3561955aa1940ac$require$inherits($b3561955aa1940ac$var$SBMH, $b3561955aa1940ac$require$EventEmitter);\n$b3561955aa1940ac$var$SBMH.prototype.reset = function() {\n    this._lookbehind_size = 0;\n    this.matches = 0;\n    this._bufpos = 0;\n};\n$b3561955aa1940ac$var$SBMH.prototype.push = function(chunk, pos) {\n    if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, 'binary');\n    const chlen = chunk.length;\n    this._bufpos = pos || 0;\n    let r;\n    while(r !== chlen && this.matches < this.maxMatches)r = this._sbmh_feed(chunk);\n    return r;\n};\n$b3561955aa1940ac$var$SBMH.prototype._sbmh_feed = function(data) {\n    const len = data.length;\n    const needle = this._needle;\n    const needleLength = needle.length;\n    const lastNeedleChar = needle[needleLength - 1];\n    // Positive: points to a position in `data`\n    //           pos == 3 points to data[3]\n    // Negative: points to a position in the lookbehind buffer\n    //           pos == -2 points to lookbehind[lookbehind_size - 2]\n    let pos = -this._lookbehind_size;\n    let ch;\n    if (pos < 0) {\n        // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n        // search with character lookup code that considers both the\n        // lookbehind buffer and the current round's haystack data.\n        //\n        // Loop until\n        //   there is a match.\n        // or until\n        //   we've moved past the position that requires the\n        //   lookbehind buffer. In this case we switch to the\n        //   optimized loop.\n        // or until\n        //   the character to look at lies outside the haystack.\n        while(pos < 0 && pos <= len - needleLength){\n            ch = this._sbmh_lookup_char(data, pos + needleLength - 1);\n            if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {\n                this._lookbehind_size = 0;\n                ++this.matches;\n                this.emit('info', true);\n                return this._bufpos = pos + needleLength;\n            }\n            pos += this._occ[ch];\n        }\n        // No match.\n        if (pos < 0) // There's too few data for Boyer-Moore-Horspool to run,\n        // so let's use a different algorithm to skip as much as\n        // we can.\n        // Forward pos until\n        //   the trailing part of lookbehind + data\n        //   looks like the beginning of the needle\n        // or until\n        //   pos == 0\n        while(pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))++pos;\n        if (pos >= 0) {\n            // Discard lookbehind buffer.\n            this.emit('info', false, this._lookbehind, 0, this._lookbehind_size);\n            this._lookbehind_size = 0;\n        } else {\n            // Cut off part of the lookbehind buffer that has\n            // been processed and append the entire haystack\n            // into it.\n            const bytesToCutOff = this._lookbehind_size + pos;\n            if (bytesToCutOff > 0) // The cut off data is guaranteed not to contain the needle.\n            this.emit('info', false, this._lookbehind, 0, bytesToCutOff);\n            this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);\n            this._lookbehind_size -= bytesToCutOff;\n            data.copy(this._lookbehind, this._lookbehind_size);\n            this._lookbehind_size += len;\n            this._bufpos = len;\n            return len;\n        }\n    }\n    pos += (pos >= 0) * this._bufpos;\n    // Lookbehind buffer is now empty. We only need to check if the\n    // needle is in the haystack.\n    if (data.indexOf(needle, pos) !== -1) {\n        pos = data.indexOf(needle, pos);\n        ++this.matches;\n        if (pos > 0) this.emit('info', true, data, this._bufpos, pos);\n        else this.emit('info', true);\n        return this._bufpos = pos + needleLength;\n    } else pos = len - needleLength;\n    // There was no match. If there's trailing haystack data that we cannot\n    // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n    // data is less than the needle size) then match using a modified\n    // algorithm that starts matching from the beginning instead of the end.\n    // Whatever trailing data is left after running this algorithm is added to\n    // the lookbehind buffer.\n    while(pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0))++pos;\n    if (pos < len) {\n        data.copy(this._lookbehind, 0, pos, pos + (len - pos));\n        this._lookbehind_size = len - pos;\n    }\n    // Everything until pos is guaranteed not to contain needle data.\n    if (pos > 0) this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n    this._bufpos = len;\n    return len;\n};\n$b3561955aa1940ac$var$SBMH.prototype._sbmh_lookup_char = function(data, pos) {\n    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];\n};\n$b3561955aa1940ac$var$SBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n    for(var i = 0; i < len; ++i){\n        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) return false;\n    }\n    return true;\n};\n$b3561955aa1940ac$exports = $b3561955aa1940ac$var$SBMH;\n\n\nexport {$b3561955aa1940ac$exports as default};\n//# sourceMappingURL=python-version-check.2d65d83f.js.map\n","'use strict'\n\n/**\n * Copyright Brian White. All rights reserved.\n *\n * @see https://github.com/mscdex/streamsearch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n */\nconst EventEmitter = require('node:events').EventEmitter\nconst inherits = require('node:util').inherits\n\nfunction SBMH (needle) {\n  if (typeof needle === 'string') {\n    needle = Buffer.from(needle)\n  }\n\n  if (!Buffer.isBuffer(needle)) {\n    throw new TypeError('The needle has to be a String or a Buffer.')\n  }\n\n  const needleLength = needle.length\n\n  if (needleLength === 0) {\n    throw new Error('The needle cannot be an empty String/Buffer.')\n  }\n\n  if (needleLength > 256) {\n    throw new Error('The needle cannot have a length bigger than 256.')\n  }\n\n  this.maxMatches = Infinity\n  this.matches = 0\n\n  this._occ = new Array(256)\n    .fill(needleLength) // Initialize occurrence table.\n  this._lookbehind_size = 0\n  this._needle = needle\n  this._bufpos = 0\n\n  this._lookbehind = Buffer.alloc(needleLength)\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  for (var i = 0; i < needleLength - 1; ++i) { // eslint-disable-line no-var\n    this._occ[needle[i]] = needleLength - 1 - i\n  }\n}\ninherits(SBMH, EventEmitter)\n\nSBMH.prototype.reset = function () {\n  this._lookbehind_size = 0\n  this.matches = 0\n  this._bufpos = 0\n}\n\nSBMH.prototype.push = function (chunk, pos) {\n  if (!Buffer.isBuffer(chunk)) {\n    chunk = Buffer.from(chunk, 'binary')\n  }\n  const chlen = chunk.length\n  this._bufpos = pos || 0\n  let r\n  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk) }\n  return r\n}\n\nSBMH.prototype._sbmh_feed = function (data) {\n  const len = data.length\n  const needle = this._needle\n  const needleLength = needle.length\n  const lastNeedleChar = needle[needleLength - 1]\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  let pos = -this._lookbehind_size\n  let ch\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needleLength) {\n      ch = this._sbmh_lookup_char(data, pos + needleLength - 1)\n\n      if (\n        ch === lastNeedleChar &&\n        this._sbmh_memcmp(data, pos, needleLength - 1)\n      ) {\n        this._lookbehind_size = 0\n        ++this.matches\n        this.emit('info', true)\n\n        return (this._bufpos = pos + needleLength)\n      }\n      pos += this._occ[ch]\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) { ++pos }\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size)\n      this._lookbehind_size = 0\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      const bytesToCutOff = this._lookbehind_size + pos\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, this._lookbehind, 0, bytesToCutOff)\n      }\n\n      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff,\n        this._lookbehind_size - bytesToCutOff)\n      this._lookbehind_size -= bytesToCutOff\n\n      data.copy(this._lookbehind, this._lookbehind_size)\n      this._lookbehind_size += len\n\n      this._bufpos = len\n      return len\n    }\n  }\n\n  pos += (pos >= 0) * this._bufpos\n\n  // Lookbehind buffer is now empty. We only need to check if the\n  // needle is in the haystack.\n  if (data.indexOf(needle, pos) !== -1) {\n    pos = data.indexOf(needle, pos)\n    ++this.matches\n    if (pos > 0) { this.emit('info', true, data, this._bufpos, pos) } else { this.emit('info', true) }\n\n    return (this._bufpos = pos + needleLength)\n  } else {\n    pos = len - needleLength\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  while (\n    pos < len &&\n    (\n      data[pos] !== needle[0] ||\n      (\n        (Buffer.compare(\n          data.subarray(pos, pos + len - pos),\n          needle.subarray(0, len - pos)\n        ) !== 0)\n      )\n    )\n  ) {\n    ++pos\n  }\n  if (pos < len) {\n    data.copy(this._lookbehind, 0, pos, pos + (len - pos))\n    this._lookbehind_size = len - pos\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0) { this.emit('info', false, data, this._bufpos, pos < len ? pos : len) }\n\n  this._bufpos = len\n  return len\n}\n\nSBMH.prototype._sbmh_lookup_char = function (data, pos) {\n  return (pos < 0)\n    ? this._lookbehind[this._lookbehind_size + pos]\n    : data[pos]\n}\n\nSBMH.prototype._sbmh_memcmp = function (data, pos, len) {\n  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var\n    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }\n  }\n  return true\n}\n\nmodule.exports = SBMH\n"],"names":["EventEmitter","$dfzmk$EventEmitter","inherits","$dfzmk$inherits","$b3561955aa1940ac$exports","$b3561955aa1940ac$var$SBMH","needle","Buffer","from","isBuffer","TypeError","needleLength","length","Error","maxMatches","Infinity","matches","_occ","Array","fill","_lookbehind_size","_needle","_bufpos","_lookbehind","alloc","i","$b3561955aa1940ac$require$inherits","prototype","reset","push","chunk","pos","r","chlen","_sbmh_feed","data","ch","len","lastNeedleChar","_sbmh_lookup_char","_sbmh_memcmp","emit","bytesToCutOff","copy","indexOf","compare","subarray","default"],"version":3,"file":"python-version-check.2d65d83f.js.map","sourceRoot":"../"}