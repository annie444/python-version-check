{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/receiver.js"],"sourcesContent":["import $ht4UQ$pythonversioncheck64bbae24js3 from \"./python-version-check.64bbae24.js\";\nimport $ht4UQ$pythonversioncheckf95b0f32js3 from \"./python-version-check.f95b0f32.js\";\nimport $ht4UQ$pythonversioncheck92967d43js2 from \"./python-version-check.92967d43.js\";\nimport $ht4UQ$pythonversioncheck1bc0acd6js from \"./python-version-check.1bc0acd6.js\";\nimport {Writable as $ht4UQ$Writable} from \"stream\";\nimport {channel as $ht4UQ$channel} from \"diagnostics_channel\";\n\nvar $a1107a37541863d3$exports = {};\n'use strict';\n\nvar $a1107a37541863d3$require$Writable = $ht4UQ$Writable;\n\n\nvar $a1107a37541863d3$require$parserStates = $ht4UQ$pythonversioncheck64bbae24js2.parserStates;\nvar $a1107a37541863d3$require$opcodes = $ht4UQ$pythonversioncheck64bbae24js1.opcodes;\nvar $a1107a37541863d3$require$states = $ht4UQ$pythonversioncheck64bbae24js3.states;\nvar $a1107a37541863d3$require$emptyBuffer = $ht4UQ$pythonversioncheck64bbae24js.emptyBuffer;\n\nvar $a1107a37541863d3$require$kReadyState = $ht4UQ$pythonversioncheckf95b0f32js.kReadyState;\nvar $a1107a37541863d3$require$kSentClose = $ht4UQ$pythonversioncheckf95b0f32js3.kSentClose;\nvar $a1107a37541863d3$require$kResponse = $ht4UQ$pythonversioncheckf95b0f32js2.kResponse;\nvar $a1107a37541863d3$require$kReceivedClose = $ht4UQ$pythonversioncheckf95b0f32js1.kReceivedClose;\n\nvar $a1107a37541863d3$require$isValidStatusCode = $ht4UQ$pythonversioncheck92967d43js1.isValidStatusCode;\nvar $a1107a37541863d3$require$failWebsocketConnection = $ht4UQ$pythonversioncheck92967d43js.failWebsocketConnection;\nvar $a1107a37541863d3$require$websocketMessageReceived = $ht4UQ$pythonversioncheck92967d43js2.websocketMessageReceived;\n\nvar $a1107a37541863d3$require$WebsocketFrameSend = $ht4UQ$pythonversioncheck1bc0acd6js.WebsocketFrameSend;\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\nconst $a1107a37541863d3$var$channels = {};\n$a1107a37541863d3$var$channels.ping = $ht4UQ$channel('undici:websocket:ping');\n$a1107a37541863d3$var$channels.pong = $ht4UQ$channel('undici:websocket:pong');\nclass $a1107a37541863d3$var$ByteParser extends $a1107a37541863d3$require$Writable {\n    #buffers = [];\n    #byteOffset = 0;\n    #state = $a1107a37541863d3$require$parserStates.INFO;\n    #info = {};\n    #fragments = [];\n    constructor(ws){\n        super();\n        this.ws = ws;\n    }\n    /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */ _write(chunk, _, callback) {\n        this.#buffers.push(chunk);\n        this.#byteOffset += chunk.length;\n        this.run(callback);\n    }\n    /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */ run(callback) {\n        while(true){\n            if (this.#state === $a1107a37541863d3$require$parserStates.INFO) {\n                // If there aren't enough bytes to parse the payload length, etc.\n                if (this.#byteOffset < 2) return callback();\n                const buffer = this.consume(2);\n                this.#info.fin = (buffer[0] & 0x80) !== 0;\n                this.#info.opcode = buffer[0] & 0x0F;\n                // If we receive a fragmented message, we use the type of the first\n                // frame to parse the full message as binary/text, when it's terminated\n                this.#info.originalOpcode ??= this.#info.opcode;\n                this.#info.fragmented = !this.#info.fin && this.#info.opcode !== $a1107a37541863d3$require$opcodes.CONTINUATION;\n                if (this.#info.fragmented && this.#info.opcode !== $a1107a37541863d3$require$opcodes.BINARY && this.#info.opcode !== $a1107a37541863d3$require$opcodes.TEXT) {\n                    // Only text and binary frames can be fragmented\n                    $a1107a37541863d3$require$failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');\n                    return;\n                }\n                const payloadLength = buffer[1] & 0x7F;\n                if (payloadLength <= 125) {\n                    this.#info.payloadLength = payloadLength;\n                    this.#state = $a1107a37541863d3$require$parserStates.READ_DATA;\n                } else if (payloadLength === 126) this.#state = $a1107a37541863d3$require$parserStates.PAYLOADLENGTH_16;\n                else if (payloadLength === 127) this.#state = $a1107a37541863d3$require$parserStates.PAYLOADLENGTH_64;\n                if (this.#info.fragmented && payloadLength > 125) {\n                    // A fragmented frame can't be fragmented itself\n                    $a1107a37541863d3$require$failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');\n                    return;\n                } else if ((this.#info.opcode === $a1107a37541863d3$require$opcodes.PING || this.#info.opcode === $a1107a37541863d3$require$opcodes.PONG || this.#info.opcode === $a1107a37541863d3$require$opcodes.CLOSE) && payloadLength > 125) {\n                    // Control frames can have a payload length of 125 bytes MAX\n                    $a1107a37541863d3$require$failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.');\n                    return;\n                } else if (this.#info.opcode === $a1107a37541863d3$require$opcodes.CLOSE) {\n                    if (payloadLength === 1) {\n                        $a1107a37541863d3$require$failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');\n                        return;\n                    }\n                    const body = this.consume(payloadLength);\n                    this.#info.closeInfo = this.parseCloseBody(false, body);\n                    if (!this.ws[$a1107a37541863d3$require$kSentClose]) {\n                        // If an endpoint receives a Close frame and did not previously send a\n                        // Close frame, the endpoint MUST send a Close frame in response.  (When\n                        // sending a Close frame in response, the endpoint typically echos the\n                        // status code it received.)\n                        const body = Buffer.allocUnsafe(2);\n                        body.writeUInt16BE(this.#info.closeInfo.code, 0);\n                        const closeFrame = new $a1107a37541863d3$require$WebsocketFrameSend(body);\n                        this.ws[$a1107a37541863d3$require$kResponse].socket.write(closeFrame.createFrame($a1107a37541863d3$require$opcodes.CLOSE), (err)=>{\n                            if (!err) this.ws[$a1107a37541863d3$require$kSentClose] = true;\n                        });\n                    }\n                    // Upon either sending or receiving a Close control frame, it is said\n                    // that _The WebSocket Closing Handshake is Started_ and that the\n                    // WebSocket connection is in the CLOSING state.\n                    this.ws[$a1107a37541863d3$require$kReadyState] = $a1107a37541863d3$require$states.CLOSING;\n                    this.ws[$a1107a37541863d3$require$kReceivedClose] = true;\n                    this.end();\n                    return;\n                } else if (this.#info.opcode === $a1107a37541863d3$require$opcodes.PING) {\n                    // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n                    // response, unless it already received a Close frame.\n                    // A Pong frame sent in response to a Ping frame must have identical\n                    // \"Application data\"\n                    const body = this.consume(payloadLength);\n                    if (!this.ws[$a1107a37541863d3$require$kReceivedClose]) {\n                        const frame = new $a1107a37541863d3$require$WebsocketFrameSend(body);\n                        this.ws[$a1107a37541863d3$require$kResponse].socket.write(frame.createFrame($a1107a37541863d3$require$opcodes.PONG));\n                        if ($a1107a37541863d3$var$channels.ping.hasSubscribers) $a1107a37541863d3$var$channels.ping.publish({\n                            payload: body\n                        });\n                    }\n                    this.#state = $a1107a37541863d3$require$parserStates.INFO;\n                    if (this.#byteOffset > 0) continue;\n                    else {\n                        callback();\n                        return;\n                    }\n                } else if (this.#info.opcode === $a1107a37541863d3$require$opcodes.PONG) {\n                    // A Pong frame MAY be sent unsolicited.  This serves as a\n                    // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n                    // not expected.\n                    const body = this.consume(payloadLength);\n                    if ($a1107a37541863d3$var$channels.pong.hasSubscribers) $a1107a37541863d3$var$channels.pong.publish({\n                        payload: body\n                    });\n                    if (this.#byteOffset > 0) continue;\n                    else {\n                        callback();\n                        return;\n                    }\n                }\n            } else if (this.#state === $a1107a37541863d3$require$parserStates.PAYLOADLENGTH_16) {\n                if (this.#byteOffset < 2) return callback();\n                const buffer = this.consume(2);\n                this.#info.payloadLength = buffer.readUInt16BE(0);\n                this.#state = $a1107a37541863d3$require$parserStates.READ_DATA;\n            } else if (this.#state === $a1107a37541863d3$require$parserStates.PAYLOADLENGTH_64) {\n                if (this.#byteOffset < 8) return callback();\n                const buffer = this.consume(8);\n                const upper = buffer.readUInt32BE(0);\n                // 2^31 is the maxinimum bytes an arraybuffer can contain\n                // on 32-bit systems. Although, on 64-bit systems, this is\n                // 2^53-1 bytes.\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n                if (upper > 2 ** 31 - 1) {\n                    $a1107a37541863d3$require$failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');\n                    return;\n                }\n                const lower = buffer.readUInt32BE(4);\n                this.#info.payloadLength = (upper << 8) + lower;\n                this.#state = $a1107a37541863d3$require$parserStates.READ_DATA;\n            } else if (this.#state === $a1107a37541863d3$require$parserStates.READ_DATA) {\n                if (this.#byteOffset < this.#info.payloadLength) // If there is still more data in this chunk that needs to be read\n                return callback();\n                else if (this.#byteOffset >= this.#info.payloadLength) {\n                    // If the server sent multiple frames in a single chunk\n                    const body = this.consume(this.#info.payloadLength);\n                    this.#fragments.push(body);\n                    // If the frame is unfragmented, or a fragmented frame was terminated,\n                    // a message was received\n                    if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === $a1107a37541863d3$require$opcodes.CONTINUATION) {\n                        const fullMessage = Buffer.concat(this.#fragments);\n                        $a1107a37541863d3$require$websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);\n                        this.#info = {};\n                        this.#fragments.length = 0;\n                    }\n                    this.#state = $a1107a37541863d3$require$parserStates.INFO;\n                }\n            }\n            if (this.#byteOffset > 0) continue;\n            else {\n                callback();\n                break;\n            }\n        }\n    }\n    /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer|null}\n   */ consume(n) {\n        if (n > this.#byteOffset) return null;\n        else if (n === 0) return $a1107a37541863d3$require$emptyBuffer;\n        if (this.#buffers[0].length === n) {\n            this.#byteOffset -= this.#buffers[0].length;\n            return this.#buffers.shift();\n        }\n        const buffer = Buffer.allocUnsafe(n);\n        let offset = 0;\n        while(offset !== n){\n            const next = this.#buffers[0];\n            const { length: length } = next;\n            if (length + offset === n) {\n                buffer.set(this.#buffers.shift(), offset);\n                break;\n            } else if (length + offset > n) {\n                buffer.set(next.subarray(0, n - offset), offset);\n                this.#buffers[0] = next.subarray(n - offset);\n                break;\n            } else {\n                buffer.set(this.#buffers.shift(), offset);\n                offset += next.length;\n            }\n        }\n        this.#byteOffset -= n;\n        return buffer;\n    }\n    parseCloseBody(onlyCode, data) {\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n        /** @type {number|undefined} */ let code;\n        if (data.length >= 2) // _The WebSocket Connection Close Code_ is\n        // defined as the status code (Section 7.4) contained in the first Close\n        // control frame received by the application\n        code = data.readUInt16BE(0);\n        if (onlyCode) {\n            if (!$a1107a37541863d3$require$isValidStatusCode(code)) return null;\n            return {\n                code: code\n            };\n        }\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n        /** @type {Buffer} */ let reason = data.subarray(2);\n        // Remove BOM\n        if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) reason = reason.subarray(3);\n        if (code !== undefined && !$a1107a37541863d3$require$isValidStatusCode(code)) return null;\n        try {\n            // TODO: optimize this\n            reason = new TextDecoder('utf-8', {\n                fatal: true\n            }).decode(reason);\n        } catch  {\n            return null;\n        }\n        return {\n            code: code,\n            reason: reason\n        };\n    }\n    get closingInfo() {\n        return this.#info.closeInfo;\n    }\n}\n$a1107a37541863d3$exports = {\n    ByteParser: $a1107a37541863d3$var$ByteParser\n};\n\n\nexport {$a1107a37541863d3$exports as default};\n//# sourceMappingURL=python-version-check.98655e43.js.map\n","'use strict'\n\nconst { Writable } = require('stream')\nconst diagnosticsChannel = require('diagnostics_channel')\nconst { parserStates, opcodes, states, emptyBuffer } = require('./constants')\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = require('./symbols')\nconst { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require('./util')\nconst { WebsocketFrameSend } = require('./frame')\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nconst channels = {}\nchannels.ping = diagnosticsChannel.channel('undici:websocket:ping')\nchannels.pong = diagnosticsChannel.channel('undici:websocket:pong')\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #byteOffset = 0\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  constructor (ws) {\n    super()\n\n    this.ws = ws\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (true) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.fin = (buffer[0] & 0x80) !== 0\n        this.#info.opcode = buffer[0] & 0x0F\n\n        // If we receive a fragmented message, we use the type of the first\n        // frame to parse the full message as binary/text, when it's terminated\n        this.#info.originalOpcode ??= this.#info.opcode\n\n        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION\n\n        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        const payloadLength = buffer[1] & 0x7F\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (this.#info.fragmented && payloadLength > 125) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.')\n          return\n        } else if (\n          (this.#info.opcode === opcodes.PING ||\n            this.#info.opcode === opcodes.PONG ||\n            this.#info.opcode === opcodes.CLOSE) &&\n          payloadLength > 125\n        ) {\n          // Control frames can have a payload length of 125 bytes MAX\n          failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.')\n          return\n        } else if (this.#info.opcode === opcodes.CLOSE) {\n          if (payloadLength === 1) {\n            failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.')\n            return\n          }\n\n          const body = this.consume(payloadLength)\n\n          this.#info.closeInfo = this.parseCloseBody(false, body)\n\n          if (!this.ws[kSentClose]) {\n            // If an endpoint receives a Close frame and did not previously send a\n            // Close frame, the endpoint MUST send a Close frame in response.  (When\n            // sending a Close frame in response, the endpoint typically echos the\n            // status code it received.)\n            const body = Buffer.allocUnsafe(2)\n            body.writeUInt16BE(this.#info.closeInfo.code, 0)\n            const closeFrame = new WebsocketFrameSend(body)\n\n            this.ws[kResponse].socket.write(\n              closeFrame.createFrame(opcodes.CLOSE),\n              (err) => {\n                if (!err) {\n                  this.ws[kSentClose] = true\n                }\n              }\n            )\n          }\n\n          // Upon either sending or receiving a Close control frame, it is said\n          // that _The WebSocket Closing Handshake is Started_ and that the\n          // WebSocket connection is in the CLOSING state.\n          this.ws[kReadyState] = states.CLOSING\n          this.ws[kReceivedClose] = true\n\n          this.end()\n\n          return\n        } else if (this.#info.opcode === opcodes.PING) {\n          // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n          // response, unless it already received a Close frame.\n          // A Pong frame sent in response to a Ping frame must have identical\n          // \"Application data\"\n\n          const body = this.consume(payloadLength)\n\n          if (!this.ws[kReceivedClose]) {\n            const frame = new WebsocketFrameSend(body)\n\n            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG))\n\n            if (channels.ping.hasSubscribers) {\n              channels.ping.publish({\n                payload: body\n              })\n            }\n          }\n\n          this.#state = parserStates.INFO\n\n          if (this.#byteOffset > 0) {\n            continue\n          } else {\n            callback()\n            return\n          }\n        } else if (this.#info.opcode === opcodes.PONG) {\n          // A Pong frame MAY be sent unsolicited.  This serves as a\n          // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n          // not expected.\n\n          const body = this.consume(payloadLength)\n\n          if (channels.pong.hasSubscribers) {\n            channels.pong.publish({\n              payload: body\n            })\n          }\n\n          if (this.#byteOffset > 0) {\n            continue\n          } else {\n            callback()\n            return\n          }\n        }\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maxinimum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          // If there is still more data in this chunk that needs to be read\n          return callback()\n        } else if (this.#byteOffset >= this.#info.payloadLength) {\n          // If the server sent multiple frames in a single chunk\n\n          const body = this.consume(this.#info.payloadLength)\n\n          this.#fragments.push(body)\n\n          // If the frame is unfragmented, or a fragmented frame was terminated,\n          // a message was received\n          if (!this.#info.fragmented || (this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)) {\n            const fullMessage = Buffer.concat(this.#fragments)\n\n            websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage)\n\n            this.#info = {}\n            this.#fragments.length = 0\n          }\n\n          this.#state = parserStates.INFO\n        }\n      }\n\n      if (this.#byteOffset > 0) {\n        continue\n      } else {\n        callback()\n        break\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer|null}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      return null\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length\n      return this.#buffers.shift()\n    }\n\n    const buffer = Buffer.allocUnsafe(n)\n    let offset = 0\n\n    while (offset !== n) {\n      const next = this.#buffers[0]\n      const { length } = next\n\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset)\n        break\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset)\n        this.#buffers[0] = next.subarray(n - offset)\n        break\n      } else {\n        buffer.set(this.#buffers.shift(), offset)\n        offset += next.length\n      }\n    }\n\n    this.#byteOffset -= n\n\n    return buffer\n  }\n\n  parseCloseBody (onlyCode, data) {\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (onlyCode) {\n      if (!isValidStatusCode(code)) {\n        return null\n      }\n\n      return { code }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return null\n    }\n\n    try {\n      // TODO: optimize this\n      reason = new TextDecoder('utf-8', { fatal: true }).decode(reason)\n    } catch {\n      return null\n    }\n\n    return { code, reason }\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n"],"names":["$ht4UQ$pythonversioncheck64bbae24js3","$ht4UQ$pythonversioncheckf95b0f32js3","$ht4UQ$pythonversioncheck92967d43js2","$ht4UQ$pythonversioncheck1bc0acd6js","Writable","$ht4UQ$Writable","channel","$ht4UQ$channel","$a1107a37541863d3$exports","$a1107a37541863d3$require$Writable","$a1107a37541863d3$require$parserStates","$ht4UQ$pythonversioncheck64bbae24js2","parserStates","$a1107a37541863d3$require$opcodes","$ht4UQ$pythonversioncheck64bbae24js1","opcodes","$a1107a37541863d3$require$states","states","$a1107a37541863d3$require$emptyBuffer","$ht4UQ$pythonversioncheck64bbae24js","emptyBuffer","$a1107a37541863d3$require$kReadyState","$ht4UQ$pythonversioncheckf95b0f32js","kReadyState","$a1107a37541863d3$require$kSentClose","kSentClose","$a1107a37541863d3$require$kResponse","$ht4UQ$pythonversioncheckf95b0f32js2","kResponse","$a1107a37541863d3$require$kReceivedClose","$ht4UQ$pythonversioncheckf95b0f32js1","kReceivedClose","$a1107a37541863d3$require$isValidStatusCode","$ht4UQ$pythonversioncheck92967d43js1","isValidStatusCode","$a1107a37541863d3$require$failWebsocketConnection","$ht4UQ$pythonversioncheck92967d43js","failWebsocketConnection","$a1107a37541863d3$require$websocketMessageReceived","websocketMessageReceived","$a1107a37541863d3$require$WebsocketFrameSend","WebsocketFrameSend","$a1107a37541863d3$var$channels","ping","pong","$a1107a37541863d3$var$ByteParser","INFO","ws","_write","chunk","_","callback","push","length","run","buffer","consume","fin","opcode","originalOpcode","fragmented","CONTINUATION","BINARY","TEXT","payloadLength","READ_DATA","PAYLOADLENGTH_16","PAYLOADLENGTH_64","PING","PONG","CLOSE","body","closeInfo","parseCloseBody","Buffer","allocUnsafe","writeUInt16BE","code","closeFrame","socket","write","createFrame","err","CLOSING","end","frame","hasSubscribers","publish","payload","readUInt16BE","upper","readUInt32BE","lower","fullMessage","concat","n","shift","offset","next","set","subarray","onlyCode","data","reason","undefined","TextDecoder","fatal","decode","closingInfo","ByteParser","default"],"version":3,"file":"python-version-check.98655e43.js.map","sourceRoot":"../"}