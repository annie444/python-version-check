{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js"],"sourcesContent":["import $1uSZm$pythonversioncheckebf2a848js1 from \"./python-version-check.ebf2a848.js\";\nimport $1uSZm$pythonversioncheck92c00e26js from \"./python-version-check.92c00e26.js\";\nimport $1uSZm$pythonversioncheck7ed1514ejs from \"./python-version-check.7ed1514e.js\";\nimport $1uSZm$pythonversioncheck3f48d3eejs2 from \"./python-version-check.3f48d3ee.js\";\nimport $1uSZm$pythonversioncheck801bb0f1js from \"./python-version-check.801bb0f1.js\";\nimport {inspect as $1uSZm$inspect} from \"util\";\nimport * as $1uSZm$assert from \"assert\";\n\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5a65\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5a65\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"8jWfB\", function(module, exports) {\n// https://github.com/Ethan-Arrowood/undici-fetch\n'use strict';\n\nvar $60ed487139952095$require$kHeadersList = $1uSZm$pythonversioncheckebf2a848js1.kHeadersList;\nvar $60ed487139952095$require$kConstruct = $1uSZm$pythonversioncheckebf2a848js.kConstruct;\n\nvar $60ed487139952095$require$kGuard = $1uSZm$pythonversioncheck92c00e26js.kGuard;\n\nvar $60ed487139952095$require$kEnumerableProperty = $1uSZm$pythonversioncheck7ed1514ejs.kEnumerableProperty;\n\nvar $60ed487139952095$require$makeIterator = $1uSZm$pythonversioncheck3f48d3eejs2.makeIterator;\nvar $60ed487139952095$require$isValidHeaderName = $1uSZm$pythonversioncheck3f48d3eejs.isValidHeaderName;\nvar $60ed487139952095$require$isValidHeaderValue = $1uSZm$pythonversioncheck3f48d3eejs1.isValidHeaderValue;\n\n\nvar $60ed487139952095$require$webidl = $1uSZm$pythonversioncheck801bb0f1js.webidl;\n\nconst $60ed487139952095$var$kHeadersMap = Symbol('headers map');\nconst $60ed487139952095$var$kHeadersSortedMap = Symbol('headers map sorted');\n/**\n * @param {number} code\n */ function $60ed487139952095$var$isHTTPWhiteSpaceCharCode(code) {\n    return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */ function $60ed487139952095$var$headerValueNormalize(potentialValue) {\n    //  To normalize a byte sequence potentialValue, remove\n    //  any leading and trailing HTTP whitespace bytes from\n    //  potentialValue.\n    let i = 0;\n    let j = potentialValue.length;\n    while(j > i && $60ed487139952095$var$isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))--j;\n    while(j > i && $60ed487139952095$var$isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))++i;\n    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);\n}\nfunction $60ed487139952095$var$fill(headers, object) {\n    // To fill a Headers object headers with a given object object, run these steps:\n    // 1. If object is a sequence, then for each header in object:\n    // Note: webidl conversion to array has already been done.\n    if (Array.isArray(object)) for(let i = 0; i < object.length; ++i){\n        const header = object[i];\n        // 1. If header does not contain exactly two items, then throw a TypeError.\n        if (header.length !== 2) throw $60ed487139952095$require$webidl.errors.exception({\n            header: 'Headers constructor',\n            message: `expected name/value pair to be length 2, found ${header.length}.`\n        });\n        // 2. Append (header’s first item, header’s second item) to headers.\n        $60ed487139952095$var$appendHeader(headers, header[0], header[1]);\n    }\n    else if (typeof object === 'object' && object !== null) {\n        // Note: null should throw\n        // 2. Otherwise, object is a record, then for each key → value in object,\n        //    append (key, value) to headers\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; ++i)$60ed487139952095$var$appendHeader(headers, keys[i], object[keys[i]]);\n    } else throw $60ed487139952095$require$webidl.errors.conversionFailed({\n        prefix: 'Headers constructor',\n        argument: 'Argument 1',\n        types: [\n            'sequence<sequence<ByteString>>',\n            'record<ByteString, ByteString>'\n        ]\n    });\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */ function $60ed487139952095$var$appendHeader(headers, name, value) {\n    // 1. Normalize value.\n    value = $60ed487139952095$var$headerValueNormalize(value);\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!$60ed487139952095$require$isValidHeaderName(name)) throw $60ed487139952095$require$webidl.errors.invalidArgument({\n        prefix: 'Headers.append',\n        value: name,\n        type: 'header name'\n    });\n    else if (!$60ed487139952095$require$isValidHeaderValue(value)) throw $60ed487139952095$require$webidl.errors.invalidArgument({\n        prefix: 'Headers.append',\n        value: value,\n        type: 'header value'\n    });\n    // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if headers’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // Note: undici does not implement forbidden header names\n    if (headers[$60ed487139952095$require$kGuard] === 'immutable') throw new TypeError('immutable');\n    else headers[$60ed487139952095$require$kGuard];\n    // 6. Otherwise, if headers’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // 7. Append (name, value) to headers’s header list.\n    return headers[$60ed487139952095$require$kHeadersList].append(name, value);\n// 8. If headers’s guard is \"request-no-cors\", then remove\n//    privileged no-CORS request headers from headers\n}\nclass $60ed487139952095$var$HeadersList {\n    /** @type {[string, string][]|null} */ cookies = null;\n    constructor(init){\n        if (init instanceof $60ed487139952095$var$HeadersList) {\n            this[$60ed487139952095$var$kHeadersMap] = new Map(init[$60ed487139952095$var$kHeadersMap]);\n            this[$60ed487139952095$var$kHeadersSortedMap] = init[$60ed487139952095$var$kHeadersSortedMap];\n            this.cookies = init.cookies === null ? null : [\n                ...init.cookies\n            ];\n        } else {\n            this[$60ed487139952095$var$kHeadersMap] = new Map(init);\n            this[$60ed487139952095$var$kHeadersSortedMap] = null;\n        }\n    }\n    // https://fetch.spec.whatwg.org/#header-list-contains\n    contains(name) {\n        // A header list list contains a header name name if list\n        // contains a header whose name is a byte-case-insensitive\n        // match for name.\n        name = name.toLowerCase();\n        return this[$60ed487139952095$var$kHeadersMap].has(name);\n    }\n    clear() {\n        this[$60ed487139952095$var$kHeadersMap].clear();\n        this[$60ed487139952095$var$kHeadersSortedMap] = null;\n        this.cookies = null;\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-append\n    append(name, value) {\n        this[$60ed487139952095$var$kHeadersSortedMap] = null;\n        // 1. If list contains name, then set name to the first such\n        //    header’s name.\n        const lowercaseName = name.toLowerCase();\n        const exists = this[$60ed487139952095$var$kHeadersMap].get(lowercaseName);\n        // 2. Append (name, value) to list.\n        if (exists) {\n            const delimiter = lowercaseName === 'cookie' ? '; ' : ', ';\n            this[$60ed487139952095$var$kHeadersMap].set(lowercaseName, {\n                name: exists.name,\n                value: `${exists.value}${delimiter}${value}`\n            });\n        } else this[$60ed487139952095$var$kHeadersMap].set(lowercaseName, {\n            name: name,\n            value: value\n        });\n        if (lowercaseName === 'set-cookie') {\n            this.cookies ??= [];\n            this.cookies.push(value);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-set\n    set(name, value) {\n        this[$60ed487139952095$var$kHeadersSortedMap] = null;\n        const lowercaseName = name.toLowerCase();\n        if (lowercaseName === 'set-cookie') this.cookies = [\n            value\n        ];\n        // 1. If list contains name, then set the value of\n        //    the first such header to value and remove the\n        //    others.\n        // 2. Otherwise, append header (name, value) to list.\n        this[$60ed487139952095$var$kHeadersMap].set(lowercaseName, {\n            name: name,\n            value: value\n        });\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-delete\n    delete(name) {\n        this[$60ed487139952095$var$kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        if (name === 'set-cookie') this.cookies = null;\n        this[$60ed487139952095$var$kHeadersMap].delete(name);\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-get\n    get(name) {\n        const value = this[$60ed487139952095$var$kHeadersMap].get(name.toLowerCase());\n        // 1. If list does not contain name, then return null.\n        // 2. Return the values of all headers in list whose name\n        //    is a byte-case-insensitive match for name,\n        //    separated from each other by 0x2C 0x20, in order.\n        return value === undefined ? null : value.value;\n    }\n    *[Symbol.iterator]() {\n        // use the lowercased name\n        for (const [name, { value: value }] of this[$60ed487139952095$var$kHeadersMap])yield [\n            name,\n            value\n        ];\n    }\n    get entries() {\n        const headers = {};\n        if (this[$60ed487139952095$var$kHeadersMap].size) for (const { name: name, value: value } of this[$60ed487139952095$var$kHeadersMap].values())headers[name] = value;\n        return headers;\n    }\n}\n// https://fetch.spec.whatwg.org/#headers-class\nclass $60ed487139952095$var$Headers {\n    constructor(init){\n        if (init === $60ed487139952095$require$kConstruct) return;\n        this[$60ed487139952095$require$kHeadersList] = new $60ed487139952095$var$HeadersList();\n        // The new Headers(init) constructor steps are:\n        // 1. Set this’s guard to \"none\".\n        this[$60ed487139952095$require$kGuard] = 'none';\n        // 2. If init is given, then fill this with init.\n        if (init !== undefined) {\n            init = $60ed487139952095$require$webidl.converters.HeadersInit(init);\n            $60ed487139952095$var$fill(this, init);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-append\n    append(name, value) {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        $60ed487139952095$require$webidl.argumentLengthCheck(arguments, 2, {\n            header: 'Headers.append'\n        });\n        name = $60ed487139952095$require$webidl.converters.ByteString(name);\n        value = $60ed487139952095$require$webidl.converters.ByteString(value);\n        return $60ed487139952095$var$appendHeader(this, name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-delete\n    delete(name) {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        $60ed487139952095$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'Headers.delete'\n        });\n        name = $60ed487139952095$require$webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!$60ed487139952095$require$isValidHeaderName(name)) throw $60ed487139952095$require$webidl.errors.invalidArgument({\n            prefix: 'Headers.delete',\n            value: name,\n            type: 'header name'\n        });\n        // 2. If this’s guard is \"immutable\", then throw a TypeError.\n        // 3. Otherwise, if this’s guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n        //    is not a no-CORS-safelisted request-header name, and\n        //    name is not a privileged no-CORS request-header name,\n        //    return.\n        // 5. Otherwise, if this’s guard is \"response\" and name is\n        //    a forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[$60ed487139952095$require$kGuard] === 'immutable') throw new TypeError('immutable');\n        else this[$60ed487139952095$require$kGuard];\n        // 6. If this’s header list does not contain name, then\n        //    return.\n        if (!this[$60ed487139952095$require$kHeadersList].contains(name)) return;\n        // 7. Delete name from this’s header list.\n        // 8. If this’s guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this.\n        this[$60ed487139952095$require$kHeadersList].delete(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-get\n    get(name) {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        $60ed487139952095$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'Headers.get'\n        });\n        name = $60ed487139952095$require$webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!$60ed487139952095$require$isValidHeaderName(name)) throw $60ed487139952095$require$webidl.errors.invalidArgument({\n            prefix: 'Headers.get',\n            value: name,\n            type: 'header name'\n        });\n        // 2. Return the result of getting name from this’s header\n        //    list.\n        return this[$60ed487139952095$require$kHeadersList].get(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-has\n    has(name) {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        $60ed487139952095$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'Headers.has'\n        });\n        name = $60ed487139952095$require$webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!$60ed487139952095$require$isValidHeaderName(name)) throw $60ed487139952095$require$webidl.errors.invalidArgument({\n            prefix: 'Headers.has',\n            value: name,\n            type: 'header name'\n        });\n        // 2. Return true if this’s header list contains name;\n        //    otherwise false.\n        return this[$60ed487139952095$require$kHeadersList].contains(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-set\n    set(name, value) {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        $60ed487139952095$require$webidl.argumentLengthCheck(arguments, 2, {\n            header: 'Headers.set'\n        });\n        name = $60ed487139952095$require$webidl.converters.ByteString(name);\n        value = $60ed487139952095$require$webidl.converters.ByteString(value);\n        // 1. Normalize value.\n        value = $60ed487139952095$var$headerValueNormalize(value);\n        // 2. If name is not a header name or value is not a\n        //    header value, then throw a TypeError.\n        if (!$60ed487139952095$require$isValidHeaderName(name)) throw $60ed487139952095$require$webidl.errors.invalidArgument({\n            prefix: 'Headers.set',\n            value: name,\n            type: 'header name'\n        });\n        else if (!$60ed487139952095$require$isValidHeaderValue(value)) throw $60ed487139952095$require$webidl.errors.invalidArgument({\n            prefix: 'Headers.set',\n            value: value,\n            type: 'header value'\n        });\n        // 3. If this’s guard is \"immutable\", then throw a TypeError.\n        // 4. Otherwise, if this’s guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n        //    name/value is not a no-CORS-safelisted request-header,\n        //    return.\n        // 6. Otherwise, if this’s guard is \"response\" and name is a\n        //    forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[$60ed487139952095$require$kGuard] === 'immutable') throw new TypeError('immutable');\n        else this[$60ed487139952095$require$kGuard];\n        // 7. Set (name, value) in this’s header list.\n        // 8. If this’s guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this\n        this[$60ed487139952095$require$kHeadersList].set(name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n    getSetCookie() {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n        // 2. Return the values of all headers in this’s header list whose name is\n        //    a byte-case-insensitive match for `Set-Cookie`, in order.\n        const list = this[$60ed487139952095$require$kHeadersList].cookies;\n        if (list) return [\n            ...list\n        ];\n        return [];\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n    get [$60ed487139952095$var$kHeadersSortedMap]() {\n        if (this[$60ed487139952095$require$kHeadersList][$60ed487139952095$var$kHeadersSortedMap]) return this[$60ed487139952095$require$kHeadersList][$60ed487139952095$var$kHeadersSortedMap];\n        // 1. Let headers be an empty list of headers with the key being the name\n        //    and value the value.\n        const headers = [];\n        // 2. Let names be the result of convert header names to a sorted-lowercase\n        //    set with all the names of the headers in list.\n        const names = [\n            ...this[$60ed487139952095$require$kHeadersList]\n        ].sort((a, b)=>a[0] < b[0] ? -1 : 1);\n        const cookies = this[$60ed487139952095$require$kHeadersList].cookies;\n        // 3. For each name of names:\n        for(let i = 0; i < names.length; ++i){\n            const [name, value] = names[i];\n            // 1. If name is `set-cookie`, then:\n            if (name === 'set-cookie') // 1. Let values be a list of all values of headers in list whose name\n            //    is a byte-case-insensitive match for name, in order.\n            // 2. For each value of values:\n            // 1. Append (name, value) to headers.\n            for(let j = 0; j < cookies.length; ++j)headers.push([\n                name,\n                cookies[j]\n            ]);\n            else {\n                // 2. Otherwise:\n                // 1. Let value be the result of getting name from list.\n                // 2. Assert: value is non-null.\n                $1uSZm$assert(value !== null);\n                // 3. Append (name, value) to headers.\n                headers.push([\n                    name,\n                    value\n                ]);\n            }\n        }\n        this[$60ed487139952095$require$kHeadersList][$60ed487139952095$var$kHeadersSortedMap] = headers;\n        // 4. Return headers.\n        return headers;\n    }\n    keys() {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        if (this[$60ed487139952095$require$kGuard] === 'immutable') {\n            const value = this[$60ed487139952095$var$kHeadersSortedMap];\n            return $60ed487139952095$require$makeIterator(()=>value, 'Headers', 'key');\n        }\n        return $60ed487139952095$require$makeIterator(()=>[\n                ...this[$60ed487139952095$var$kHeadersSortedMap].values()\n            ], 'Headers', 'key');\n    }\n    values() {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        if (this[$60ed487139952095$require$kGuard] === 'immutable') {\n            const value = this[$60ed487139952095$var$kHeadersSortedMap];\n            return $60ed487139952095$require$makeIterator(()=>value, 'Headers', 'value');\n        }\n        return $60ed487139952095$require$makeIterator(()=>[\n                ...this[$60ed487139952095$var$kHeadersSortedMap].values()\n            ], 'Headers', 'value');\n    }\n    entries() {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        if (this[$60ed487139952095$require$kGuard] === 'immutable') {\n            const value = this[$60ed487139952095$var$kHeadersSortedMap];\n            return $60ed487139952095$require$makeIterator(()=>value, 'Headers', 'key+value');\n        }\n        return $60ed487139952095$require$makeIterator(()=>[\n                ...this[$60ed487139952095$var$kHeadersSortedMap].values()\n            ], 'Headers', 'key+value');\n    }\n    /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */ forEach(callbackFn, thisArg = globalThis) {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        $60ed487139952095$require$webidl.argumentLengthCheck(arguments, 1, {\n            header: 'Headers.forEach'\n        });\n        if (typeof callbackFn !== 'function') throw new TypeError(\"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\");\n        for (const [key, value] of this)callbackFn.apply(thisArg, [\n            value,\n            key,\n            this\n        ]);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        $60ed487139952095$require$webidl.brandCheck(this, $60ed487139952095$var$Headers);\n        return this[$60ed487139952095$require$kHeadersList];\n    }\n}\n$60ed487139952095$var$Headers.prototype[Symbol.iterator] = $60ed487139952095$var$Headers.prototype.entries;\nObject.defineProperties($60ed487139952095$var$Headers.prototype, {\n    append: $60ed487139952095$require$kEnumerableProperty,\n    delete: $60ed487139952095$require$kEnumerableProperty,\n    get: $60ed487139952095$require$kEnumerableProperty,\n    has: $60ed487139952095$require$kEnumerableProperty,\n    set: $60ed487139952095$require$kEnumerableProperty,\n    getSetCookie: $60ed487139952095$require$kEnumerableProperty,\n    keys: $60ed487139952095$require$kEnumerableProperty,\n    values: $60ed487139952095$require$kEnumerableProperty,\n    entries: $60ed487139952095$require$kEnumerableProperty,\n    forEach: $60ed487139952095$require$kEnumerableProperty,\n    [Symbol.iterator]: {\n        enumerable: false\n    },\n    [Symbol.toStringTag]: {\n        value: 'Headers',\n        configurable: true\n    },\n    [$1uSZm$inspect.custom]: {\n        enumerable: false\n    }\n});\n$60ed487139952095$require$webidl.converters.HeadersInit = function(V) {\n    if ($60ed487139952095$require$webidl.util.Type(V) === 'Object') {\n        if (V[Symbol.iterator]) return $60ed487139952095$require$webidl.converters['sequence<sequence<ByteString>>'](V);\n        return $60ed487139952095$require$webidl.converters['record<ByteString, ByteString>'](V);\n    }\n    throw $60ed487139952095$require$webidl.errors.conversionFailed({\n        prefix: 'Headers constructor',\n        argument: 'Argument 1',\n        types: [\n            'sequence<sequence<ByteString>>',\n            'record<ByteString, ByteString>'\n        ]\n    });\n};\nmodule.exports = {\n    fill: $60ed487139952095$var$fill,\n    Headers: $60ed487139952095$var$Headers,\n    HeadersList: $60ed487139952095$var$HeadersList\n};\n\n});\n\n\nparcelRequire(\"8jWfB\");\n\n//# sourceMappingURL=python-version-check.5597d583.js.map\n","// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { kHeadersList, kConstruct } = require('../core/symbols')\nconst { kGuard } = require('./symbols')\nconst { kEnumerableProperty } = require('../core/util')\nconst {\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue\n} = require('./util')\nconst util = require('util')\nconst { webidl } = require('./webidl')\nconst assert = require('assert')\n\nconst kHeadersMap = Symbol('headers map')\nconst kHeadersSortedMap = Symbol('headers map sorted')\n\n/**\n * @param {number} code\n */\nfunction isHTTPWhiteSpaceCharCode (code) {\n  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0; let j = potentialValue.length\n\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i\n\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i]\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (header’s first item, header’s second item) to headers.\n      appendHeader(headers, header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key → value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object)\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]])\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */\nfunction appendHeader (headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value)\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    })\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    })\n  }\n\n  // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headers’s guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // Note: undici does not implement forbidden header names\n  if (headers[kGuard] === 'immutable') {\n    throw new TypeError('immutable')\n  } else if (headers[kGuard] === 'request-no-cors') {\n    // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n    // TODO\n  }\n\n  // 6. Otherwise, if headers’s guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headers’s header list.\n  return headers[kHeadersList].append(name, value)\n\n  // 8. If headers’s guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap])\n      this[kHeadersSortedMap] = init[kHeadersSortedMap]\n      this.cookies = init.cookies === null ? null : [...init.cookies]\n    } else {\n      this[kHeadersMap] = new Map(init)\n      this[kHeadersSortedMap] = null\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#header-list-contains\n  contains (name) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n    name = name.toLowerCase()\n\n    return this[kHeadersMap].has(name)\n  }\n\n  clear () {\n    this[kHeadersMap].clear()\n    this[kHeadersSortedMap] = null\n    this.cookies = null\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-append\n  append (name, value) {\n    this[kHeadersSortedMap] = null\n\n    // 1. If list contains name, then set name to the first such\n    //    header’s name.\n    const lowercaseName = name.toLowerCase()\n    const exists = this[kHeadersMap].get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this[kHeadersMap].set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies ??= []\n      this.cookies.push(value)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-set\n  set (name, value) {\n    this[kHeadersSortedMap] = null\n    const lowercaseName = name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this[kHeadersMap].set(lowercaseName, { name, value })\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-delete\n  delete (name) {\n    this[kHeadersSortedMap] = null\n\n    name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    this[kHeadersMap].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-get\n  get (name) {\n    const value = this[kHeadersMap].get(name.toLowerCase())\n\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return value === undefined ? null : value.value\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const [name, { value }] of this[kHeadersMap]) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this[kHeadersMap].size) {\n      for (const { name, value } of this[kHeadersMap].values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  constructor (init = undefined) {\n    if (init === kConstruct) {\n      return\n    }\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init)\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    return appendHeader(this, name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If this’s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this’s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 6. If this’s header list does not contain name, then\n    //    return.\n    if (!this[kHeadersList].contains(name)) {\n      return\n    }\n\n    // 7. Delete name from this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this[kHeadersList].delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.get',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from this’s header\n    //    list.\n    return this[kHeadersList].get(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' })\n\n    name = webidl.converters.ByteString(name)\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.has',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if this’s header list contains name;\n    //    otherwise false.\n    return this[kHeadersList].contains(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' })\n\n    name = webidl.converters.ByteString(name)\n    value = webidl.converters.ByteString(value)\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.set',\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If this’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    }\n\n    // 7. Set (name, value) in this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this[kHeadersList].set(name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n    // 2. Return the values of all headers in this’s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this[kHeadersList].cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap] () {\n    if (this[kHeadersList][kHeadersSortedMap]) {\n      return this[kHeadersList][kHeadersSortedMap]\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = []\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1)\n    const cookies = this[kHeadersList].cookies\n\n    // 3. For each name of names:\n    for (let i = 0; i < names.length; ++i) {\n      const [name, value] = names[i]\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (let j = 0; j < cookies.length; ++j) {\n          headers.push([name, cookies[j]])\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        assert(value !== null)\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value])\n      }\n    }\n\n    this[kHeadersList][kHeadersSortedMap] = headers\n\n    // 4. Return headers.\n    return headers\n  }\n\n  keys () {\n    webidl.brandCheck(this, Headers)\n\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap]\n      return makeIterator(() => value, 'Headers',\n        'key')\n    }\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key'\n    )\n  }\n\n  values () {\n    webidl.brandCheck(this, Headers)\n\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap]\n      return makeIterator(() => value, 'Headers',\n        'value')\n    }\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'value'\n    )\n  }\n\n  entries () {\n    webidl.brandCheck(this, Headers)\n\n    if (this[kGuard] === 'immutable') {\n      const value = this[kHeadersSortedMap]\n      return makeIterator(() => value, 'Headers',\n        'key+value')\n    }\n\n    return makeIterator(\n      () => [...this[kHeadersSortedMap].values()],\n      'Headers',\n      'key+value'\n    )\n  }\n\n  /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */\n  forEach (callbackFn, thisArg = globalThis) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' })\n\n    if (typeof callbackFn !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n\n    for (const [key, value] of this) {\n      callbackFn.apply(thisArg, [value, key, this])\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    webidl.brandCheck(this, Headers)\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty,\n  [Symbol.iterator]: { enumerable: false },\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  },\n  [util.inspect.custom]: {\n    enumerable: false\n  }\n})\n\nwebidl.converters.HeadersInit = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (V[Symbol.iterator]) {\n      return webidl.converters['sequence<sequence<ByteString>>'](V)\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList\n}\n"],"names":["$1uSZm$pythonversioncheckebf2a848js1","$1uSZm$pythonversioncheck92c00e26js","$1uSZm$pythonversioncheck7ed1514ejs","$1uSZm$pythonversioncheck3f48d3eejs2","$1uSZm$pythonversioncheck801bb0f1js","inspect","$1uSZm$inspect","$1uSZm$assert","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$60ed487139952095$require$kHeadersList","kHeadersList","$60ed487139952095$require$kConstruct","$1uSZm$pythonversioncheckebf2a848js","kConstruct","$60ed487139952095$require$kGuard","kGuard","$60ed487139952095$require$kEnumerableProperty","kEnumerableProperty","$60ed487139952095$require$makeIterator","makeIterator","$60ed487139952095$require$isValidHeaderName","$1uSZm$pythonversioncheck3f48d3eejs","isValidHeaderName","$60ed487139952095$require$isValidHeaderValue","$1uSZm$pythonversioncheck3f48d3eejs1","isValidHeaderValue","$60ed487139952095$require$webidl","webidl","$60ed487139952095$var$kHeadersMap","Symbol","$60ed487139952095$var$kHeadersSortedMap","$60ed487139952095$var$isHTTPWhiteSpaceCharCode","$60ed487139952095$var$headerValueNormalize","potentialValue","i","j","length","charCodeAt","substring","$60ed487139952095$var$fill","headers","object","Array","isArray","header","errors","exception","message","$60ed487139952095$var$appendHeader","keys","Object","conversionFailed","prefix","argument","types","name","value","invalidArgument","type","TypeError","append","$60ed487139952095$var$HeadersList","cookies","Map","contains","toLowerCase","has","clear","lowercaseName","exists","get","delimiter","set","push","delete","undefined","iterator","entries","size","values","$60ed487139952095$var$Headers","converters","HeadersInit","brandCheck","argumentLengthCheck","arguments","ByteString","getSetCookie","list","names","sort","a","b","forEach","callbackFn","thisArg","key","apply","for","prototype","defineProperties","enumerable","toStringTag","configurable","custom","V","util","Type","fill","Headers","HeadersList"],"version":3,"file":"python-version-check.5597d583.js.map","sourceRoot":"../"}