{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js"],"sourcesContent":["import $1vZ1t$pythonversioncheck3f48d3eejs1 from \"./python-version-check.3f48d3ee.js\";\nimport {types as $1vZ1t$types} from \"util\";\n\nvar $e16d8374983b673a$exports = {};\n'use strict';\n\nvar $e16d8374983b673a$require$types = $1vZ1t$types;\n\nvar $e16d8374983b673a$require$hasOwn = $1vZ1t$pythonversioncheck3f48d3eejs.hasOwn;\nvar $e16d8374983b673a$require$toUSVString = $1vZ1t$pythonversioncheck3f48d3eejs1.toUSVString;\n/** @type {import('../../types/webidl').Webidl} */ const $e16d8374983b673a$var$webidl = {};\n$e16d8374983b673a$var$webidl.converters = {};\n$e16d8374983b673a$var$webidl.util = {};\n$e16d8374983b673a$var$webidl.errors = {};\n$e16d8374983b673a$var$webidl.errors.exception = function(message) {\n    return new TypeError(`${message.header}: ${message.message}`);\n};\n$e16d8374983b673a$var$webidl.errors.conversionFailed = function(context) {\n    const plural = context.types.length === 1 ? '' : ' one of';\n    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(', ')}.`;\n    return $e16d8374983b673a$var$webidl.errors.exception({\n        header: context.prefix,\n        message: message\n    });\n};\n$e16d8374983b673a$var$webidl.errors.invalidArgument = function(context) {\n    return $e16d8374983b673a$var$webidl.errors.exception({\n        header: context.prefix,\n        message: `\"${context.value}\" is an invalid ${context.type}.`\n    });\n};\n// https://webidl.spec.whatwg.org/#implements\n$e16d8374983b673a$var$webidl.brandCheck = function(V, I, opts) {\n    if (opts?.strict !== false && !(V instanceof I)) throw new TypeError('Illegal invocation');\n    else return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];\n};\n$e16d8374983b673a$var$webidl.argumentLengthCheck = function({ length: length }, min, ctx) {\n    if (length < min) throw $e16d8374983b673a$var$webidl.errors.exception({\n        message: `${min} argument${min !== 1 ? 's' : ''} required, ` + `but${length ? ' only' : ''} ${length} found.`,\n        ...ctx\n    });\n};\n$e16d8374983b673a$var$webidl.illegalConstructor = function() {\n    throw $e16d8374983b673a$var$webidl.errors.exception({\n        header: 'TypeError',\n        message: 'Illegal constructor'\n    });\n};\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\n$e16d8374983b673a$var$webidl.util.Type = function(V) {\n    switch(typeof V){\n        case 'undefined':\n            return 'Undefined';\n        case 'boolean':\n            return 'Boolean';\n        case 'string':\n            return 'String';\n        case 'symbol':\n            return 'Symbol';\n        case 'number':\n            return 'Number';\n        case 'bigint':\n            return 'BigInt';\n        case 'function':\n        case 'object':\n            if (V === null) return 'Null';\n            return 'Object';\n    }\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\n$e16d8374983b673a$var$webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {\n    let upperBound;\n    let lowerBound;\n    // 1. If bitLength is 64, then:\n    if (bitLength === 64) {\n        // 1. Let upperBound be 2^53 − 1.\n        upperBound = Math.pow(2, 53) - 1;\n        // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n        if (signedness === 'unsigned') lowerBound = 0;\n        else // 3. Otherwise let lowerBound be −2^53 + 1.\n        lowerBound = Math.pow(-2, 53) + 1;\n    } else if (signedness === 'unsigned') {\n        // 2. Otherwise, if signedness is \"unsigned\", then:\n        // 1. Let lowerBound be 0.\n        lowerBound = 0;\n        // 2. Let upperBound be 2^bitLength − 1.\n        upperBound = Math.pow(2, bitLength) - 1;\n    } else {\n        // 3. Otherwise:\n        // 1. Let lowerBound be -2^bitLength − 1.\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        // 2. Let upperBound be 2^bitLength − 1 − 1.\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n    }\n    // 4. Let x be ? ToNumber(V).\n    let x = Number(V);\n    // 5. If x is −0, then set x to +0.\n    if (x === 0) x = 0;\n    // 6. If the conversion is to an IDL type associated\n    //    with the [EnforceRange] extended attribute, then:\n    if (opts.enforceRange === true) {\n        // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) throw $e16d8374983b673a$var$webidl.errors.exception({\n            header: 'Integer conversion',\n            message: `Could not convert ${V} to an integer.`\n        });\n        // 2. Set x to IntegerPart(x).\n        x = $e16d8374983b673a$var$webidl.util.IntegerPart(x);\n        // 3. If x < lowerBound or x > upperBound, then\n        //    throw a TypeError.\n        if (x < lowerBound || x > upperBound) throw $e16d8374983b673a$var$webidl.errors.exception({\n            header: 'Integer conversion',\n            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n        });\n        // 4. Return x.\n        return x;\n    }\n    // 7. If x is not NaN and the conversion is to an IDL\n    //    type associated with the [Clamp] extended\n    //    attribute, then:\n    if (!Number.isNaN(x) && opts.clamp === true) {\n        // 1. Set x to min(max(x, lowerBound), upperBound).\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        // 2. Round x to the nearest integer, choosing the\n        //    even integer if it lies halfway between two,\n        //    and choosing +0 rather than −0.\n        if (Math.floor(x) % 2 === 0) x = Math.floor(x);\n        else x = Math.ceil(x);\n        // 3. Return x.\n        return x;\n    }\n    // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) return 0;\n    // 9. Set x to IntegerPart(x).\n    x = $e16d8374983b673a$var$webidl.util.IntegerPart(x);\n    // 10. Set x to x modulo 2^bitLength.\n    x = x % Math.pow(2, bitLength);\n    // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n    //    then return x − 2^bitLength.\n    if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) return x - Math.pow(2, bitLength);\n    // 12. Otherwise, return x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\n$e16d8374983b673a$var$webidl.util.IntegerPart = function(n) {\n    // 1. Let r be floor(abs(n)).\n    const r = Math.floor(Math.abs(n));\n    // 2. If n < 0, then return -1 × r.\n    if (n < 0) return -1 * r;\n    // 3. Otherwise, return r.\n    return r;\n};\n// https://webidl.spec.whatwg.org/#es-sequence\n$e16d8374983b673a$var$webidl.sequenceConverter = function(converter) {\n    return (V)=>{\n        // 1. If Type(V) is not Object, throw a TypeError.\n        if ($e16d8374983b673a$var$webidl.util.Type(V) !== 'Object') throw $e16d8374983b673a$var$webidl.errors.exception({\n            header: 'Sequence',\n            message: `Value of type ${$e16d8374983b673a$var$webidl.util.Type(V)} is not an Object.`\n        });\n        // 2. Let method be ? GetMethod(V, @@iterator).\n        /** @type {Generator} */ const method = V?.[Symbol.iterator]?.();\n        const seq = [];\n        // 3. If method is undefined, throw a TypeError.\n        if (method === undefined || typeof method.next !== 'function') throw $e16d8374983b673a$var$webidl.errors.exception({\n            header: 'Sequence',\n            message: 'Object is not an iterator.'\n        });\n        // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n        while(true){\n            const { done: done, value: value } = method.next();\n            if (done) break;\n            seq.push(converter(value));\n        }\n        return seq;\n    };\n};\n// https://webidl.spec.whatwg.org/#es-to-record\n$e16d8374983b673a$var$webidl.recordConverter = function(keyConverter, valueConverter) {\n    return (O)=>{\n        // 1. If Type(O) is not Object, throw a TypeError.\n        if ($e16d8374983b673a$var$webidl.util.Type(O) !== 'Object') throw $e16d8374983b673a$var$webidl.errors.exception({\n            header: 'Record',\n            message: `Value of type ${$e16d8374983b673a$var$webidl.util.Type(O)} is not an Object.`\n        });\n        // 2. Let result be a new empty instance of record<K, V>.\n        const result = {};\n        if (!$e16d8374983b673a$require$types.isProxy(O)) {\n            // Object.keys only returns enumerable properties\n            const keys = Object.keys(O);\n            for (const key of keys){\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key]);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n            // 5. Return result.\n            return result;\n        }\n        // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n        const keys = Reflect.ownKeys(O);\n        // 4. For each key of keys.\n        for (const key of keys){\n            // 1. Let desc be ? O.[[GetOwnProperty]](key).\n            const desc = Reflect.getOwnPropertyDescriptor(O, key);\n            // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n            if (desc?.enumerable) {\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key]);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n        }\n        // 5. Return result.\n        return result;\n    };\n};\n$e16d8374983b673a$var$webidl.interfaceConverter = function(i) {\n    return (V, opts = {})=>{\n        if (opts.strict !== false && !(V instanceof i)) throw $e16d8374983b673a$var$webidl.errors.exception({\n            header: i.name,\n            message: `Expected ${V} to be an instance of ${i.name}.`\n        });\n        return V;\n    };\n};\n$e16d8374983b673a$var$webidl.dictionaryConverter = function(converters) {\n    return (dictionary)=>{\n        const type = $e16d8374983b673a$var$webidl.util.Type(dictionary);\n        const dict = {};\n        if (type === 'Null' || type === 'Undefined') return dict;\n        else if (type !== 'Object') throw $e16d8374983b673a$var$webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n        });\n        for (const options of converters){\n            const { key: key, defaultValue: defaultValue, required: required, converter: converter } = options;\n            if (required === true) {\n                if (!$e16d8374983b673a$require$hasOwn(dictionary, key)) throw $e16d8374983b673a$var$webidl.errors.exception({\n                    header: 'Dictionary',\n                    message: `Missing required key \"${key}\".`\n                });\n            }\n            let value = dictionary[key];\n            const hasDefault = $e16d8374983b673a$require$hasOwn(options, 'defaultValue');\n            // Only use defaultValue if value is undefined and\n            // a defaultValue options was provided.\n            if (hasDefault && value !== null) value = value ?? defaultValue;\n            // A key can be optional and have no default value.\n            // When this happens, do not perform a conversion,\n            // and do not assign the key a value.\n            if (required || hasDefault || value !== undefined) {\n                value = converter(value);\n                if (options.allowedValues && !options.allowedValues.includes(value)) throw $e16d8374983b673a$var$webidl.errors.exception({\n                    header: 'Dictionary',\n                    message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n                });\n                dict[key] = value;\n            }\n        }\n        return dict;\n    };\n};\n$e16d8374983b673a$var$webidl.nullableConverter = function(converter) {\n    return (V)=>{\n        if (V === null) return V;\n        return converter(V);\n    };\n};\n// https://webidl.spec.whatwg.org/#es-DOMString\n$e16d8374983b673a$var$webidl.converters.DOMString = function(V, opts = {}) {\n    // 1. If V is null and the conversion is to an IDL type\n    //    associated with the [LegacyNullToEmptyString]\n    //    extended attribute, then return the DOMString value\n    //    that represents the empty string.\n    if (V === null && opts.legacyNullToEmptyString) return '';\n    // 2. Let x be ? ToString(V).\n    if (typeof V === 'symbol') throw new TypeError('Could not convert argument of type symbol to string.');\n    // 3. Return the IDL DOMString value that represents the\n    //    same sequence of code units as the one the\n    //    ECMAScript String value x represents.\n    return String(V);\n};\n// https://webidl.spec.whatwg.org/#es-ByteString\n$e16d8374983b673a$var$webidl.converters.ByteString = function(V) {\n    // 1. Let x be ? ToString(V).\n    // Note: DOMString converter perform ? ToString(V)\n    const x = $e16d8374983b673a$var$webidl.converters.DOMString(V);\n    // 2. If the value of any element of x is greater than\n    //    255, then throw a TypeError.\n    for(let index = 0; index < x.length; index++){\n        if (x.charCodeAt(index) > 255) throw new TypeError('Cannot convert argument to a ByteString because the character at ' + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);\n    }\n    // 3. Return an IDL ByteString value whose length is the\n    //    length of x, and where the value of each element is\n    //    the value of the corresponding element of x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-USVString\n$e16d8374983b673a$var$webidl.converters.USVString = $e16d8374983b673a$require$toUSVString;\n// https://webidl.spec.whatwg.org/#es-boolean\n$e16d8374983b673a$var$webidl.converters.boolean = function(V) {\n    // 1. Let x be the result of computing ToBoolean(V).\n    const x = Boolean(V);\n    // 2. Return the IDL boolean value that is the one that represents\n    //    the same truth value as the ECMAScript Boolean value x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-any\n$e16d8374983b673a$var$webidl.converters.any = function(V) {\n    return V;\n};\n// https://webidl.spec.whatwg.org/#es-long-long\n$e16d8374983b673a$var$webidl.converters['long long'] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n    const x = $e16d8374983b673a$var$webidl.util.ConvertToInt(V, 64, 'signed');\n    // 2. Return the IDL long long value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\n$e16d8374983b673a$var$webidl.converters['unsigned long long'] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n    const x = $e16d8374983b673a$var$webidl.util.ConvertToInt(V, 64, 'unsigned');\n    // 2. Return the IDL unsigned long long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long\n$e16d8374983b673a$var$webidl.converters['unsigned long'] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n    const x = $e16d8374983b673a$var$webidl.util.ConvertToInt(V, 32, 'unsigned');\n    // 2. Return the IDL unsigned long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-short\n$e16d8374983b673a$var$webidl.converters['unsigned short'] = function(V, opts) {\n    // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n    const x = $e16d8374983b673a$var$webidl.util.ConvertToInt(V, 16, 'unsigned', opts);\n    // 2. Return the IDL unsigned short value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\n$e16d8374983b673a$var$webidl.converters.ArrayBuffer = function(V, opts = {}) {\n    // 1. If Type(V) is not Object, or V does not have an\n    //    [[ArrayBufferData]] internal slot, then throw a\n    //    TypeError.\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n    if ($e16d8374983b673a$var$webidl.util.Type(V) !== 'Object' || !$e16d8374983b673a$require$types.isAnyArrayBuffer(V)) throw $e16d8374983b673a$var$webidl.errors.conversionFailed({\n        prefix: `${V}`,\n        argument: `${V}`,\n        types: [\n            'ArrayBuffer'\n        ]\n    });\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    if (opts.allowShared === false && $e16d8374983b673a$require$types.isSharedArrayBuffer(V)) throw $e16d8374983b673a$var$webidl.errors.exception({\n        header: 'ArrayBuffer',\n        message: 'SharedArrayBuffer is not allowed.'\n    });\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    // Note: resizable ArrayBuffers are currently a proposal.\n    // 4. Return the IDL ArrayBuffer value that is a\n    //    reference to the same object as V.\n    return V;\n};\n$e16d8374983b673a$var$webidl.converters.TypedArray = function(V, T, opts = {}) {\n    // 1. Let T be the IDL type V is being converted to.\n    // 2. If Type(V) is not Object, or V does not have a\n    //    [[TypedArrayName]] internal slot with a value\n    //    equal to T’s name, then throw a TypeError.\n    if ($e16d8374983b673a$var$webidl.util.Type(V) !== 'Object' || !$e16d8374983b673a$require$types.isTypedArray(V) || V.constructor.name !== T.name) throw $e16d8374983b673a$var$webidl.errors.conversionFailed({\n        prefix: `${T.name}`,\n        argument: `${V}`,\n        types: [\n            T.name\n        ]\n    });\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (opts.allowShared === false && $e16d8374983b673a$require$types.isSharedArrayBuffer(V.buffer)) throw $e16d8374983b673a$var$webidl.errors.exception({\n        header: 'ArrayBuffer',\n        message: 'SharedArrayBuffer is not allowed.'\n    });\n    // 4. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    // Note: resizable array buffers are currently a proposal\n    // 5. Return the IDL value of type T that is a reference\n    //    to the same object as V.\n    return V;\n};\n$e16d8374983b673a$var$webidl.converters.DataView = function(V, opts = {}) {\n    // 1. If Type(V) is not Object, or V does not have a\n    //    [[DataView]] internal slot, then throw a TypeError.\n    if ($e16d8374983b673a$var$webidl.util.Type(V) !== 'Object' || !$e16d8374983b673a$require$types.isDataView(V)) throw $e16d8374983b673a$var$webidl.errors.exception({\n        header: 'DataView',\n        message: 'Object is not a DataView.'\n    });\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n    //    then throw a TypeError.\n    if (opts.allowShared === false && $e16d8374983b673a$require$types.isSharedArrayBuffer(V.buffer)) throw $e16d8374983b673a$var$webidl.errors.exception({\n        header: 'ArrayBuffer',\n        message: 'SharedArrayBuffer is not allowed.'\n    });\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    // Note: resizable ArrayBuffers are currently a proposal\n    // 4. Return the IDL DataView value that is a reference\n    //    to the same object as V.\n    return V;\n};\n// https://webidl.spec.whatwg.org/#BufferSource\n$e16d8374983b673a$var$webidl.converters.BufferSource = function(V, opts = {}) {\n    if ($e16d8374983b673a$require$types.isAnyArrayBuffer(V)) return $e16d8374983b673a$var$webidl.converters.ArrayBuffer(V, opts);\n    if ($e16d8374983b673a$require$types.isTypedArray(V)) return $e16d8374983b673a$var$webidl.converters.TypedArray(V, V.constructor);\n    if ($e16d8374983b673a$require$types.isDataView(V)) return $e16d8374983b673a$var$webidl.converters.DataView(V, opts);\n    throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n};\n$e16d8374983b673a$var$webidl.converters['sequence<ByteString>'] = $e16d8374983b673a$var$webidl.sequenceConverter($e16d8374983b673a$var$webidl.converters.ByteString);\n$e16d8374983b673a$var$webidl.converters['sequence<sequence<ByteString>>'] = $e16d8374983b673a$var$webidl.sequenceConverter($e16d8374983b673a$var$webidl.converters['sequence<ByteString>']);\n$e16d8374983b673a$var$webidl.converters['record<ByteString, ByteString>'] = $e16d8374983b673a$var$webidl.recordConverter($e16d8374983b673a$var$webidl.converters.ByteString, $e16d8374983b673a$var$webidl.converters.ByteString);\n$e16d8374983b673a$exports = {\n    webidl: $e16d8374983b673a$var$webidl\n};\n\n\nexport {$e16d8374983b673a$exports as default};\n//# sourceMappingURL=python-version-check.801bb0f1.js.map\n","'use strict'\n\nconst { types } = require('util')\nconst { hasOwn, toUSVString } = require('./util')\n\n/** @type {import('../../types/webidl').Webidl} */\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts = undefined) {\n  if (opts?.strict !== false && !(V instanceof I)) {\n    throw new TypeError('Illegal invocation')\n  } else {\n    return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag]\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      ...ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${V} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Sequence',\n        message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = V?.[Symbol.iterator]?.()\n    const seq = []\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: 'Sequence',\n        message: 'Object is not an iterator.'\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Record',\n        message: `Value of type ${webidl.util.Type(O)} is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // Object.keys only returns enumerable properties\n      const keys = Object.keys(O)\n\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key])\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key])\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, opts = {}) => {\n    if (opts.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: i.name,\n        message: `Expected ${V} to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type === 'Null' || type === 'Undefined') {\n      return dict\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: 'Dictionary',\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value = value ?? defaultValue\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: 'Dictionary',\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, opts = {}) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw new TypeError('Could not convert argument of type symbol to string.')\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed')\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned')\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned')\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix: `${V}`,\n      argument: `${V}`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal.\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, opts = {}) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix: `${T.name}`,\n      argument: `${V}`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable array buffers are currently a proposal\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: 'DataView',\n      message: 'Object is not a DataView.'\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, opts = {}) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, opts)\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor)\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, opts)\n  }\n\n  throw new TypeError(`Could not convert ${V} to a BufferSource.`)\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n"],"names":["$1vZ1t$pythonversioncheck3f48d3eejs1","types","$1vZ1t$types","$e16d8374983b673a$exports","$e16d8374983b673a$require$hasOwn","$1vZ1t$pythonversioncheck3f48d3eejs","hasOwn","$e16d8374983b673a$require$toUSVString","toUSVString","$e16d8374983b673a$var$webidl","converters","util","errors","exception","message","TypeError","header","conversionFailed","context","plural","length","argument","join","prefix","invalidArgument","value","type","brandCheck","V","I","opts","strict","Symbol","toStringTag","prototype","argumentLengthCheck","min","ctx","illegalConstructor","Type","ConvertToInt","bitLength","signedness","upperBound","lowerBound","Math","pow","x","Number","enforceRange","isNaN","IntegerPart","clamp","Object","is","floor","max","ceil","n","r","abs","sequenceConverter","converter","method","iterator","seq","undefined","next","done","push","recordConverter","keyConverter","valueConverter","O","result","$e16d8374983b673a$require$types","isProxy","key","keys","typedKey","typedValue","Reflect","ownKeys","desc","getOwnPropertyDescriptor","enumerable","interfaceConverter","i","name","dictionaryConverter","dictionary","dict","options","defaultValue","required","hasDefault","allowedValues","includes","nullableConverter","DOMString","legacyNullToEmptyString","String","ByteString","index","charCodeAt","USVString","boolean","Boolean","any","ArrayBuffer","isAnyArrayBuffer","allowShared","isSharedArrayBuffer","TypedArray","T","isTypedArray","buffer","DataView","isDataView","BufferSource","webidl","default"],"version":3,"file":"python-version-check.801bb0f1.js.map","sourceRoot":"../"}