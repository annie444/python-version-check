{"mappings":"A,O,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,S,C,K,M,A,Q,iB,C,K,gB,A,Q,Q,C,K,Q,C,I,E,C,ECEM,EAAA,EAAA,MAAA,CAAA,EAAA,sDAAA,MAAA,CAAA,EAAA,sDAAA,OAAA,CAAA,EAAA,qDAAA,QAAA,CAAA,EAAA,sDAAA,uBAAA,CAOA,EAAA,EAAA,aAAA,CACA,EAAA,EAAA,WAAA,CACA,EAAA,EAAA,YAAA,CACA,EAAA,EAAA,kBAAA,CAAA,EAAA,qDAAA,aAAA,CAyLN,SAAS,EAAoB,CAAC,CAAE,CAAM,EAGpC,IAAM,EAAQ,IAAA,EAAkB,EAAG,CACjC,QAAS,CAAA,EACT,WAAY,CAAA,CACd,GAEA,EAAO,aAAa,CAAC,EACvB,CAuKA,SAAS,EAAsB,CAAS,EACtC,IAAM,EAAO,EAAU,MAAM,CAAC,CAAC,EAAG,IACzB,EAAI,EAAE,UAAU,CACtB,GAEC,EAAS,EAEb,OAAO,EAAU,MAAM,CAAC,CAAC,EAAG,KAC1B,EAAE,GAAG,CAAC,EAAG,GACT,GAAU,EAAE,UAAU,CACf,GACN,IAAI,WAAW,GACpB,CAEA,EAAiB,CACf,0BAlXgC,CAChC,WAAY,CAAA,EACZ,SAAU,CAAA,EACV,aAAc,CAAA,CAChB,EA+WE,cAtWF,SAAwB,CAAE,CAAE,CAAI,CAAE,CAAI,CAAE,CAAY,EAGlD,GAAI,AAAe,YAAf,CAAE,CAAA,EAAQ,CACZ,MAAM,IAAA,EAAiB,gBAAiB,oBAI1C,CAAA,CAAE,CAAA,EAAQ,CAAG,UAGb,CAAE,CAAA,EAAS,CAAG,KAGd,CAAE,CAAA,EAAQ,CAAG,KAOb,IAAM,EAAS,AAHA,EAAK,MAAM,GAGJ,SAAS,GAIzB,EAAQ,EAAE,CAIZ,EAAe,EAAO,IAAI,GAG1B,EAAe,CAAA,EAOjB,AAAA,CAAA,UACA,KAAO,CAAC,CAAE,CAAA,EAAU,EAElB,GAAI,CACF,GAAM,CAAA,KAAE,CAAI,CAAA,MAAE,CAAK,CAAE,CAAG,MAAM,EAiB9B,GAZI,GAAgB,CAAC,CAAE,CAAA,EAAU,EAC/B,eAAe,KACb,EAAmB,YAAa,EAClC,GAIF,EAAe,CAAA,EAKX,CAAC,GAAQ,AA9Ef,EA8EqB,YAAY,CAAC,GAK9B,EAAM,IAAI,CAAC,GAOP,CAAA,AAAgC,KAAA,IAAhC,CAAE,CAAA,EAAyB,EAC3B,KAAK,GAAG,GAAK,CAAE,CAAA,EAAyB,EAAI,EAAA,GAE9C,CAAC,CAAE,CAAA,EAAU,GAEb,CAAE,CAAA,EAAyB,CAAG,KAAK,GAAG,GACtC,eAAe,KACb,EAAmB,WAAY,EACjC,IAKF,EAAe,EAAO,IAAI,QACrB,GAAI,EAAM,CAIf,eAAe,KAEb,CAAE,CAAA,EAAQ,CAAG,OAIb,GAAI,CACF,IAAM,EAAS,AAuF7B,SAAsB,CAAK,CAAE,CAAI,CAAE,CAAQ,CAAE,CAAY,EAMvD,OAAQ,GACN,IAAK,UAAW,CAcd,IAAI,EAAU,QAER,EAAS,EAAc,GAAY,2BAErC,AAAW,CAAA,YAAX,GACF,CAAA,GAAW,EAAmB,EADhC,EAIA,GAAW,WAEX,IAAM,EAAU,IAxOhB,EAwOkC,UAElC,IAAK,IAAM,KAAS,EAClB,GAAW,AA1Ob,EA0OkB,EAAQ,KAAK,CAAC,IAKhC,OAFA,GAAW,AA7OX,EA6OgB,EAAQ,GAAG,GAG7B,CACA,IAAK,OAAQ,CAEX,IAAI,EAAW,UASf,GALI,GACF,CAAA,EAAW,EAAY,EADzB,EAKI,AAAa,YAAb,GAA0B,EAAU,CAGtC,IAAM,EAAO,EAAc,EAIvB,AAAS,CAAA,YAAT,GACF,CAAA,EAAW,EAAY,EAAK,UAAU,CAAC,GAAG,CAAC,WAD7C,CAGF,CASA,MANI,AAAa,YAAb,GACF,CAAA,EAAW,OADb,EAMO,AA+Bb,SAAiB,CAAO,CAAE,CAAQ,EAChC,IAAM,EAAQ,EAAqB,GAG7B,EAAc,AA4BtB,SAAsB,CAAO,EAG3B,GAAM,CAAC,EAAG,EAAG,EAAE,CAAG,SAOlB,AAAI,AAAM,MAAN,GAAc,AAAM,MAAN,GAAc,AAAM,MAAN,EACvB,QACE,AAAM,MAAN,GAAc,AAAM,MAAN,EAChB,WACE,AAAM,MAAN,GAAc,AAAM,MAAN,EAChB,WAGF,IACT,EA/CkC,GAE5B,EAAQ,CAGQ,QAAhB,IAEF,EAAW,EAKX,EAAQ,AAAgB,UAAhB,EAA0B,EAAI,GAQxC,IAAM,EAAS,EAAM,KAAK,CAAC,GAC3B,OAAO,IAAI,YAAY,GAAU,MAAM,CAAC,EAC1C,EAzDoB,EAAO,EACvB,CACA,IAAK,cAIH,OAAO,AAFU,EAAqB,GAEtB,MAAM,AAExB,KAAK,eAAgB,CAGnB,IAAI,EAAe,GAEb,EAAU,IA7RhB,EA6RkC,UAElC,IAAK,IAAM,KAAS,EAClB,GAAgB,EAAQ,KAAK,CAAC,GAKhC,OAFA,GAAgB,EAAQ,GAAG,EAG7B,CACF,CACF,EAtLyC,EAAO,EAAM,EAAK,IAAI,CAAE,GAInD,GAAI,CAAE,CAAA,EAAU,CACd,MAIF,CAAA,CAAE,CAAA,EAAS,CAAG,EAGd,EAAmB,OAAQ,EAC7B,CAAE,MAAO,EAAO,CAId,CAAE,CAAA,EAAQ,CAAG,EAGb,EAAmB,QAAS,EAC9B,CAII,AAAe,YAAf,CAAE,CAAA,EAAQ,EACZ,EAAmB,UAAW,EAElC,GAEA,KACF,CACF,CAAE,MAAO,EAAO,CACd,GAAI,CAAE,CAAA,EAAU,CACd,OAMF,eAAe,KAEb,CAAE,CAAA,EAAQ,CAAG,OAGb,CAAE,CAAA,EAAQ,CAAG,EAGb,EAAmB,QAAS,GAIxB,AAAe,YAAf,CAAE,CAAA,EAAQ,EACZ,EAAmB,UAAW,EAElC,GAEA,KACF,CAEJ,CAAA,GACF,EAyME,mBAAA,CACF,S,K,O","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/util.js"],"sourcesContent":["import $bByBn$pythonversioncheck00c0aa48js4 from \"./python-version-check.00c0aa48.js\";\nimport $bByBn$pythonversioncheckd50fdc0fjs from \"./python-version-check.d50fdc0f.js\";\nimport $bByBn$pythonversionchecka70f1a4bjs from \"./python-version-check.a70f1a4b.js\";\nimport $bByBn$pythonversioncheck863e006ejs from \"./python-version-check.863e006e.js\";\nimport $bByBn$pythonversioncheck685b5bb2js1 from \"./python-version-check.685b5bb2.js\";\nimport {types as $bByBn$types} from \"util\";\nimport {StringDecoder as $bByBn$StringDecoder} from \"string_decoder\";\nimport {btoa as $bByBn$btoa} from \"buffer\";\n\nvar $cef634249f18b80b$exports = {};\n'use strict';\n\nvar $cef634249f18b80b$require$kState = $bByBn$pythonversioncheck00c0aa48js4.kState;\nvar $cef634249f18b80b$require$kError = $bByBn$pythonversioncheck00c0aa48js1.kError;\nvar $cef634249f18b80b$require$kResult = $bByBn$pythonversioncheck00c0aa48js3.kResult;\nvar $cef634249f18b80b$require$kAborted = $bByBn$pythonversioncheck00c0aa48js.kAborted;\nvar $cef634249f18b80b$require$kLastProgressEventFired = $bByBn$pythonversioncheck00c0aa48js2.kLastProgressEventFired;\n\nvar $cef634249f18b80b$require$ProgressEvent = $bByBn$pythonversioncheckd50fdc0fjs.ProgressEvent;\n\nvar $cef634249f18b80b$require$getEncoding = $bByBn$pythonversionchecka70f1a4bjs.getEncoding;\n\nvar $cef634249f18b80b$require$DOMException = $bByBn$pythonversioncheck863e006ejs.DOMException;\n\nvar $cef634249f18b80b$require$serializeAMimeType = $bByBn$pythonversioncheck685b5bb2js1.serializeAMimeType;\nvar $cef634249f18b80b$require$parseMIMEType = $bByBn$pythonversioncheck685b5bb2js.parseMIMEType;\n\nvar $cef634249f18b80b$require$types = $bByBn$types;\n\nvar $cef634249f18b80b$require$StringDecoder = $bByBn$StringDecoder;\n\nvar $cef634249f18b80b$require$btoa = $bByBn$btoa;\n/** @type {PropertyDescriptor} */ const $cef634249f18b80b$var$staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */ function $cef634249f18b80b$var$readOperation(fr, blob, type, encodingName) {\n    // 1. If fr’s state is \"loading\", throw an InvalidStateError\n    //    DOMException.\n    if (fr[$cef634249f18b80b$require$kState] === 'loading') throw new $cef634249f18b80b$require$DOMException('Invalid state', 'InvalidStateError');\n    // 2. Set fr’s state to \"loading\".\n    fr[$cef634249f18b80b$require$kState] = 'loading';\n    // 3. Set fr’s result to null.\n    fr[$cef634249f18b80b$require$kResult] = null;\n    // 4. Set fr’s error to null.\n    fr[$cef634249f18b80b$require$kError] = null;\n    // 5. Let stream be the result of calling get stream on blob.\n    /** @type {import('stream/web').ReadableStream} */ const stream = blob.stream();\n    // 6. Let reader be the result of getting a reader from stream.\n    const reader = stream.getReader();\n    // 7. Let bytes be an empty byte sequence.\n    /** @type {Uint8Array[]} */ const bytes = [];\n    // 8. Let chunkPromise be the result of reading a chunk from\n    //    stream with reader.\n    let chunkPromise = reader.read();\n    // 9. Let isFirstChunk be true.\n    let isFirstChunk = true;\n    (async ()=>{\n        while(!fr[$cef634249f18b80b$require$kAborted])// 1. Wait for chunkPromise to be fulfilled or rejected.\n        try {\n            const { done: done, value: value } = await chunkPromise;\n            // 2. If chunkPromise is fulfilled, and isFirstChunk is\n            //    true, queue a task to fire a progress event called\n            //    loadstart at fr.\n            if (isFirstChunk && !fr[$cef634249f18b80b$require$kAborted]) queueMicrotask(()=>{\n                $cef634249f18b80b$var$fireAProgressEvent('loadstart', fr);\n            });\n            // 3. Set isFirstChunk to false.\n            isFirstChunk = false;\n            // 4. If chunkPromise is fulfilled with an object whose\n            //    done property is false and whose value property is\n            //    a Uint8Array object, run these steps:\n            if (!done && $cef634249f18b80b$require$types.isUint8Array(value)) {\n                // 1. Let bs be the byte sequence represented by the\n                //    Uint8Array object.\n                // 2. Append bs to bytes.\n                bytes.push(value);\n                // 3. If roughly 50ms have passed since these steps\n                //    were last invoked, queue a task to fire a\n                //    progress event called progress at fr.\n                if ((fr[$cef634249f18b80b$require$kLastProgressEventFired] === undefined || Date.now() - fr[$cef634249f18b80b$require$kLastProgressEventFired] >= 50) && !fr[$cef634249f18b80b$require$kAborted]) {\n                    fr[$cef634249f18b80b$require$kLastProgressEventFired] = Date.now();\n                    queueMicrotask(()=>{\n                        $cef634249f18b80b$var$fireAProgressEvent('progress', fr);\n                    });\n                }\n                // 4. Set chunkPromise to the result of reading a\n                //    chunk from stream with reader.\n                chunkPromise = reader.read();\n            } else if (done) {\n                // 5. Otherwise, if chunkPromise is fulfilled with an\n                //    object whose done property is true, queue a task\n                //    to run the following steps and abort this algorithm:\n                queueMicrotask(()=>{\n                    // 1. Set fr’s state to \"done\".\n                    fr[$cef634249f18b80b$require$kState] = 'done';\n                    // 2. Let result be the result of package data given\n                    //    bytes, type, blob’s type, and encodingName.\n                    try {\n                        const result = $cef634249f18b80b$var$packageData(bytes, type, blob.type, encodingName);\n                        // 4. Else:\n                        if (fr[$cef634249f18b80b$require$kAborted]) return;\n                        // 1. Set fr’s result to result.\n                        fr[$cef634249f18b80b$require$kResult] = result;\n                        // 2. Fire a progress event called load at the fr.\n                        $cef634249f18b80b$var$fireAProgressEvent('load', fr);\n                    } catch (error) {\n                        // 3. If package data threw an exception error:\n                        // 1. Set fr’s error to error.\n                        fr[$cef634249f18b80b$require$kError] = error;\n                        // 2. Fire a progress event called error at fr.\n                        $cef634249f18b80b$var$fireAProgressEvent('error', fr);\n                    }\n                    // 5. If fr’s state is not \"loading\", fire a progress\n                    //    event called loadend at the fr.\n                    if (fr[$cef634249f18b80b$require$kState] !== 'loading') $cef634249f18b80b$var$fireAProgressEvent('loadend', fr);\n                });\n                break;\n            }\n        } catch (error) {\n            if (fr[$cef634249f18b80b$require$kAborted]) return;\n            // 6. Otherwise, if chunkPromise is rejected with an\n            //    error error, queue a task to run the following\n            //    steps and abort this algorithm:\n            queueMicrotask(()=>{\n                // 1. Set fr’s state to \"done\".\n                fr[$cef634249f18b80b$require$kState] = 'done';\n                // 2. Set fr’s error to error.\n                fr[$cef634249f18b80b$require$kError] = error;\n                // 3. Fire a progress event called error at fr.\n                $cef634249f18b80b$var$fireAProgressEvent('error', fr);\n                // 4. If fr’s state is not \"loading\", fire a progress\n                //    event called loadend at fr.\n                if (fr[$cef634249f18b80b$require$kState] !== 'loading') $cef634249f18b80b$var$fireAProgressEvent('loadend', fr);\n            });\n            break;\n        }\n    })();\n}\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */ function $cef634249f18b80b$var$fireAProgressEvent(e, reader) {\n    // The progress event e does not bubble. e.bubbles must be false\n    // The progress event e is NOT cancelable. e.cancelable must be false\n    const event = new $cef634249f18b80b$require$ProgressEvent(e, {\n        bubbles: false,\n        cancelable: false\n    });\n    reader.dispatchEvent(event);\n}\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */ function $cef634249f18b80b$var$packageData(bytes, type, mimeType, encodingName) {\n    // 1. A Blob has an associated package data algorithm, given\n    //    bytes, a type, a optional mimeType, and a optional\n    //    encodingName, which switches on type and runs the\n    //    associated steps:\n    switch(type){\n        case 'DataURL':\n            {\n                // 1. Return bytes as a DataURL [RFC2397] subject to\n                //    the considerations below:\n                //  * Use mimeType as part of the Data URL if it is\n                //    available in keeping with the Data URL\n                //    specification [RFC2397].\n                //  * If mimeType is not available return a Data URL\n                //    without a media-type. [RFC2397].\n                // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n                // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n                // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n                // data       := *urlchar\n                // parameter  := attribute \"=\" value\n                let dataURL = 'data:';\n                const parsed = $cef634249f18b80b$require$parseMIMEType(mimeType || 'application/octet-stream');\n                if (parsed !== 'failure') dataURL += $cef634249f18b80b$require$serializeAMimeType(parsed);\n                dataURL += ';base64,';\n                const decoder = new $cef634249f18b80b$require$StringDecoder('latin1');\n                for (const chunk of bytes)dataURL += $cef634249f18b80b$require$btoa(decoder.write(chunk));\n                dataURL += $cef634249f18b80b$require$btoa(decoder.end());\n                return dataURL;\n            }\n        case 'Text':\n            {\n                // 1. Let encoding be failure\n                let encoding = 'failure';\n                // 2. If the encodingName is present, set encoding to the\n                //    result of getting an encoding from encodingName.\n                if (encodingName) encoding = $cef634249f18b80b$require$getEncoding(encodingName);\n                // 3. If encoding is failure, and mimeType is present:\n                if (encoding === 'failure' && mimeType) {\n                    // 1. Let type be the result of parse a MIME type\n                    //    given mimeType.\n                    const type = $cef634249f18b80b$require$parseMIMEType(mimeType);\n                    // 2. If type is not failure, set encoding to the result\n                    //    of getting an encoding from type’s parameters[\"charset\"].\n                    if (type !== 'failure') encoding = $cef634249f18b80b$require$getEncoding(type.parameters.get('charset'));\n                }\n                // 4. If encoding is failure, then set encoding to UTF-8.\n                if (encoding === 'failure') encoding = 'UTF-8';\n                // 5. Decode bytes using fallback encoding encoding, and\n                //    return the result.\n                return $cef634249f18b80b$var$decode(bytes, encoding);\n            }\n        case 'ArrayBuffer':\n            {\n                // Return a new ArrayBuffer whose contents are bytes.\n                const sequence = $cef634249f18b80b$var$combineByteSequences(bytes);\n                return sequence.buffer;\n            }\n        case 'BinaryString':\n            {\n                // Return bytes as a binary string, in which every byte\n                //  is represented by a code unit of equal value [0..255].\n                let binaryString = '';\n                const decoder = new $cef634249f18b80b$require$StringDecoder('latin1');\n                for (const chunk of bytes)binaryString += decoder.write(chunk);\n                binaryString += decoder.end();\n                return binaryString;\n            }\n    }\n}\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */ function $cef634249f18b80b$var$decode(ioQueue, encoding) {\n    const bytes = $cef634249f18b80b$var$combineByteSequences(ioQueue);\n    // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n    const BOMEncoding = $cef634249f18b80b$var$BOMSniffing(bytes);\n    let slice = 0;\n    // 2. If BOMEncoding is non-null:\n    if (BOMEncoding !== null) {\n        // 1. Set encoding to BOMEncoding.\n        encoding = BOMEncoding;\n        // 2. Read three bytes from ioQueue, if BOMEncoding is\n        //    UTF-8; otherwise read two bytes.\n        //    (Do nothing with those bytes.)\n        slice = BOMEncoding === 'UTF-8' ? 3 : 2;\n    }\n    // 3. Process a queue with an instance of encoding’s\n    //    decoder, ioQueue, output, and \"replacement\".\n    // 4. Return output.\n    const sliced = bytes.slice(slice);\n    return new TextDecoder(encoding).decode(sliced);\n}\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */ function $cef634249f18b80b$var$BOMSniffing(ioQueue) {\n    // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n    //    converted to a byte sequence.\n    const [a, b, c] = ioQueue;\n    // 2. For each of the rows in the table below, starting with\n    //    the first one and going down, if BOM starts with the\n    //    bytes given in the first column, then return the\n    //    encoding given in the cell in the second column of that\n    //    row. Otherwise, return null.\n    if (a === 0xEF && b === 0xBB && c === 0xBF) return 'UTF-8';\n    else if (a === 0xFE && b === 0xFF) return 'UTF-16BE';\n    else if (a === 0xFF && b === 0xFE) return 'UTF-16LE';\n    return null;\n}\n/**\n * @param {Uint8Array[]} sequences\n */ function $cef634249f18b80b$var$combineByteSequences(sequences) {\n    const size = sequences.reduce((a, b)=>{\n        return a + b.byteLength;\n    }, 0);\n    let offset = 0;\n    return sequences.reduce((a, b)=>{\n        a.set(b, offset);\n        offset += b.byteLength;\n        return a;\n    }, new Uint8Array(size));\n}\n$cef634249f18b80b$exports = {\n    staticPropertyDescriptors: $cef634249f18b80b$var$staticPropertyDescriptors,\n    readOperation: $cef634249f18b80b$var$readOperation,\n    fireAProgressEvent: $cef634249f18b80b$var$fireAProgressEvent\n};\n\n\nexport {$cef634249f18b80b$exports as default};\n//# sourceMappingURL=python-version-check.57470419.js.map\n","'use strict'\n\nconst {\n  kState,\n  kError,\n  kResult,\n  kAborted,\n  kLastProgressEventFired\n} = require('./symbols')\nconst { ProgressEvent } = require('./progressevent')\nconst { getEncoding } = require('./encoding')\nconst { DOMException } = require('../fetch/constants')\nconst { serializeAMimeType, parseMIMEType } = require('../fetch/dataURL')\nconst { types } = require('util')\nconst { StringDecoder } = require('string_decoder')\nconst { btoa } = require('buffer')\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */\nfunction readOperation (fr, blob, type, encodingName) {\n  // 1. If fr’s state is \"loading\", throw an InvalidStateError\n  //    DOMException.\n  if (fr[kState] === 'loading') {\n    throw new DOMException('Invalid state', 'InvalidStateError')\n  }\n\n  // 2. Set fr’s state to \"loading\".\n  fr[kState] = 'loading'\n\n  // 3. Set fr’s result to null.\n  fr[kResult] = null\n\n  // 4. Set fr’s error to null.\n  fr[kError] = null\n\n  // 5. Let stream be the result of calling get stream on blob.\n  /** @type {import('stream/web').ReadableStream} */\n  const stream = blob.stream()\n\n  // 6. Let reader be the result of getting a reader from stream.\n  const reader = stream.getReader()\n\n  // 7. Let bytes be an empty byte sequence.\n  /** @type {Uint8Array[]} */\n  const bytes = []\n\n  // 8. Let chunkPromise be the result of reading a chunk from\n  //    stream with reader.\n  let chunkPromise = reader.read()\n\n  // 9. Let isFirstChunk be true.\n  let isFirstChunk = true\n\n  // 10. In parallel, while true:\n  // Note: \"In parallel\" just means non-blocking\n  // Note 2: readOperation itself cannot be async as double\n  // reading the body would then reject the promise, instead\n  // of throwing an error.\n  ;(async () => {\n    while (!fr[kAborted]) {\n      // 1. Wait for chunkPromise to be fulfilled or rejected.\n      try {\n        const { done, value } = await chunkPromise\n\n        // 2. If chunkPromise is fulfilled, and isFirstChunk is\n        //    true, queue a task to fire a progress event called\n        //    loadstart at fr.\n        if (isFirstChunk && !fr[kAborted]) {\n          queueMicrotask(() => {\n            fireAProgressEvent('loadstart', fr)\n          })\n        }\n\n        // 3. Set isFirstChunk to false.\n        isFirstChunk = false\n\n        // 4. If chunkPromise is fulfilled with an object whose\n        //    done property is false and whose value property is\n        //    a Uint8Array object, run these steps:\n        if (!done && types.isUint8Array(value)) {\n          // 1. Let bs be the byte sequence represented by the\n          //    Uint8Array object.\n\n          // 2. Append bs to bytes.\n          bytes.push(value)\n\n          // 3. If roughly 50ms have passed since these steps\n          //    were last invoked, queue a task to fire a\n          //    progress event called progress at fr.\n          if (\n            (\n              fr[kLastProgressEventFired] === undefined ||\n              Date.now() - fr[kLastProgressEventFired] >= 50\n            ) &&\n            !fr[kAborted]\n          ) {\n            fr[kLastProgressEventFired] = Date.now()\n            queueMicrotask(() => {\n              fireAProgressEvent('progress', fr)\n            })\n          }\n\n          // 4. Set chunkPromise to the result of reading a\n          //    chunk from stream with reader.\n          chunkPromise = reader.read()\n        } else if (done) {\n          // 5. Otherwise, if chunkPromise is fulfilled with an\n          //    object whose done property is true, queue a task\n          //    to run the following steps and abort this algorithm:\n          queueMicrotask(() => {\n            // 1. Set fr’s state to \"done\".\n            fr[kState] = 'done'\n\n            // 2. Let result be the result of package data given\n            //    bytes, type, blob’s type, and encodingName.\n            try {\n              const result = packageData(bytes, type, blob.type, encodingName)\n\n              // 4. Else:\n\n              if (fr[kAborted]) {\n                return\n              }\n\n              // 1. Set fr’s result to result.\n              fr[kResult] = result\n\n              // 2. Fire a progress event called load at the fr.\n              fireAProgressEvent('load', fr)\n            } catch (error) {\n              // 3. If package data threw an exception error:\n\n              // 1. Set fr’s error to error.\n              fr[kError] = error\n\n              // 2. Fire a progress event called error at fr.\n              fireAProgressEvent('error', fr)\n            }\n\n            // 5. If fr’s state is not \"loading\", fire a progress\n            //    event called loadend at the fr.\n            if (fr[kState] !== 'loading') {\n              fireAProgressEvent('loadend', fr)\n            }\n          })\n\n          break\n        }\n      } catch (error) {\n        if (fr[kAborted]) {\n          return\n        }\n\n        // 6. Otherwise, if chunkPromise is rejected with an\n        //    error error, queue a task to run the following\n        //    steps and abort this algorithm:\n        queueMicrotask(() => {\n          // 1. Set fr’s state to \"done\".\n          fr[kState] = 'done'\n\n          // 2. Set fr’s error to error.\n          fr[kError] = error\n\n          // 3. Fire a progress event called error at fr.\n          fireAProgressEvent('error', fr)\n\n          // 4. If fr’s state is not \"loading\", fire a progress\n          //    event called loadend at fr.\n          if (fr[kState] !== 'loading') {\n            fireAProgressEvent('loadend', fr)\n          }\n        })\n\n        break\n      }\n    }\n  })()\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */\nfunction fireAProgressEvent (e, reader) {\n  // The progress event e does not bubble. e.bubbles must be false\n  // The progress event e is NOT cancelable. e.cancelable must be false\n  const event = new ProgressEvent(e, {\n    bubbles: false,\n    cancelable: false\n  })\n\n  reader.dispatchEvent(event)\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */\nfunction packageData (bytes, type, mimeType, encodingName) {\n  // 1. A Blob has an associated package data algorithm, given\n  //    bytes, a type, a optional mimeType, and a optional\n  //    encodingName, which switches on type and runs the\n  //    associated steps:\n\n  switch (type) {\n    case 'DataURL': {\n      // 1. Return bytes as a DataURL [RFC2397] subject to\n      //    the considerations below:\n      //  * Use mimeType as part of the Data URL if it is\n      //    available in keeping with the Data URL\n      //    specification [RFC2397].\n      //  * If mimeType is not available return a Data URL\n      //    without a media-type. [RFC2397].\n\n      // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n      // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n      // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n      // data       := *urlchar\n      // parameter  := attribute \"=\" value\n      let dataURL = 'data:'\n\n      const parsed = parseMIMEType(mimeType || 'application/octet-stream')\n\n      if (parsed !== 'failure') {\n        dataURL += serializeAMimeType(parsed)\n      }\n\n      dataURL += ';base64,'\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        dataURL += btoa(decoder.write(chunk))\n      }\n\n      dataURL += btoa(decoder.end())\n\n      return dataURL\n    }\n    case 'Text': {\n      // 1. Let encoding be failure\n      let encoding = 'failure'\n\n      // 2. If the encodingName is present, set encoding to the\n      //    result of getting an encoding from encodingName.\n      if (encodingName) {\n        encoding = getEncoding(encodingName)\n      }\n\n      // 3. If encoding is failure, and mimeType is present:\n      if (encoding === 'failure' && mimeType) {\n        // 1. Let type be the result of parse a MIME type\n        //    given mimeType.\n        const type = parseMIMEType(mimeType)\n\n        // 2. If type is not failure, set encoding to the result\n        //    of getting an encoding from type’s parameters[\"charset\"].\n        if (type !== 'failure') {\n          encoding = getEncoding(type.parameters.get('charset'))\n        }\n      }\n\n      // 4. If encoding is failure, then set encoding to UTF-8.\n      if (encoding === 'failure') {\n        encoding = 'UTF-8'\n      }\n\n      // 5. Decode bytes using fallback encoding encoding, and\n      //    return the result.\n      return decode(bytes, encoding)\n    }\n    case 'ArrayBuffer': {\n      // Return a new ArrayBuffer whose contents are bytes.\n      const sequence = combineByteSequences(bytes)\n\n      return sequence.buffer\n    }\n    case 'BinaryString': {\n      // Return bytes as a binary string, in which every byte\n      //  is represented by a code unit of equal value [0..255].\n      let binaryString = ''\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        binaryString += decoder.write(chunk)\n      }\n\n      binaryString += decoder.end()\n\n      return binaryString\n    }\n  }\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */\nfunction decode (ioQueue, encoding) {\n  const bytes = combineByteSequences(ioQueue)\n\n  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n  const BOMEncoding = BOMSniffing(bytes)\n\n  let slice = 0\n\n  // 2. If BOMEncoding is non-null:\n  if (BOMEncoding !== null) {\n    // 1. Set encoding to BOMEncoding.\n    encoding = BOMEncoding\n\n    // 2. Read three bytes from ioQueue, if BOMEncoding is\n    //    UTF-8; otherwise read two bytes.\n    //    (Do nothing with those bytes.)\n    slice = BOMEncoding === 'UTF-8' ? 3 : 2\n  }\n\n  // 3. Process a queue with an instance of encoding’s\n  //    decoder, ioQueue, output, and \"replacement\".\n\n  // 4. Return output.\n\n  const sliced = bytes.slice(slice)\n  return new TextDecoder(encoding).decode(sliced)\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */\nfunction BOMSniffing (ioQueue) {\n  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n  //    converted to a byte sequence.\n  const [a, b, c] = ioQueue\n\n  // 2. For each of the rows in the table below, starting with\n  //    the first one and going down, if BOM starts with the\n  //    bytes given in the first column, then return the\n  //    encoding given in the cell in the second column of that\n  //    row. Otherwise, return null.\n  if (a === 0xEF && b === 0xBB && c === 0xBF) {\n    return 'UTF-8'\n  } else if (a === 0xFE && b === 0xFF) {\n    return 'UTF-16BE'\n  } else if (a === 0xFF && b === 0xFE) {\n    return 'UTF-16LE'\n  }\n\n  return null\n}\n\n/**\n * @param {Uint8Array[]} sequences\n */\nfunction combineByteSequences (sequences) {\n  const size = sequences.reduce((a, b) => {\n    return a + b.byteLength\n  }, 0)\n\n  let offset = 0\n\n  return sequences.reduce((a, b) => {\n    a.set(b, offset)\n    offset += b.byteLength\n    return a\n  }, new Uint8Array(size))\n}\n\nmodule.exports = {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n}\n"],"names":["$bByBn$pythonversioncheck00c0aa48js4","$bByBn$pythonversioncheckd50fdc0fjs","$bByBn$pythonversionchecka70f1a4bjs","$bByBn$pythonversioncheck863e006ejs","$bByBn$pythonversioncheck685b5bb2js1","types","$bByBn$types","StringDecoder","$bByBn$StringDecoder","btoa","$bByBn$btoa","$cef634249f18b80b$exports","$cef634249f18b80b$require$kState","kState","$cef634249f18b80b$require$kError","$bByBn$pythonversioncheck00c0aa48js1","kError","$cef634249f18b80b$require$kResult","$bByBn$pythonversioncheck00c0aa48js3","kResult","$cef634249f18b80b$require$kAborted","$bByBn$pythonversioncheck00c0aa48js","kAborted","$cef634249f18b80b$require$kLastProgressEventFired","$bByBn$pythonversioncheck00c0aa48js2","kLastProgressEventFired","$cef634249f18b80b$require$ProgressEvent","ProgressEvent","$cef634249f18b80b$require$getEncoding","getEncoding","$cef634249f18b80b$require$DOMException","DOMException","$cef634249f18b80b$require$serializeAMimeType","serializeAMimeType","$cef634249f18b80b$require$parseMIMEType","$bByBn$pythonversioncheck685b5bb2js","parseMIMEType","$cef634249f18b80b$var$fireAProgressEvent","e","reader","event","bubbles","cancelable","dispatchEvent","$cef634249f18b80b$var$combineByteSequences","sequences","size","reduce","a","b","byteLength","offset","set","Uint8Array","staticPropertyDescriptors","enumerable","writable","configurable","readOperation","fr","blob","type","encodingName","stream","getReader","bytes","chunkPromise","read","isFirstChunk","done","value","queueMicrotask","$cef634249f18b80b$require$types","isUint8Array","push","undefined","Date","now","result","$cef634249f18b80b$var$packageData","mimeType","dataURL","parsed","decoder","chunk","$cef634249f18b80b$require$btoa","write","end","encoding","parameters","get","$cef634249f18b80b$var$decode","ioQueue","BOMEncoding","$cef634249f18b80b$var$BOMSniffing","c","slice","sliced","TextDecoder","decode","sequence","buffer","binaryString","error","fireAProgressEvent","default"],"version":3,"file":"python-version-check.57470419.js.map","sourceRoot":"../"}