{"mappings":"A,O,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,M,qD,A,Q,gB,C,C,a,C,C,iB,C,C,0B,C,K,M,A,W,M,Q,A,W,M,Q,A,Q,Y,C,C,Y,C,K,Q,A,Q,mB,C,C,kB,C,K,Y,A,Q,gB,C,K,M,A,Q,oB,C,K,Q,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,MCmEI,EA/DE,IAAA,EAAA,EAAA,QAAA,CAAA,EAAA,sDAAA,gBAAA,CAAA,EAAA,sDAAA,2BAAA,CAAA,EAAA,qDAAA,cAAA,CAAA,EAAA,sDAAA,YAAA,CAOA,EAAA,EAAA,OAAA,CACA,EAAA,EAAA,OAAA,CAAA,EAAA,qDAAA,WAAA,CAEA,EAAA,sDAAA,UAAA,CAAA,EAAA,uDAAA,mBAAA,CAAA,EAAA,sDAAA,oBAAA,CAAA,EAAA,uDAAA,cAAA,CAAA,EAAA,uDAAA,QAAA,CAAA,EAAA,sDAAA,yBAAA,CAAA,EAAA,uDAAA,mBAAA,CAAA,EAAA,uDAAA,iBAAA,CAAA,EAAA,uDAAA,kCAAA,CAAA,EAAA,uDAAA,6CAAA,CAAA,EAAA,sDAAA,sBAAA,CAAA,EAAA,qDAAA,mBAAA,CAAA,EAAA,sDAAA,SAAA,CAAA,EAAA,sDAAA,8BAAA,CAAA,EAAA,sDAAA,yBAAA,CAAA,EAAA,sDAAA,0BAAA,CAAA,EAAA,sDAAA,qBAAA,CAAA,EAAA,uDAAA,UAAA,CAAA,EAAA,uDAAA,UAAA,CAAA,GAAA,uDAAA,WAAA,CAAA,GAAA,uDAAA,SAAA,CAAA,GAAA,uDAAA,WAAA,CAAA,GAAA,uDAAA,aAAA,CAAA,GAAA,uDAAA,mBAAA,CAAA,GAAA,uDAAA,gBAAA,CAAA,GAAA,EAAA,U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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js"],"sourcesContent":["import $jEVl2$pythonversioncheckc211052ejs4 from \"./python-version-check.c211052e.js\";\nimport $jEVl2$pythonversioncheck5597d583js from \"./python-version-check.5597d583.js\";\nimport $jEVl2$pythonversioncheckff3942bajs1 from \"./python-version-check.ff3942ba.js\";\nimport $jEVl2$pythonversioncheck3f48d3eejs27 from \"./python-version-check.3f48d3ee.js\";\nimport $jEVl2$pythonversioncheck92c00e26js3 from \"./python-version-check.92c00e26.js\";\nimport $jEVl2$pythonversioncheck152f8bbajs from \"./python-version-check.152f8bba.js\";\nimport $jEVl2$pythonversioncheck863e006ejs5 from \"./python-version-check.863e006e.js\";\nimport $jEVl2$pythonversioncheckebf2a848js from \"./python-version-check.ebf2a848.js\";\nimport $jEVl2$pythonversioncheck7ed1514ejs4 from \"./python-version-check.7ed1514e.js\";\nimport $jEVl2$pythonversioncheck685b5bb2js1 from \"./python-version-check.685b5bb2.js\";\nimport $jEVl2$pythonversioncheck2f8c5fadjs from \"./python-version-check.2f8c5fad.js\";\nimport $jEVl2$pythonversioncheck801bb0f1js from \"./python-version-check.801bb0f1.js\";\nimport {createGunzip as $jEVl2$createGunzip, constants as $jEVl2$constants, createInflate as $jEVl2$createInflate, createBrotliDecompress as $jEVl2$createBrotliDecompress} from \"zlib\";\nimport * as $jEVl2$assert from \"assert\";\nimport * as $jEVl2$events from \"events\";\nimport {Readable as $jEVl2$Readable, pipeline as $jEVl2$pipeline} from \"stream\";\nimport {TransformStream as $jEVl2$TransformStream, ReadableStream as $jEVl2$ReadableStream} from \"stream/web\";\nimport {STATUS_CODES as $jEVl2$STATUS_CODES} from \"http\";\nimport {resolveObjectURL as $jEVl2$resolveObjectURL} from \"buffer\";\n\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5a65\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5a65\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"1XcJy\", function(module, exports) {\n// https://github.com/Ethan-Arrowood/undici-fetch\n'use strict';\n\nvar $16c52dcde4886f4d$require$Response = $jEVl2$pythonversioncheckc211052ejs4.Response;\nvar $16c52dcde4886f4d$require$makeNetworkError = $jEVl2$pythonversioncheckc211052ejs2.makeNetworkError;\nvar $16c52dcde4886f4d$require$makeAppropriateNetworkError = $jEVl2$pythonversioncheckc211052ejs1.makeAppropriateNetworkError;\nvar $16c52dcde4886f4d$require$filterResponse = $jEVl2$pythonversioncheckc211052ejs.filterResponse;\nvar $16c52dcde4886f4d$require$makeResponse = $jEVl2$pythonversioncheckc211052ejs3.makeResponse;\n\nvar $16c52dcde4886f4d$require$Headers = $jEVl2$pythonversioncheck5597d583js.Headers;\n\nvar $16c52dcde4886f4d$require$Request = $jEVl2$pythonversioncheckff3942bajs1.Request;\nvar $16c52dcde4886f4d$require$makeRequest = $jEVl2$pythonversioncheckff3942bajs.makeRequest;\n\n\nvar $16c52dcde4886f4d$require$bytesMatch = $jEVl2$pythonversioncheck3f48d3eejs2.bytesMatch;\nvar $16c52dcde4886f4d$require$makePolicyContainer = $jEVl2$pythonversioncheck3f48d3eejs16.makePolicyContainer;\nvar $16c52dcde4886f4d$require$clonePolicyContainer = $jEVl2$pythonversioncheck3f48d3eejs3.clonePolicyContainer;\nvar $16c52dcde4886f4d$require$requestBadPort = $jEVl2$pythonversioncheck3f48d3eejs18.requestBadPort;\nvar $16c52dcde4886f4d$require$TAOCheck = $jEVl2$pythonversioncheck3f48d3eejs23.TAOCheck;\nvar $16c52dcde4886f4d$require$appendRequestOriginHeader = $jEVl2$pythonversioncheck3f48d3eejs1.appendRequestOriginHeader;\nvar $16c52dcde4886f4d$require$responseLocationURL = $jEVl2$pythonversioncheck3f48d3eejs20.responseLocationURL;\nvar $16c52dcde4886f4d$require$requestCurrentURL = $jEVl2$pythonversioncheck3f48d3eejs19.requestCurrentURL;\nvar $16c52dcde4886f4d$require$setRequestReferrerPolicyOnRedirect = $jEVl2$pythonversioncheck3f48d3eejs22.setRequestReferrerPolicyOnRedirect;\nvar $16c52dcde4886f4d$require$tryUpgradeRequestToAPotentiallyTrustworthyURL = $jEVl2$pythonversioncheck3f48d3eejs24.tryUpgradeRequestToAPotentiallyTrustworthyURL;\nvar $16c52dcde4886f4d$require$createOpaqueTimingInfo = $jEVl2$pythonversioncheck3f48d3eejs7.createOpaqueTimingInfo;\nvar $16c52dcde4886f4d$require$appendFetchMetadata = $jEVl2$pythonversioncheck3f48d3eejs.appendFetchMetadata;\nvar $16c52dcde4886f4d$require$corsCheck = $jEVl2$pythonversioncheck3f48d3eejs5.corsCheck;\nvar $16c52dcde4886f4d$require$crossOriginResourcePolicyCheck = $jEVl2$pythonversioncheck3f48d3eejs8.crossOriginResourcePolicyCheck;\nvar $16c52dcde4886f4d$require$determineRequestsReferrer = $jEVl2$pythonversioncheck3f48d3eejs9.determineRequestsReferrer;\nvar $16c52dcde4886f4d$require$coarsenedSharedCurrentTime = $jEVl2$pythonversioncheck3f48d3eejs4.coarsenedSharedCurrentTime;\nvar $16c52dcde4886f4d$require$createDeferredPromise = $jEVl2$pythonversioncheck3f48d3eejs6.createDeferredPromise;\nvar $16c52dcde4886f4d$require$isBlobLike = $jEVl2$pythonversioncheck3f48d3eejs12.isBlobLike;\nvar $16c52dcde4886f4d$require$sameOrigin = $jEVl2$pythonversioncheck3f48d3eejs21.sameOrigin;\nvar $16c52dcde4886f4d$require$isCancelled = $jEVl2$pythonversioncheck3f48d3eejs13.isCancelled;\nvar $16c52dcde4886f4d$require$isAborted = $jEVl2$pythonversioncheck3f48d3eejs11.isAborted;\nvar $16c52dcde4886f4d$require$isErrorLike = $jEVl2$pythonversioncheck3f48d3eejs14.isErrorLike;\nvar $16c52dcde4886f4d$require$fullyReadBody = $jEVl2$pythonversioncheck3f48d3eejs10.fullyReadBody;\nvar $16c52dcde4886f4d$require$readableStreamClose = $jEVl2$pythonversioncheck3f48d3eejs17.readableStreamClose;\nvar $16c52dcde4886f4d$require$isomorphicEncode = $jEVl2$pythonversioncheck3f48d3eejs15.isomorphicEncode;\nvar $16c52dcde4886f4d$require$urlIsLocal = $jEVl2$pythonversioncheck3f48d3eejs27.urlIsLocal;\nvar $16c52dcde4886f4d$require$urlIsHttpHttpsScheme = $jEVl2$pythonversioncheck3f48d3eejs26.urlIsHttpHttpsScheme;\nvar $16c52dcde4886f4d$require$urlHasHttpsScheme = $jEVl2$pythonversioncheck3f48d3eejs25.urlHasHttpsScheme;\n\nvar $16c52dcde4886f4d$require$kState = $jEVl2$pythonversioncheck92c00e26js3.kState;\nvar $16c52dcde4886f4d$require$kHeaders = $jEVl2$pythonversioncheck92c00e26js1.kHeaders;\nvar $16c52dcde4886f4d$require$kGuard = $jEVl2$pythonversioncheck92c00e26js.kGuard;\nvar $16c52dcde4886f4d$require$kRealm = $jEVl2$pythonversioncheck92c00e26js2.kRealm;\n\n\nvar $16c52dcde4886f4d$require$safelyExtractBody = $jEVl2$pythonversioncheck152f8bbajs.safelyExtractBody;\n\nvar $16c52dcde4886f4d$require$redirectStatusSet = $jEVl2$pythonversioncheck863e006ejs2.redirectStatusSet;\nvar $16c52dcde4886f4d$require$nullBodyStatus = $jEVl2$pythonversioncheck863e006ejs1.nullBodyStatus;\nvar $16c52dcde4886f4d$require$safeMethodsSet = $jEVl2$pythonversioncheck863e006ejs4.safeMethodsSet;\nvar $16c52dcde4886f4d$require$requestBodyHeader = $jEVl2$pythonversioncheck863e006ejs3.requestBodyHeader;\nvar $16c52dcde4886f4d$require$subresourceSet = $jEVl2$pythonversioncheck863e006ejs5.subresourceSet;\nvar $16c52dcde4886f4d$require$DOMException = $jEVl2$pythonversioncheck863e006ejs.DOMException;\n\nvar $16c52dcde4886f4d$require$kHeadersList = $jEVl2$pythonversioncheckebf2a848js.kHeadersList;\n\n\nvar $16c52dcde4886f4d$require$Readable = $jEVl2$Readable;\nvar $16c52dcde4886f4d$require$pipeline = $jEVl2$pipeline;\n\nvar $16c52dcde4886f4d$require$addAbortListener = $jEVl2$pythonversioncheck7ed1514ejs.addAbortListener;\nvar $16c52dcde4886f4d$require$isErrored = $jEVl2$pythonversioncheck7ed1514ejs1.isErrored;\nvar $16c52dcde4886f4d$require$isReadable = $jEVl2$pythonversioncheck7ed1514ejs2.isReadable;\nvar $16c52dcde4886f4d$require$nodeMajor = $jEVl2$pythonversioncheck7ed1514ejs3.nodeMajor;\nvar $16c52dcde4886f4d$require$nodeMinor = $jEVl2$pythonversioncheck7ed1514ejs4.nodeMinor;\n\nvar $16c52dcde4886f4d$require$dataURLProcessor = $jEVl2$pythonversioncheck685b5bb2js.dataURLProcessor;\nvar $16c52dcde4886f4d$require$serializeAMimeType = $jEVl2$pythonversioncheck685b5bb2js1.serializeAMimeType;\n\nvar $16c52dcde4886f4d$require$TransformStream = $jEVl2$TransformStream;\n\nvar $16c52dcde4886f4d$require$getGlobalDispatcher = $jEVl2$pythonversioncheck2f8c5fadjs.getGlobalDispatcher;\n\nvar $16c52dcde4886f4d$require$webidl = $jEVl2$pythonversioncheck801bb0f1js.webidl;\n\nvar $16c52dcde4886f4d$require$STATUS_CODES = $jEVl2$STATUS_CODES;\nconst $16c52dcde4886f4d$var$GET_OR_HEAD = [\n    'GET',\n    'HEAD'\n];\n/** @type {import('buffer').resolveObjectURL} */ let $16c52dcde4886f4d$var$resolveObjectURL;\nlet $16c52dcde4886f4d$var$ReadableStream = globalThis.ReadableStream;\nclass $16c52dcde4886f4d$var$Fetch extends $jEVl2$events {\n    constructor(dispatcher){\n        super();\n        this.dispatcher = dispatcher;\n        this.connection = null;\n        this.dump = false;\n        this.state = 'ongoing';\n        // 2 terminated listeners get added per request,\n        // but only 1 gets removed. If there are 20 redirects,\n        // 21 listeners will be added.\n        // See https://github.com/nodejs/undici/issues/1711\n        // TODO (fix): Find and fix root cause for leaked listener.\n        this.setMaxListeners(21);\n    }\n    terminate(reason) {\n        if (this.state !== 'ongoing') return;\n        this.state = 'terminated';\n        this.connection?.destroy(reason);\n        this.emit('terminated', reason);\n    }\n    // https://fetch.spec.whatwg.org/#fetch-controller-abort\n    abort(error) {\n        if (this.state !== 'ongoing') return;\n        // 1. Set controller’s state to \"aborted\".\n        this.state = 'aborted';\n        // 2. Let fallbackError be an \"AbortError\" DOMException.\n        // 3. Set error to fallbackError if it is not given.\n        if (!error) error = new $16c52dcde4886f4d$require$DOMException('The operation was aborted.', 'AbortError');\n        // 4. Let serializedError be StructuredSerialize(error).\n        //    If that threw an exception, catch it, and let\n        //    serializedError be StructuredSerialize(fallbackError).\n        // 5. Set controller’s serialized abort reason to serializedError.\n        this.serializedAbortReason = error;\n        this.connection?.destroy(error);\n        this.emit('terminated', error);\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction $16c52dcde4886f4d$var$fetch(input, init = {}) {\n    $16c52dcde4886f4d$require$webidl.argumentLengthCheck(arguments, 1, {\n        header: 'globalThis.fetch'\n    });\n    // 1. Let p be a new promise.\n    const p = $16c52dcde4886f4d$require$createDeferredPromise();\n    // 2. Let requestObject be the result of invoking the initial value of\n    // Request as constructor with input and init as arguments. If this throws\n    // an exception, reject p with it and return p.\n    let requestObject;\n    try {\n        requestObject = new $16c52dcde4886f4d$require$Request(input, init);\n    } catch (e) {\n        p.reject(e);\n        return p.promise;\n    }\n    // 3. Let request be requestObject’s request.\n    const request = requestObject[$16c52dcde4886f4d$require$kState];\n    // 4. If requestObject’s signal’s aborted flag is set, then:\n    if (requestObject.signal.aborted) {\n        // 1. Abort the fetch() call with p, request, null, and\n        //    requestObject’s signal’s abort reason.\n        $16c52dcde4886f4d$var$abortFetch(p, request, null, requestObject.signal.reason);\n        // 2. Return p.\n        return p.promise;\n    }\n    // 5. Let globalObject be request’s client’s global object.\n    const globalObject = request.client.globalObject;\n    // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n    // request’s service-workers mode to \"none\".\n    if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') request.serviceWorkers = 'none';\n    // 7. Let responseObject be null.\n    let responseObject = null;\n    // 8. Let relevantRealm be this’s relevant Realm.\n    const relevantRealm = null;\n    // 9. Let locallyAborted be false.\n    let locallyAborted = false;\n    // 10. Let controller be null.\n    let controller = null;\n    // 11. Add the following abort steps to requestObject’s signal:\n    $16c52dcde4886f4d$require$addAbortListener(requestObject.signal, ()=>{\n        // 1. Set locallyAborted to true.\n        locallyAborted = true;\n        // 2. Assert: controller is non-null.\n        $jEVl2$assert(controller != null);\n        // 3. Abort controller with requestObject’s signal’s abort reason.\n        controller.abort(requestObject.signal.reason);\n        // 4. Abort the fetch() call with p, request, responseObject,\n        //    and requestObject’s signal’s abort reason.\n        $16c52dcde4886f4d$var$abortFetch(p, request, responseObject, requestObject.signal.reason);\n    });\n    // 12. Let handleFetchDone given response response be to finalize and\n    // report timing with response, globalObject, and \"fetch\".\n    const handleFetchDone = (response)=>$16c52dcde4886f4d$var$finalizeAndReportTiming(response, 'fetch');\n    // 13. Set controller to the result of calling fetch given request,\n    // with processResponseEndOfBody set to handleFetchDone, and processResponse\n    // given response being these substeps:\n    const processResponse = (response)=>{\n        // 1. If locallyAborted is true, terminate these substeps.\n        if (locallyAborted) return Promise.resolve();\n        // 2. If response’s aborted flag is set, then:\n        if (response.aborted) {\n            // 1. Let deserializedError be the result of deserialize a serialized\n            //    abort reason given controller’s serialized abort reason and\n            //    relevantRealm.\n            // 2. Abort the fetch() call with p, request, responseObject, and\n            //    deserializedError.\n            $16c52dcde4886f4d$var$abortFetch(p, request, responseObject, controller.serializedAbortReason);\n            return Promise.resolve();\n        }\n        // 3. If response is a network error, then reject p with a TypeError\n        // and terminate these substeps.\n        if (response.type === 'error') {\n            p.reject(Object.assign(new TypeError('fetch failed'), {\n                cause: response.error\n            }));\n            return Promise.resolve();\n        }\n        // 4. Set responseObject to the result of creating a Response object,\n        // given response, \"immutable\", and relevantRealm.\n        responseObject = new $16c52dcde4886f4d$require$Response();\n        responseObject[$16c52dcde4886f4d$require$kState] = response;\n        responseObject[$16c52dcde4886f4d$require$kRealm] = relevantRealm;\n        responseObject[$16c52dcde4886f4d$require$kHeaders][$16c52dcde4886f4d$require$kHeadersList] = response.headersList;\n        responseObject[$16c52dcde4886f4d$require$kHeaders][$16c52dcde4886f4d$require$kGuard] = 'immutable';\n        responseObject[$16c52dcde4886f4d$require$kHeaders][$16c52dcde4886f4d$require$kRealm] = relevantRealm;\n        // 5. Resolve p with responseObject.\n        p.resolve(responseObject);\n    };\n    controller = $16c52dcde4886f4d$var$fetching({\n        request: request,\n        processResponseEndOfBody: handleFetchDone,\n        processResponse: processResponse,\n        dispatcher: init.dispatcher ?? $16c52dcde4886f4d$require$getGlobalDispatcher() // undici\n    });\n    // 14. Return p.\n    return p.promise;\n}\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction $16c52dcde4886f4d$var$finalizeAndReportTiming(response, initiatorType = 'other') {\n    // 1. If response is an aborted network error, then return.\n    if (response.type === 'error' && response.aborted) return;\n    // 2. If response’s URL list is null or empty, then return.\n    if (!response.urlList?.length) return;\n    // 3. Let originalURL be response’s URL list[0].\n    const originalURL = response.urlList[0];\n    // 4. Let timingInfo be response’s timing info.\n    let timingInfo = response.timingInfo;\n    // 5. Let cacheState be response’s cache state.\n    let cacheState = response.cacheState;\n    // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n    if (!$16c52dcde4886f4d$require$urlIsHttpHttpsScheme(originalURL)) return;\n    // 7. If timingInfo is null, then return.\n    if (timingInfo === null) return;\n    // 8. If response’s timing allow passed flag is not set, then:\n    if (!response.timingAllowPassed) {\n        //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n        timingInfo = $16c52dcde4886f4d$require$createOpaqueTimingInfo({\n            startTime: timingInfo.startTime\n        });\n        //  2. Set cacheState to the empty string.\n        cacheState = '';\n    }\n    // 9. Set timingInfo’s end time to the coarsened shared current time\n    // given global’s relevant settings object’s cross-origin isolated\n    // capability.\n    // TODO: given global’s relevant settings object’s cross-origin isolated\n    // capability?\n    timingInfo.endTime = $16c52dcde4886f4d$require$coarsenedSharedCurrentTime();\n    // 10. Set response’s timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n    // global, and cacheState.\n    $16c52dcde4886f4d$var$markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);\n}\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction $16c52dcde4886f4d$var$markResourceTiming(timingInfo, originalURL, initiatorType, globalThis1, cacheState) {\n    if ($16c52dcde4886f4d$require$nodeMajor > 18 || $16c52dcde4886f4d$require$nodeMajor === 18 && $16c52dcde4886f4d$require$nodeMinor >= 2) performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis1, cacheState);\n}\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction $16c52dcde4886f4d$var$abortFetch(p, request, responseObject, error) {\n    // Note: AbortSignal.reason was added in node v17.2.0\n    // which would give us an undefined error to reject with.\n    // Remove this once node v16 is no longer supported.\n    if (!error) error = new $16c52dcde4886f4d$require$DOMException('The operation was aborted.', 'AbortError');\n    // 1. Reject promise with error.\n    p.reject(error);\n    // 2. If request’s body is not null and is readable, then cancel request’s\n    // body with error.\n    if (request.body != null && $16c52dcde4886f4d$require$isReadable(request.body?.stream)) request.body.stream.cancel(error).catch((err)=>{\n        if (err.code === 'ERR_INVALID_STATE') // Node bug?\n        return;\n        throw err;\n    });\n    // 3. If responseObject is null, then return.\n    if (responseObject == null) return;\n    // 4. Let response be responseObject’s response.\n    const response = responseObject[$16c52dcde4886f4d$require$kState];\n    // 5. If response’s body is not null and is readable, then error response’s\n    // body with error.\n    if (response.body != null && $16c52dcde4886f4d$require$isReadable(response.body?.stream)) response.body.stream.cancel(error).catch((err)=>{\n        if (err.code === 'ERR_INVALID_STATE') // Node bug?\n        return;\n        throw err;\n    });\n}\n// https://fetch.spec.whatwg.org/#fetching\nfunction $16c52dcde4886f4d$var$fetching({ request: request, processRequestBodyChunkLength: processRequestBodyChunkLength, processRequestEndOfBody: processRequestEndOfBody, processResponse: processResponse, processResponseEndOfBody: processResponseEndOfBody, processResponseConsumeBody: processResponseConsumeBody, useParallelQueue: useParallelQueue = false, dispatcher: dispatcher // undici\n }) {\n    // 1. Let taskDestination be null.\n    let taskDestination = null;\n    // 2. Let crossOriginIsolatedCapability be false.\n    let crossOriginIsolatedCapability = false;\n    // 3. If request’s client is non-null, then:\n    if (request.client != null) {\n        // 1. Set taskDestination to request’s client’s global object.\n        taskDestination = request.client.globalObject;\n        // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n        // isolated capability.\n        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n    }\n    // 4. If useParallelQueue is true, then set taskDestination to the result of\n    // starting a new parallel queue.\n    // TODO\n    // 5. Let timingInfo be a new fetch timing info whose start time and\n    // post-redirect start time are the coarsened shared current time given\n    // crossOriginIsolatedCapability.\n    const currenTime = $16c52dcde4886f4d$require$coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n    const timingInfo = $16c52dcde4886f4d$require$createOpaqueTimingInfo({\n        startTime: currenTime\n    });\n    // 6. Let fetchParams be a new fetch params whose\n    // request is request,\n    // timing info is timingInfo,\n    // process request body chunk length is processRequestBodyChunkLength,\n    // process request end-of-body is processRequestEndOfBody,\n    // process response is processResponse,\n    // process response consume body is processResponseConsumeBody,\n    // process response end-of-body is processResponseEndOfBody,\n    // task destination is taskDestination,\n    // and cross-origin isolated capability is crossOriginIsolatedCapability.\n    const fetchParams = {\n        controller: new $16c52dcde4886f4d$var$Fetch(dispatcher),\n        request: request,\n        timingInfo: timingInfo,\n        processRequestBodyChunkLength: processRequestBodyChunkLength,\n        processRequestEndOfBody: processRequestEndOfBody,\n        processResponse: processResponse,\n        processResponseConsumeBody: processResponseConsumeBody,\n        processResponseEndOfBody: processResponseEndOfBody,\n        taskDestination: taskDestination,\n        crossOriginIsolatedCapability: crossOriginIsolatedCapability\n    };\n    // 7. If request’s body is a byte sequence, then set request’s body to\n    //    request’s body as a body.\n    // NOTE: Since fetching is only called from fetch, body should already be\n    // extracted.\n    $jEVl2$assert(!request.body || request.body.stream);\n    // 8. If request’s window is \"client\", then set request’s window to request’s\n    // client, if request’s client’s global object is a Window object; otherwise\n    // \"no-window\".\n    if (request.window === 'client') // TODO: What if request.client is null?\n    request.window = request.client?.globalObject?.constructor?.name === 'Window' ? request.client : 'no-window';\n    // 9. If request’s origin is \"client\", then set request’s origin to request’s\n    // client’s origin.\n    if (request.origin === 'client') // TODO: What if request.client is null?\n    request.origin = request.client?.origin;\n    // 10. If all of the following conditions are true:\n    // TODO\n    // 11. If request’s policy container is \"client\", then:\n    if (request.policyContainer === 'client') {\n        // 1. If request’s client is non-null, then set request’s policy\n        // container to a clone of request’s client’s policy container. [HTML]\n        if (request.client != null) request.policyContainer = $16c52dcde4886f4d$require$clonePolicyContainer(request.client.policyContainer);\n        else // 2. Otherwise, set request’s policy container to a new policy\n        // container.\n        request.policyContainer = $16c52dcde4886f4d$require$makePolicyContainer();\n    }\n    // 12. If request’s header list does not contain `Accept`, then:\n    if (!request.headersList.contains('accept')) {\n        // 1. Let value be `*/*`.\n        const value = '*/*';\n        // 2. A user agent should set value to the first matching statement, if\n        // any, switching on request’s destination:\n        // \"document\"\n        // \"frame\"\n        // \"iframe\"\n        // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n        // \"image\"\n        // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n        // \"style\"\n        // `text/css,*/*;q=0.1`\n        // TODO\n        // 3. Append `Accept`/value to request’s header list.\n        request.headersList.append('accept', value);\n    }\n    // 13. If request’s header list does not contain `Accept-Language`, then\n    // user agents should append `Accept-Language`/an appropriate value to\n    // request’s header list.\n    if (!request.headersList.contains('accept-language')) request.headersList.append('accept-language', '*');\n    // 14. If request’s priority is null, then use request’s initiator and\n    // destination appropriately in setting request’s priority to a\n    // user-agent-defined object.\n    request.priority;\n    // 15. If request is a subresource request, then:\n    $16c52dcde4886f4d$require$subresourceSet.has(request.destination);\n    // 16. Run main fetch given fetchParams.\n    $16c52dcde4886f4d$var$mainFetch(fetchParams).catch((err)=>{\n        fetchParams.controller.terminate(err);\n    });\n    // 17. Return fetchParam's controller\n    return fetchParams.controller;\n}\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function $16c52dcde4886f4d$var$mainFetch(fetchParams, recursive = false) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. If request’s local-URLs-only flag is set and request’s current URL is\n    // not local, then set response to a network error.\n    if (request.localURLsOnly && !$16c52dcde4886f4d$require$urlIsLocal($16c52dcde4886f4d$require$requestCurrentURL(request))) response = $16c52dcde4886f4d$require$makeNetworkError('local URLs only');\n    // 4. Run report Content Security Policy violations for request.\n    // TODO\n    // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n    $16c52dcde4886f4d$require$tryUpgradeRequestToAPotentiallyTrustworthyURL(request);\n    // 6. If should request be blocked due to a bad port, should fetching request\n    // be blocked as mixed content, or should request be blocked by Content\n    // Security Policy returns blocked, then set response to a network error.\n    if ($16c52dcde4886f4d$require$requestBadPort(request) === 'blocked') response = $16c52dcde4886f4d$require$makeNetworkError('bad port');\n    // TODO: should fetching request be blocked as mixed content?\n    // TODO: should request be blocked by Content Security Policy?\n    // 7. If request’s referrer policy is the empty string, then set request’s\n    // referrer policy to request’s policy container’s referrer policy.\n    if (request.referrerPolicy === '') request.referrerPolicy = request.policyContainer.referrerPolicy;\n    // 8. If request’s referrer is not \"no-referrer\", then set request’s\n    // referrer to the result of invoking determine request’s referrer.\n    if (request.referrer !== 'no-referrer') request.referrer = $16c52dcde4886f4d$require$determineRequestsReferrer(request);\n    // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n    // conditions are true:\n    // - request’s current URL’s scheme is \"http\"\n    // - request’s current URL’s host is a domain\n    // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n    //   Matching results in either a superdomain match with an asserted\n    //   includeSubDomains directive or a congruent match (with or without an\n    //   asserted includeSubDomains directive). [HSTS]\n    // TODO\n    // 10. If recursive is false, then run the remaining steps in parallel.\n    // TODO\n    // 11. If response is null, then set response to the result of running\n    // the steps corresponding to the first matching statement:\n    if (response === null) response = await (async ()=>{\n        const currentURL = $16c52dcde4886f4d$require$requestCurrentURL(request);\n        if (// - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        $16c52dcde4886f4d$require$sameOrigin(currentURL, request.url) && request.responseTainting === 'basic' || // request’s current URL’s scheme is \"data\"\n        currentURL.protocol === 'data:' || // - request’s mode is \"navigate\" or \"websocket\"\n        request.mode === 'navigate' || request.mode === 'websocket') {\n            // 1. Set request’s response tainting to \"basic\".\n            request.responseTainting = 'basic';\n            // 2. Return the result of running scheme fetch given fetchParams.\n            return await $16c52dcde4886f4d$var$schemeFetch(fetchParams);\n        }\n        // request’s mode is \"same-origin\"\n        if (request.mode === 'same-origin') // 1. Return a network error.\n        return $16c52dcde4886f4d$require$makeNetworkError('request mode cannot be \"same-origin\"');\n        // request’s mode is \"no-cors\"\n        if (request.mode === 'no-cors') {\n            // 1. If request’s redirect mode is not \"follow\", then return a network\n            // error.\n            if (request.redirect !== 'follow') return $16c52dcde4886f4d$require$makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n            // 2. Set request’s response tainting to \"opaque\".\n            request.responseTainting = 'opaque';\n            // 3. Return the result of running scheme fetch given fetchParams.\n            return await $16c52dcde4886f4d$var$schemeFetch(fetchParams);\n        }\n        // request’s current URL’s scheme is not an HTTP(S) scheme\n        if (!$16c52dcde4886f4d$require$urlIsHttpHttpsScheme($16c52dcde4886f4d$require$requestCurrentURL(request))) // Return a network error.\n        return $16c52dcde4886f4d$require$makeNetworkError('URL scheme must be a HTTP(S) scheme');\n        // - request’s use-CORS-preflight flag is set\n        // - request’s unsafe-request flag is set and either request’s method is\n        //   not a CORS-safelisted method or CORS-unsafe request-header names with\n        //   request’s header list is not empty\n        //    1. Set request’s response tainting to \"cors\".\n        //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n        //    given fetchParams and true.\n        //    3. If corsWithPreflightResponse is a network error, then clear cache\n        //    entries using request.\n        //    4. Return corsWithPreflightResponse.\n        // TODO\n        // Otherwise\n        //    1. Set request’s response tainting to \"cors\".\n        request.responseTainting = 'cors';\n        //    2. Return the result of running HTTP fetch given fetchParams.\n        return await $16c52dcde4886f4d$var$httpFetch(fetchParams);\n    })();\n    // 12. If recursive is true, then return response.\n    if (recursive) return response;\n    // 13. If response is not a network error and response is not a filtered\n    // response, then:\n    if (response.status !== 0 && !response.internalResponse) {\n        // If request’s response tainting is \"cors\", then:\n        request.responseTainting;\n        // Set response to the following filtered response with response as its\n        // internal response, depending on request’s response tainting:\n        if (request.responseTainting === 'basic') response = $16c52dcde4886f4d$require$filterResponse(response, 'basic');\n        else if (request.responseTainting === 'cors') response = $16c52dcde4886f4d$require$filterResponse(response, 'cors');\n        else if (request.responseTainting === 'opaque') response = $16c52dcde4886f4d$require$filterResponse(response, 'opaque');\n        else $jEVl2$assert(false);\n    }\n    // 14. Let internalResponse be response, if response is a network error,\n    // and response’s internal response otherwise.\n    let internalResponse = response.status === 0 ? response : response.internalResponse;\n    // 15. If internalResponse’s URL list is empty, then set it to a clone of\n    // request’s URL list.\n    if (internalResponse.urlList.length === 0) internalResponse.urlList.push(...request.urlList);\n    // 16. If request’s timing allow failed flag is unset, then set\n    // internalResponse’s timing allow passed flag.\n    if (!request.timingAllowFailed) response.timingAllowPassed = true;\n    // 17. If response is not a network error and any of the following returns\n    // blocked\n    // - should internalResponse to request be blocked as mixed content\n    // - should internalResponse to request be blocked by Content Security Policy\n    // - should internalResponse to request be blocked due to its MIME type\n    // - should internalResponse to request be blocked due to nosniff\n    // TODO\n    // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n    // internalResponse’s range-requested flag is set, and request’s header\n    // list does not contain `Range`, then set response and internalResponse\n    // to a network error.\n    if (response.type === 'opaque' && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains('range')) response = internalResponse = $16c52dcde4886f4d$require$makeNetworkError();\n    // 19. If response is not a network error and either request’s method is\n    // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n    // set internalResponse’s body to null and disregard any enqueuing toward\n    // it (if any).\n    if (response.status !== 0 && (request.method === 'HEAD' || request.method === 'CONNECT' || $16c52dcde4886f4d$require$nullBodyStatus.includes(internalResponse.status))) {\n        internalResponse.body = null;\n        fetchParams.controller.dump = true;\n    }\n    // 20. If request’s integrity metadata is not the empty string, then:\n    if (request.integrity) {\n        // 1. Let processBodyError be this step: run fetch finale given fetchParams\n        // and a network error.\n        const processBodyError = (reason)=>$16c52dcde4886f4d$var$fetchFinale(fetchParams, $16c52dcde4886f4d$require$makeNetworkError(reason));\n        // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n        // then run processBodyError and abort these steps.\n        if (request.responseTainting === 'opaque' || response.body == null) {\n            processBodyError(response.error);\n            return;\n        }\n        // 3. Let processBody given bytes be these steps:\n        const processBody = (bytes)=>{\n            // 1. If bytes do not match request’s integrity metadata,\n            // then run processBodyError and abort these steps. [SRI]\n            if (!$16c52dcde4886f4d$require$bytesMatch(bytes, request.integrity)) {\n                processBodyError('integrity mismatch');\n                return;\n            }\n            // 2. Set response’s body to bytes as a body.\n            response.body = $16c52dcde4886f4d$require$safelyExtractBody(bytes)[0];\n            // 3. Run fetch finale given fetchParams and response.\n            $16c52dcde4886f4d$var$fetchFinale(fetchParams, response);\n        };\n        // 4. Fully read response’s body given processBody and processBodyError.\n        await $16c52dcde4886f4d$require$fullyReadBody(response.body, processBody, processBodyError);\n    } else // 21. Otherwise, run fetch finale given fetchParams and response.\n    $16c52dcde4886f4d$var$fetchFinale(fetchParams, response);\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction $16c52dcde4886f4d$var$schemeFetch(fetchParams) {\n    // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n    // cancelled state, we do not want this condition to trigger *unless* there have been\n    // no redirects. See https://github.com/nodejs/undici/issues/1776\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if ($16c52dcde4886f4d$require$isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) return Promise.resolve($16c52dcde4886f4d$require$makeAppropriateNetworkError(fetchParams));\n    // 2. Let request be fetchParams’s request.\n    const { request: request } = fetchParams;\n    const { protocol: scheme } = $16c52dcde4886f4d$require$requestCurrentURL(request);\n    // 3. Switch on request’s current URL’s scheme and run the associated steps:\n    switch(scheme){\n        case 'about:':\n            // If request’s current URL’s path is the string \"blank\", then return a new response\n            // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n            // and body is the empty byte sequence as a body.\n            // Otherwise, return a network error.\n            return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('about scheme is not supported'));\n        case 'blob:':\n            {\n                if (!$16c52dcde4886f4d$var$resolveObjectURL) $16c52dcde4886f4d$var$resolveObjectURL = $jEVl2$resolveObjectURL;\n                // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n                const blobURLEntry = $16c52dcde4886f4d$require$requestCurrentURL(request);\n                // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n                // Buffer.resolveObjectURL does not ignore URL queries.\n                if (blobURLEntry.search.length !== 0) return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('NetworkError when attempting to fetch resource.'));\n                const blobURLEntryObject = $16c52dcde4886f4d$var$resolveObjectURL(blobURLEntry.toString());\n                // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n                //    object is not a Blob object, then return a network error.\n                if (request.method !== 'GET' || !$16c52dcde4886f4d$require$isBlobLike(blobURLEntryObject)) return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('invalid method'));\n                // 3. Let bodyWithType be the result of safely extracting blobURLEntry’s object.\n                const bodyWithType = $16c52dcde4886f4d$require$safelyExtractBody(blobURLEntryObject);\n                // 4. Let body be bodyWithType’s body.\n                const body = bodyWithType[0];\n                // 5. Let length be body’s length, serialized and isomorphic encoded.\n                const length = $16c52dcde4886f4d$require$isomorphicEncode(`${body.length}`);\n                // 6. Let type be bodyWithType’s type if it is non-null; otherwise the empty byte sequence.\n                const type = bodyWithType[1] ?? '';\n                // 7. Return a new response whose status message is `OK`, header list is\n                //    « (`Content-Length`, length), (`Content-Type`, type) », and body is body.\n                const response = $16c52dcde4886f4d$require$makeResponse({\n                    statusText: 'OK',\n                    headersList: [\n                        [\n                            'content-length',\n                            {\n                                name: 'Content-Length',\n                                value: length\n                            }\n                        ],\n                        [\n                            'content-type',\n                            {\n                                name: 'Content-Type',\n                                value: type\n                            }\n                        ]\n                    ]\n                });\n                response.body = body;\n                return Promise.resolve(response);\n            }\n        case 'data:':\n            {\n                // 1. Let dataURLStruct be the result of running the\n                //    data: URL processor on request’s current URL.\n                const currentURL = $16c52dcde4886f4d$require$requestCurrentURL(request);\n                const dataURLStruct = $16c52dcde4886f4d$require$dataURLProcessor(currentURL);\n                // 2. If dataURLStruct is failure, then return a\n                //    network error.\n                if (dataURLStruct === 'failure') return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('failed to fetch the data URL'));\n                // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n                const mimeType = $16c52dcde4886f4d$require$serializeAMimeType(dataURLStruct.mimeType);\n                // 4. Return a response whose status message is `OK`,\n                //    header list is « (`Content-Type`, mimeType) »,\n                //    and body is dataURLStruct’s body as a body.\n                return Promise.resolve($16c52dcde4886f4d$require$makeResponse({\n                    statusText: 'OK',\n                    headersList: [\n                        [\n                            'content-type',\n                            {\n                                name: 'Content-Type',\n                                value: mimeType\n                            }\n                        ]\n                    ],\n                    body: $16c52dcde4886f4d$require$safelyExtractBody(dataURLStruct.body)[0]\n                }));\n            }\n        case 'file:':\n            // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n            // When in doubt, return a network error.\n            return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('not implemented... yet...'));\n        case 'http:':\n        case 'https:':\n            // Return the result of running HTTP fetch given fetchParams.\n            return $16c52dcde4886f4d$var$httpFetch(fetchParams).catch((err)=>$16c52dcde4886f4d$require$makeNetworkError(err));\n        default:\n            return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('unknown scheme'));\n    }\n}\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction $16c52dcde4886f4d$var$finalizeResponse(fetchParams, response) {\n    // 1. Set fetchParams’s request’s done flag.\n    fetchParams.request.done = true;\n    // 2, If fetchParams’s process response done is not null, then queue a fetch\n    // task to run fetchParams’s process response done given response, with\n    // fetchParams’s task destination.\n    if (fetchParams.processResponseDone != null) queueMicrotask(()=>fetchParams.processResponseDone(response));\n}\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction $16c52dcde4886f4d$var$fetchFinale(fetchParams, response) {\n    // 1. If response is a network error, then:\n    if (response.type === 'error') {\n        // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n        response.urlList = [\n            fetchParams.request.urlList[0]\n        ];\n        // 2. Set response’s timing info to the result of creating an opaque timing\n        // info for fetchParams’s timing info.\n        response.timingInfo = $16c52dcde4886f4d$require$createOpaqueTimingInfo({\n            startTime: fetchParams.timingInfo.startTime\n        });\n    }\n    // 2. Let processResponseEndOfBody be the following steps:\n    const processResponseEndOfBody = ()=>{\n        // 1. Set fetchParams’s request’s done flag.\n        fetchParams.request.done = true;\n        // If fetchParams’s process response end-of-body is not null,\n        // then queue a fetch task to run fetchParams’s process response\n        // end-of-body given response with fetchParams’s task destination.\n        if (fetchParams.processResponseEndOfBody != null) queueMicrotask(()=>fetchParams.processResponseEndOfBody(response));\n    };\n    // 3. If fetchParams’s process response is non-null, then queue a fetch task\n    // to run fetchParams’s process response given response, with fetchParams’s\n    // task destination.\n    if (fetchParams.processResponse != null) queueMicrotask(()=>fetchParams.processResponse(response));\n    // 4. If response’s body is null, then run processResponseEndOfBody.\n    if (response.body == null) processResponseEndOfBody();\n    else {\n        // 5. Otherwise:\n        // 1. Let transformStream be a new a TransformStream.\n        // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,\n        // enqueues chunk in transformStream.\n        const identityTransformAlgorithm = (chunk, controller)=>{\n            controller.enqueue(chunk);\n        };\n        // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm\n        // and flushAlgorithm set to processResponseEndOfBody.\n        const transformStream = new $16c52dcde4886f4d$require$TransformStream({\n            start () {},\n            transform: identityTransformAlgorithm,\n            flush: processResponseEndOfBody\n        }, {\n            size () {\n                return 1;\n            }\n        }, {\n            size () {\n                return 1;\n            }\n        });\n        // 4. Set response’s body to the result of piping response’s body through transformStream.\n        response.body = {\n            stream: response.body.stream.pipeThrough(transformStream)\n        };\n    }\n    // 6. If fetchParams’s process response consume body is non-null, then:\n    if (fetchParams.processResponseConsumeBody != null) {\n        // 1. Let processBody given nullOrBytes be this step: run fetchParams’s\n        // process response consume body given response and nullOrBytes.\n        const processBody = (nullOrBytes)=>fetchParams.processResponseConsumeBody(response, nullOrBytes);\n        // 2. Let processBodyError be this step: run fetchParams’s process\n        // response consume body given response and failure.\n        const processBodyError = (failure)=>fetchParams.processResponseConsumeBody(response, failure);\n        // 3. If response’s body is null, then queue a fetch task to run processBody\n        // given null, with fetchParams’s task destination.\n        if (response.body == null) queueMicrotask(()=>processBody(null));\n        else // 4. Otherwise, fully read response’s body given processBody, processBodyError,\n        // and fetchParams’s task destination.\n        return $16c52dcde4886f4d$require$fullyReadBody(response.body, processBody, processBodyError);\n        return Promise.resolve();\n    }\n}\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function $16c52dcde4886f4d$var$httpFetch(fetchParams) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let actualResponse be null.\n    let actualResponse = null;\n    // 4. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 5. If request’s service-workers mode is \"all\", then:\n    request.serviceWorkers;\n    // 6. If response is null, then:\n    if (response === null) {\n        // 1. If makeCORSPreflight is true and one of these conditions is true:\n        // TODO\n        // 2. If request’s redirect mode is \"follow\", then set request’s\n        // service-workers mode to \"none\".\n        if (request.redirect === 'follow') request.serviceWorkers = 'none';\n        // 3. Set response and actualResponse to the result of running\n        // HTTP-network-or-cache fetch given fetchParams.\n        actualResponse = response = await $16c52dcde4886f4d$var$httpNetworkOrCacheFetch(fetchParams);\n        // 4. If request’s response tainting is \"cors\" and a CORS check\n        // for request and response returns failure, then return a network error.\n        if (request.responseTainting === 'cors' && $16c52dcde4886f4d$require$corsCheck(request, response) === 'failure') return $16c52dcde4886f4d$require$makeNetworkError('cors failure');\n        // 5. If the TAO check for request and response returns failure, then set\n        // request’s timing allow failed flag.\n        if ($16c52dcde4886f4d$require$TAOCheck(request, response) === 'failure') request.timingAllowFailed = true;\n    }\n    // 7. If either request’s response tainting or response’s type\n    // is \"opaque\", and the cross-origin resource policy check with\n    // request’s origin, request’s client, request’s destination,\n    // and actualResponse returns blocked, then return a network error.\n    if ((request.responseTainting === 'opaque' || response.type === 'opaque') && $16c52dcde4886f4d$require$crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === 'blocked') return $16c52dcde4886f4d$require$makeNetworkError('blocked');\n    // 8. If actualResponse’s status is a redirect status, then:\n    if ($16c52dcde4886f4d$require$redirectStatusSet.has(actualResponse.status)) {\n        // 1. If actualResponse’s status is not 303, request’s body is not null,\n        // and the connection uses HTTP/2, then user agents may, and are even\n        // encouraged to, transmit an RST_STREAM frame.\n        // See, https://github.com/whatwg/fetch/issues/1288\n        if (request.redirect !== 'manual') fetchParams.controller.connection.destroy();\n        // 2. Switch on request’s redirect mode:\n        if (request.redirect === 'error') // Set response to a network error.\n        response = $16c52dcde4886f4d$require$makeNetworkError('unexpected redirect');\n        else if (request.redirect === 'manual') // Set response to an opaque-redirect filtered response whose internal\n        // response is actualResponse.\n        // NOTE(spec): On the web this would return an `opaqueredirect` response,\n        // but that doesn't make sense server side.\n        // See https://github.com/nodejs/undici/issues/1193.\n        response = actualResponse;\n        else if (request.redirect === 'follow') // Set response to the result of running HTTP-redirect fetch given\n        // fetchParams and response.\n        response = await $16c52dcde4886f4d$var$httpRedirectFetch(fetchParams, response);\n        else $jEVl2$assert(false);\n    }\n    // 9. Set response’s timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 10. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction $16c52dcde4886f4d$var$httpRedirectFetch(fetchParams, response) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let actualResponse be response, if response is not a filtered response,\n    // and response’s internal response otherwise.\n    const actualResponse = response.internalResponse ? response.internalResponse : response;\n    // 3. Let locationURL be actualResponse’s location URL given request’s current\n    // URL’s fragment.\n    let locationURL;\n    try {\n        locationURL = $16c52dcde4886f4d$require$responseLocationURL(actualResponse, $16c52dcde4886f4d$require$requestCurrentURL(request).hash);\n        // 4. If locationURL is null, then return response.\n        if (locationURL == null) return response;\n    } catch (err) {\n        // 5. If locationURL is failure, then return a network error.\n        return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError(err));\n    }\n    // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n    // error.\n    if (!$16c52dcde4886f4d$require$urlIsHttpHttpsScheme(locationURL)) return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('URL scheme must be a HTTP(S) scheme'));\n    // 7. If request’s redirect count is 20, then return a network error.\n    if (request.redirectCount === 20) return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('redirect count exceeded'));\n    // 8. Increase request’s redirect count by 1.\n    request.redirectCount += 1;\n    // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n    // request’s origin is not same origin with locationURL’s origin, then return\n    //  a network error.\n    if (request.mode === 'cors' && (locationURL.username || locationURL.password) && !$16c52dcde4886f4d$require$sameOrigin(request, locationURL)) return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('cross origin not allowed for request mode \"cors\"'));\n    // 10. If request’s response tainting is \"cors\" and locationURL includes\n    // credentials, then return a network error.\n    if (request.responseTainting === 'cors' && (locationURL.username || locationURL.password)) return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError('URL cannot contain credentials for request mode \"cors\"'));\n    // 11. If actualResponse’s status is not 303, request’s body is non-null,\n    // and request’s body’s source is null, then return a network error.\n    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) return Promise.resolve($16c52dcde4886f4d$require$makeNetworkError());\n    // 12. If one of the following is true\n    // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n    // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n    if ([\n        301,\n        302\n    ].includes(actualResponse.status) && request.method === 'POST' || actualResponse.status === 303 && !$16c52dcde4886f4d$var$GET_OR_HEAD.includes(request.method)) {\n        // then:\n        // 1. Set request’s method to `GET` and request’s body to null.\n        request.method = 'GET';\n        request.body = null;\n        // 2. For each headerName of request-body-header name, delete headerName from\n        // request’s header list.\n        for (const headerName of $16c52dcde4886f4d$require$requestBodyHeader)request.headersList.delete(headerName);\n    }\n    // 13. If request’s current URL’s origin is not same origin with locationURL’s\n    //     origin, then for each headerName of CORS non-wildcard request-header name,\n    //     delete headerName from request’s header list.\n    if (!$16c52dcde4886f4d$require$sameOrigin($16c52dcde4886f4d$require$requestCurrentURL(request), locationURL)) {\n        // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n        request.headersList.delete('authorization');\n        // https://fetch.spec.whatwg.org/#authentication-entries\n        request.headersList.delete('proxy-authorization', true);\n        // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n        request.headersList.delete('cookie');\n        request.headersList.delete('host');\n    }\n    // 14. If request’s body is non-null, then set request’s body to the first return\n    // value of safely extracting request’s body’s source.\n    if (request.body != null) {\n        $jEVl2$assert(request.body.source != null);\n        request.body = $16c52dcde4886f4d$require$safelyExtractBody(request.body.source)[0];\n    }\n    // 15. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n    // coarsened shared current time given fetchParams’s cross-origin isolated\n    // capability.\n    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = $16c52dcde4886f4d$require$coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n    // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n    //  redirect start time to timingInfo’s start time.\n    if (timingInfo.redirectStartTime === 0) timingInfo.redirectStartTime = timingInfo.startTime;\n    // 18. Append locationURL to request’s URL list.\n    request.urlList.push(locationURL);\n    // 19. Invoke set request’s referrer policy on redirect on request and\n    // actualResponse.\n    $16c52dcde4886f4d$require$setRequestReferrerPolicyOnRedirect(request, actualResponse);\n    // 20. Return the result of running main fetch given fetchParams and true.\n    return $16c52dcde4886f4d$var$mainFetch(fetchParams, true);\n}\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function $16c52dcde4886f4d$var$httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let httpFetchParams be null.\n    let httpFetchParams = null;\n    // 3. Let httpRequest be null.\n    let httpRequest = null;\n    // 4. Let response be null.\n    let response = null;\n    // 5. Let storedResponse be null.\n    // TODO: cache\n    // 6. Let httpCache be null.\n    const httpCache = null;\n    // 7. Let the revalidatingFlag be unset.\n    const revalidatingFlag = false;\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If request’s window is \"no-window\" and request’s redirect mode is\n    //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n    //    request.\n    if (request.window === 'no-window' && request.redirect === 'error') {\n        httpFetchParams = fetchParams;\n        httpRequest = request;\n    } else {\n        // Otherwise:\n        // 1. Set httpRequest to a clone of request.\n        httpRequest = $16c52dcde4886f4d$require$makeRequest(request);\n        // 2. Set httpFetchParams to a copy of fetchParams.\n        httpFetchParams = {\n            ...fetchParams\n        };\n        // 3. Set httpFetchParams’s request to httpRequest.\n        httpFetchParams.request = httpRequest;\n    }\n    //    3. Let includeCredentials be true if one of\n    const includeCredentials = request.credentials === 'include' || request.credentials === 'same-origin' && request.responseTainting === 'basic';\n    //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n    //    body is non-null; otherwise null.\n    const contentLength = httpRequest.body ? httpRequest.body.length : null;\n    //    5. Let contentLengthHeaderValue be null.\n    let contentLengthHeaderValue = null;\n    //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n    //    `PUT`, then set contentLengthHeaderValue to `0`.\n    if (httpRequest.body == null && [\n        'POST',\n        'PUT'\n    ].includes(httpRequest.method)) contentLengthHeaderValue = '0';\n    //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n    //    contentLength, serialized and isomorphic encoded.\n    if (contentLength != null) contentLengthHeaderValue = $16c52dcde4886f4d$require$isomorphicEncode(`${contentLength}`);\n    //    8. If contentLengthHeaderValue is non-null, then append\n    //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n    //    list.\n    if (contentLengthHeaderValue != null) httpRequest.headersList.append('content-length', contentLengthHeaderValue);\n    //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n    //    contentLengthHeaderValue) to httpRequest’s header list.\n    //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n    //    then:\n    contentLength != null && httpRequest.keepalive;\n    //    11. If httpRequest’s referrer is a URL, then append\n    //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n    //     to httpRequest’s header list.\n    if (httpRequest.referrer instanceof URL) httpRequest.headersList.append('referer', $16c52dcde4886f4d$require$isomorphicEncode(httpRequest.referrer.href));\n    //    12. Append a request `Origin` header for httpRequest.\n    $16c52dcde4886f4d$require$appendRequestOriginHeader(httpRequest);\n    //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n    $16c52dcde4886f4d$require$appendFetchMetadata(httpRequest);\n    //    14. If httpRequest’s header list does not contain `User-Agent`, then\n    //    user agents should append `User-Agent`/default `User-Agent` value to\n    //    httpRequest’s header list.\n    if (!httpRequest.headersList.contains('user-agent')) httpRequest.headersList.append('user-agent', typeof esbuildDetection === 'undefined' ? 'undici' : 'node');\n    //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n    //    list contains `If-Modified-Since`, `If-None-Match`,\n    //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n    //    httpRequest’s cache mode to \"no-store\".\n    if (httpRequest.cache === 'default' && (httpRequest.headersList.contains('if-modified-since') || httpRequest.headersList.contains('if-none-match') || httpRequest.headersList.contains('if-unmodified-since') || httpRequest.headersList.contains('if-match') || httpRequest.headersList.contains('if-range'))) httpRequest.cache = 'no-store';\n    //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n    //    no-cache cache-control header modification flag is unset, and\n    //    httpRequest’s header list does not contain `Cache-Control`, then append\n    //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n    if (httpRequest.cache === 'no-cache' && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains('cache-control')) httpRequest.headersList.append('cache-control', 'max-age=0');\n    //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n    if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n        // 1. If httpRequest’s header list does not contain `Pragma`, then append\n        // `Pragma`/`no-cache` to httpRequest’s header list.\n        if (!httpRequest.headersList.contains('pragma')) httpRequest.headersList.append('pragma', 'no-cache');\n        // 2. If httpRequest’s header list does not contain `Cache-Control`,\n        // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n        if (!httpRequest.headersList.contains('cache-control')) httpRequest.headersList.append('cache-control', 'no-cache');\n    }\n    //    18. If httpRequest’s header list contains `Range`, then append\n    //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n    if (httpRequest.headersList.contains('range')) httpRequest.headersList.append('accept-encoding', 'identity');\n    //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n    //    header if httpRequest’s header list contains that header’s name.\n    //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n    if (!httpRequest.headersList.contains('accept-encoding')) {\n        if ($16c52dcde4886f4d$require$urlHasHttpsScheme($16c52dcde4886f4d$require$requestCurrentURL(httpRequest))) httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');\n        else httpRequest.headersList.append('accept-encoding', 'gzip, deflate');\n    }\n    httpRequest.headersList.delete('host');\n    //    20. If includeCredentials is true, then:\n    includeCredentials;\n    //    21. If there’s a proxy-authentication entry, use it as appropriate.\n    //    TODO: proxy-authentication\n    //    22. Set httpCache to the result of determining the HTTP cache\n    //    partition, given httpRequest.\n    //    TODO: cache\n    //    23. If httpCache is null, then set httpRequest’s cache mode to\n    //    \"no-store\".\n    if (httpCache == null) httpRequest.cache = 'no-store';\n    //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n    //    then:\n    httpRequest.mode !== 'no-store' && httpRequest.mode;\n    // 9. If aborted, then return the appropriate network error for fetchParams.\n    // TODO\n    // 10. If response is null, then:\n    if (response == null) {\n        // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n        // network error.\n        if (httpRequest.mode === 'only-if-cached') return $16c52dcde4886f4d$require$makeNetworkError('only if cached');\n        // 2. Let forwardResponse be the result of running HTTP-network fetch\n        // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n        const forwardResponse = await $16c52dcde4886f4d$var$httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);\n        // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n        // in the range 200 to 399, inclusive, invalidate appropriate stored\n        // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n        // Caching, and set storedResponse to null. [HTTP-CACHING]\n        !$16c52dcde4886f4d$require$safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status;\n        // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n        // then:\n        revalidatingFlag && forwardResponse.status;\n        // 5. If response is null, then:\n        if (response == null) // 1. Set response to forwardResponse.\n        response = forwardResponse;\n    }\n    // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n    response.urlList = [\n        ...httpRequest.urlList\n    ];\n    // 12. If httpRequest’s header list contains `Range`, then set response’s\n    // range-requested flag.\n    if (httpRequest.headersList.contains('range')) response.rangeRequested = true;\n    // 13. Set response’s request-includes-credentials to includeCredentials.\n    response.requestIncludesCredentials = includeCredentials;\n    // 14. If response’s status is 401, httpRequest’s response tainting is not\n    // \"cors\", includeCredentials is true, and request’s window is an environment\n    // settings object, then:\n    // TODO\n    // 15. If response’s status is 407, then:\n    if (response.status === 407) {\n        // 1. If request’s window is \"no-window\", then return a network error.\n        if (request.window === 'no-window') return $16c52dcde4886f4d$require$makeNetworkError();\n        // 2. ???\n        // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if ($16c52dcde4886f4d$require$isCancelled(fetchParams)) return $16c52dcde4886f4d$require$makeAppropriateNetworkError(fetchParams);\n        // 4. Prompt the end user as appropriate in request’s window and store\n        // the result as a proxy-authentication entry. [HTTP-AUTH]\n        // TODO: Invoke some kind of callback?\n        // 5. Set response to the result of running HTTP-network-or-cache fetch given\n        // fetchParams.\n        // TODO\n        return $16c52dcde4886f4d$require$makeNetworkError('proxy authentication required');\n    }\n    // 16. If all of the following are true\n    if (// response’s status is 421\n    response.status === 421 && // isNewConnectionFetch is false\n    !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)) {\n        // then:\n        // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if ($16c52dcde4886f4d$require$isCancelled(fetchParams)) return $16c52dcde4886f4d$require$makeAppropriateNetworkError(fetchParams);\n        // 2. Set response to the result of running HTTP-network-or-cache\n        // fetch given fetchParams, isAuthenticationFetch, and true.\n        // TODO (spec): The spec doesn't specify this but we need to cancel\n        // the active response before we can start a new one.\n        // https://github.com/whatwg/fetch/issues/1293\n        fetchParams.controller.connection.destroy();\n        response = await $16c52dcde4886f4d$var$httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);\n    }\n    // 17. If isAuthenticationFetch is true, then create an authentication entry\n    isAuthenticationFetch;\n    // 18. Return response.\n    return response;\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function $16c52dcde4886f4d$var$httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n    $jEVl2$assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n    fetchParams.controller.connection = {\n        abort: null,\n        destroyed: false,\n        destroy (err) {\n            if (!this.destroyed) {\n                this.destroyed = true;\n                this.abort?.(err ?? new $16c52dcde4886f4d$require$DOMException('The operation was aborted.', 'AbortError'));\n            }\n        }\n    };\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null;\n    // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n    if (httpCache == null) request.cache = 'no-store';\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n    // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n    // \"no\".\n    const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n    ;\n    // 8. Switch on request’s mode:\n    request.mode;\n    // 9. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If connection is failure, then return a network error.\n    //    2. Set timingInfo’s final connection timing info to the result of\n    //    calling clamp and coarsen connection timing info with connection’s\n    //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n    //    cross-origin isolated capability.\n    //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n    //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n    //    `chunked`) to request’s header list.\n    //    4. Set timingInfo’s final network-request start time to the coarsened\n    //    shared current time given fetchParams’s cross-origin isolated\n    //    capability.\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n    //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n    //        - If request’s body is non-null, and request’s body’s source is null,\n    //        then the user agent may have a buffer of up to 64 kibibytes and store\n    //        a part of request’s body in that buffer. If the user agent reads from\n    //        request’s body beyond that buffer’s size and the user agent needs to\n    //        resend request, then instead return a network error.\n    //        - Set timingInfo’s final network-response start time to the coarsened\n    //        shared current time given fetchParams’s cross-origin isolated capability,\n    //        immediately after the user agent’s HTTP parser receives the first byte\n    //        of the response (e.g., frame header bytes for HTTP/2 or response status\n    //        line for HTTP/1.x).\n    //        - Wait until all the headers are transmitted.\n    //        - Any responses whose status is in the range 100 to 199, inclusive,\n    //        and is not 101, are to be ignored, except for the purposes of setting\n    //        timingInfo’s final network-response start time above.\n    //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n    //    - If the HTTP request results in a TLS client certificate dialog, then:\n    //        1. If request’s window is an environment settings object, make the\n    //        dialog available in request’s window.\n    //        2. Otherwise, return a network error.\n    // To transmit request’s body body, run these steps:\n    let requestBody = null;\n    // 1. If body is null and fetchParams’s process request end-of-body is\n    // non-null, then queue a fetch task given fetchParams’s process request\n    // end-of-body and fetchParams’s task destination.\n    if (request.body == null && fetchParams.processRequestEndOfBody) queueMicrotask(()=>fetchParams.processRequestEndOfBody());\n    else if (request.body != null) {\n        // 2. Otherwise, if body is non-null:\n        //    1. Let processBodyChunk given bytes be these steps:\n        const processBodyChunk = async function*(bytes) {\n            // 1. If the ongoing fetch is terminated, then abort these steps.\n            if ($16c52dcde4886f4d$require$isCancelled(fetchParams)) return;\n            // 2. Run this step in parallel: transmit bytes.\n            yield bytes;\n            // 3. If fetchParams’s process request body is non-null, then run\n            // fetchParams’s process request body given bytes’s length.\n            fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);\n        };\n        // 2. Let processEndOfBody be these steps:\n        const processEndOfBody = ()=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if ($16c52dcde4886f4d$require$isCancelled(fetchParams)) return;\n            // 2. If fetchParams’s process request end-of-body is non-null,\n            // then run fetchParams’s process request end-of-body.\n            if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();\n        };\n        // 3. Let processBodyError given e be these steps:\n        const processBodyError = (e)=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if ($16c52dcde4886f4d$require$isCancelled(fetchParams)) return;\n            // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n            if (e.name === 'AbortError') fetchParams.controller.abort();\n            else fetchParams.controller.terminate(e);\n        };\n        // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n        // processBodyError, and fetchParams’s task destination.\n        requestBody = async function*() {\n            try {\n                for await (const bytes of request.body.stream)yield* processBodyChunk(bytes);\n                processEndOfBody();\n            } catch (err) {\n                processBodyError(err);\n            }\n        }();\n    }\n    try {\n        // socket is only provided for websockets\n        const { body: body, status: status, statusText: statusText, headersList: headersList, socket: socket } = await dispatch({\n            body: requestBody\n        });\n        if (socket) response = $16c52dcde4886f4d$require$makeResponse({\n            status: status,\n            statusText: statusText,\n            headersList: headersList,\n            socket: socket\n        });\n        else {\n            const iterator = body[Symbol.asyncIterator]();\n            fetchParams.controller.next = ()=>iterator.next();\n            response = $16c52dcde4886f4d$require$makeResponse({\n                status: status,\n                statusText: statusText,\n                headersList: headersList\n            });\n        }\n    } catch (err) {\n        // 10. If aborted, then:\n        if (err.name === 'AbortError') {\n            // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n            fetchParams.controller.connection.destroy();\n            // 2. Return the appropriate network error for fetchParams.\n            return $16c52dcde4886f4d$require$makeAppropriateNetworkError(fetchParams, err);\n        }\n        return $16c52dcde4886f4d$require$makeNetworkError(err);\n    }\n    // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    const pullAlgorithm = ()=>{\n        fetchParams.controller.resume();\n    };\n    // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n    // controller with reason, given reason.\n    const cancelAlgorithm = (reason)=>{\n        fetchParams.controller.abort(reason);\n    };\n    // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    // TODO\n    // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n    // 15. Let stream be a new ReadableStream.\n    // 16. Set up stream with pullAlgorithm set to pullAlgorithm,\n    // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n    // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n    if (!$16c52dcde4886f4d$var$ReadableStream) $16c52dcde4886f4d$var$ReadableStream = $jEVl2$ReadableStream;\n    const stream = new $16c52dcde4886f4d$var$ReadableStream({\n        async start (controller) {\n            fetchParams.controller.controller = controller;\n        },\n        async pull (controller) {\n            await pullAlgorithm(controller);\n        },\n        async cancel (reason) {\n            await cancelAlgorithm(reason);\n        }\n    }, {\n        highWaterMark: 0,\n        size () {\n            return 1;\n        }\n    });\n    // 17. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. Set response’s body to a new body whose stream is stream.\n    response.body = {\n        stream: stream\n    };\n    //    2. If response is not a network error and request’s cache mode is\n    //    not \"no-store\", then update response in httpCache for request.\n    //    TODO\n    //    3. If includeCredentials is true and the user agent is not configured\n    //    to block cookies for request (see section 7 of [COOKIES]), then run the\n    //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n    //    the value of each header whose name is a byte-case-insensitive match for\n    //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n    //    TODO\n    // 18. If aborted, then:\n    // TODO\n    // 19. Run these steps in parallel:\n    //    1. Run these steps, but abort when fetchParams is canceled:\n    fetchParams.controller.on('terminated', onAborted);\n    fetchParams.controller.resume = async ()=>{\n        // 1. While true\n        while(true){\n            // 1-3. See onData...\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes;\n            let isFailure;\n            try {\n                const { done: done, value: value } = await fetchParams.controller.next();\n                if ($16c52dcde4886f4d$require$isAborted(fetchParams)) break;\n                bytes = done ? undefined : value;\n            } catch (err) {\n                if (fetchParams.controller.ended && !timingInfo.encodedBodySize) // zlib doesn't like empty streams.\n                bytes = undefined;\n                else {\n                    bytes = err;\n                    // err may be propagated from the result of calling readablestream.cancel,\n                    // which might not be an error. https://github.com/nodejs/undici/issues/2009\n                    isFailure = true;\n                }\n            }\n            if (bytes === undefined) {\n                // 2. Otherwise, if the bytes transmission for response’s message\n                // body is done normally and stream is readable, then close\n                // stream, finalize response for fetchParams and response, and\n                // abort these in-parallel steps.\n                $16c52dcde4886f4d$require$readableStreamClose(fetchParams.controller.controller);\n                $16c52dcde4886f4d$var$finalizeResponse(fetchParams, response);\n                return;\n            }\n            // 5. Increase timingInfo’s decoded body size by bytes’s length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0;\n            // 6. If bytes is failure, then terminate fetchParams’s controller.\n            if (isFailure) {\n                fetchParams.controller.terminate(bytes);\n                return;\n            }\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            fetchParams.controller.controller.enqueue(new Uint8Array(bytes));\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if ($16c52dcde4886f4d$require$isErrored(stream)) {\n                fetchParams.controller.terminate();\n                return;\n            }\n            // 9. If stream doesn’t need more data ask the user agent to suspend\n            // the ongoing fetch.\n            if (!fetchParams.controller.controller.desiredSize) return;\n        }\n    };\n    //    2. If aborted, then:\n    function onAborted(reason) {\n        // 2. If fetchParams is aborted, then:\n        if ($16c52dcde4886f4d$require$isAborted(fetchParams)) {\n            // 1. Set response’s aborted flag.\n            response.aborted = true;\n            // 2. If stream is readable, then error stream with the result of\n            //    deserialize a serialized abort reason given fetchParams’s\n            //    controller’s serialized abort reason and an\n            //    implementation-defined realm.\n            if ($16c52dcde4886f4d$require$isReadable(stream)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);\n        } else // 3. Otherwise, if stream is readable, error stream with a TypeError.\n        if ($16c52dcde4886f4d$require$isReadable(stream)) fetchParams.controller.controller.error(new TypeError('terminated', {\n            cause: $16c52dcde4886f4d$require$isErrorLike(reason) ? reason : undefined\n        }));\n        // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n        // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n        fetchParams.controller.connection.destroy();\n    }\n    // 20. Return response.\n    return response;\n    async function dispatch({ body: body }) {\n        const url = $16c52dcde4886f4d$require$requestCurrentURL(request);\n        /** @type {import('../..').Agent} */ const agent = fetchParams.controller.dispatcher;\n        return new Promise((resolve, reject)=>agent.dispatch({\n                path: url.pathname + url.search,\n                origin: url.origin,\n                method: request.method,\n                body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n                headers: request.headersList.entries,\n                maxRedirections: 0,\n                upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n            }, {\n                body: null,\n                abort: null,\n                onConnect (abort) {\n                    // TODO (fix): Do we need connection here?\n                    const { connection: connection } = fetchParams.controller;\n                    if (connection.destroyed) abort(new $16c52dcde4886f4d$require$DOMException('The operation was aborted.', 'AbortError'));\n                    else {\n                        fetchParams.controller.on('terminated', abort);\n                        this.abort = connection.abort = abort;\n                    }\n                },\n                onHeaders (status, headersList, resume, statusText) {\n                    if (status < 200) return;\n                    let codings = [];\n                    let location = '';\n                    const headers = new $16c52dcde4886f4d$require$Headers();\n                    // For H2, the headers are a plain JS object\n                    // We distinguish between them and iterate accordingly\n                    if (Array.isArray(headersList)) for(let n = 0; n < headersList.length; n += 2){\n                        const key = headersList[n + 0].toString('latin1');\n                        const val = headersList[n + 1].toString('latin1');\n                        if (key.toLowerCase() === 'content-encoding') // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                        // \"All content-coding values are case-insensitive...\"\n                        codings = val.toLowerCase().split(',').map((x)=>x.trim());\n                        else if (key.toLowerCase() === 'location') location = val;\n                        headers[$16c52dcde4886f4d$require$kHeadersList].append(key, val);\n                    }\n                    else {\n                        const keys = Object.keys(headersList);\n                        for (const key of keys){\n                            const val = headersList[key];\n                            if (key.toLowerCase() === 'content-encoding') // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                            // \"All content-coding values are case-insensitive...\"\n                            codings = val.toLowerCase().split(',').map((x)=>x.trim()).reverse();\n                            else if (key.toLowerCase() === 'location') location = val;\n                            headers[$16c52dcde4886f4d$require$kHeadersList].append(key, val);\n                        }\n                    }\n                    this.body = new $16c52dcde4886f4d$require$Readable({\n                        read: resume\n                    });\n                    const decoders = [];\n                    const willFollow = request.redirect === 'follow' && location && $16c52dcde4886f4d$require$redirectStatusSet.has(status);\n                    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n                    if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !$16c52dcde4886f4d$require$nullBodyStatus.includes(status) && !willFollow) for (const coding of codings){\n                        // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n                        if (coding === 'x-gzip' || coding === 'gzip') decoders.push($jEVl2$createGunzip({\n                            // Be less strict when decoding compressed responses, since sometimes\n                            // servers send slightly invalid responses that are still accepted\n                            // by common browsers.\n                            // Always using Z_SYNC_FLUSH is what cURL does.\n                            flush: $jEVl2$constants.Z_SYNC_FLUSH,\n                            finishFlush: $jEVl2$constants.Z_SYNC_FLUSH\n                        }));\n                        else if (coding === 'deflate') decoders.push($jEVl2$createInflate());\n                        else if (coding === 'br') decoders.push($jEVl2$createBrotliDecompress());\n                        else {\n                            decoders.length = 0;\n                            break;\n                        }\n                    }\n                    resolve({\n                        status: status,\n                        statusText: statusText,\n                        headersList: headers[$16c52dcde4886f4d$require$kHeadersList],\n                        body: decoders.length ? $16c52dcde4886f4d$require$pipeline(this.body, ...decoders, ()=>{}) : this.body.on('error', ()=>{})\n                    });\n                    return true;\n                },\n                onData (chunk) {\n                    if (fetchParams.controller.dump) return;\n                    // 1. If one or more bytes have been transmitted from response’s\n                    // message body, then:\n                    //  1. Let bytes be the transmitted bytes.\n                    const bytes = chunk;\n                    //  2. Let codings be the result of extracting header list values\n                    //  given `Content-Encoding` and response’s header list.\n                    //  See pullAlgorithm.\n                    //  3. Increase timingInfo’s encoded body size by bytes’s length.\n                    timingInfo.encodedBodySize += bytes.byteLength;\n                    //  4. See pullAlgorithm...\n                    return this.body.push(bytes);\n                },\n                onComplete () {\n                    if (this.abort) fetchParams.controller.off('terminated', this.abort);\n                    fetchParams.controller.ended = true;\n                    this.body.push(null);\n                },\n                onError (error) {\n                    if (this.abort) fetchParams.controller.off('terminated', this.abort);\n                    this.body?.destroy(error);\n                    fetchParams.controller.terminate(error);\n                    reject(error);\n                },\n                onUpgrade (status, headersList, socket) {\n                    if (status !== 101) return;\n                    const headers = new $16c52dcde4886f4d$require$Headers();\n                    for(let n = 0; n < headersList.length; n += 2){\n                        const key = headersList[n + 0].toString('latin1');\n                        const val = headersList[n + 1].toString('latin1');\n                        headers[$16c52dcde4886f4d$require$kHeadersList].append(key, val);\n                    }\n                    resolve({\n                        status: status,\n                        statusText: $16c52dcde4886f4d$require$STATUS_CODES[status],\n                        headersList: headers[$16c52dcde4886f4d$require$kHeadersList],\n                        socket: socket\n                    });\n                    return true;\n                }\n            }));\n    }\n}\nmodule.exports = {\n    fetch: $16c52dcde4886f4d$var$fetch,\n    Fetch: $16c52dcde4886f4d$var$Fetch,\n    fetching: $16c52dcde4886f4d$var$fetching,\n    finalizeAndReportTiming: $16c52dcde4886f4d$var$finalizeAndReportTiming\n};\n\n});\n\n\nparcelRequire(\"1XcJy\");\n\n//# sourceMappingURL=python-version-check.db834fc6.js.map\n","// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst {\n  Response,\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse\n} = require('./response')\nconst { Headers } = require('./headers')\nconst { Request, makeRequest } = require('./request')\nconst zlib = require('zlib')\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme\n} = require('./util')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst assert = require('assert')\nconst { safelyExtractBody } = require('./body')\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet,\n  DOMException\n} = require('./constants')\nconst { kHeadersList } = require('../core/symbols')\nconst EE = require('events')\nconst { Readable, pipeline } = require('stream')\nconst { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require('../core/util')\nconst { dataURLProcessor, serializeAMimeType } = require('./dataURL')\nconst { TransformStream } = require('stream/web')\nconst { getGlobalDispatcher } = require('../global')\nconst { webidl } = require('./webidl')\nconst { STATUS_CODES } = require('http')\nconst GET_OR_HEAD = ['GET', 'HEAD']\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\nlet ReadableStream = globalThis.ReadableStream\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n    // 2 terminated listeners get added per request,\n    // but only 1 gets removed. If there are 20 redirects,\n    // 21 listeners will be added.\n    // See https://github.com/nodejs/undici/issues/1711\n    // TODO (fix): Find and fix root cause for leaked listener.\n    this.setMaxListeners(21)\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controller’s state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controller’s serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = {}) {\n  webidl.argumentLengthCheck(arguments, 1, { header: 'globalThis.fetch' })\n\n  // 1. Let p be a new promise.\n  const p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObject’s signal’s abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n  const relevantRealm = null\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObject’s signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObject’s signal’s abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObject’s signal’s abort reason.\n      abortFetch(p, request, responseObject, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  const handleFetchDone = (response) =>\n    finalizeAndReportTiming(response, 'fetch')\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return Promise.resolve()\n    }\n\n    // 2. If response’s aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controller’s serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return Promise.resolve()\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(\n        Object.assign(new TypeError('fetch failed'), { cause: response.error })\n      )\n      return Promise.resolve()\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new Response()\n    responseObject[kState] = response\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = response.headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject)\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: init.dispatcher ?? getGlobalDispatcher() // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming (timingInfo, originalURL, initiatorType, globalThis, cacheState) {\n  if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {\n    performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // Note: AbortSignal.reason was added in node v17.2.0\n  // which would give us an undefined error to reject with.\n  // Remove this once node v16 is no longer supported.\n  if (!error) {\n    error = new DOMException('The operation was aborted.', 'AbortError')\n  }\n\n  // 1. Reject promise with error.\n  p.reject(error)\n\n  // 2. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 5. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher // undici\n}) {\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currenTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to\n  //    request’s body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    // TODO: What if request.client is null?\n    request.origin = request.client?.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept')) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value)\n  }\n\n  // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.contains('accept-language')) {\n    request.headersList.append('accept-language', '*')\n  }\n\n  // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams)\n    .catch(err => {\n      fetchParams.controller.terminate(err)\n    })\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch(fetchParams)\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.contains('range')\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    fetchParams.controller.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale(fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to bytes as a body.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError)\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParams’s request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on request’s current URL’s scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = require('buffer').resolveObjectURL\n      }\n\n      // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !isBlobLike(blobURLEntryObject)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let bodyWithType be the result of safely extracting blobURLEntry’s object.\n      const bodyWithType = safelyExtractBody(blobURLEntryObject)\n\n      // 4. Let body be bodyWithType’s body.\n      const body = bodyWithType[0]\n\n      // 5. Let length be body’s length, serialized and isomorphic encoded.\n      const length = isomorphicEncode(`${body.length}`)\n\n      // 6. Let type be bodyWithType’s type if it is non-null; otherwise the empty byte sequence.\n      const type = bodyWithType[1] ?? ''\n\n      // 7. Return a new response whose status message is `OK`, header list is\n      //    « (`Content-Length`, length), (`Content-Type`, type) », and body is body.\n      const response = makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-length', { name: 'Content-Length', value: length }],\n          ['content-type', { name: 'Content-Type', value: type }]\n        ]\n      })\n\n      response.body = body\n\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. If response is a network error, then:\n  if (response.type === 'error') {\n    // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n    response.urlList = [fetchParams.request.urlList[0]]\n\n    // 2. Set response’s timing info to the result of creating an opaque timing\n    // info for fetchParams’s timing info.\n    response.timingInfo = createOpaqueTimingInfo({\n      startTime: fetchParams.timingInfo.startTime\n    })\n  }\n\n  // 2. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Set fetchParams’s request’s done flag.\n    fetchParams.request.done = true\n\n    // If fetchParams’s process response end-of-body is not null,\n    // then queue a fetch task to run fetchParams’s process response\n    // end-of-body given response with fetchParams’s task destination.\n    if (fetchParams.processResponseEndOfBody != null) {\n      queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n    }\n  }\n\n  // 3. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => fetchParams.processResponse(response))\n  }\n\n  // 4. If response’s body is null, then run processResponseEndOfBody.\n  if (response.body == null) {\n    processResponseEndOfBody()\n  } else {\n  // 5. Otherwise:\n\n    // 1. Let transformStream be a new a TransformStream.\n\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,\n    // enqueues chunk in transformStream.\n    const identityTransformAlgorithm = (chunk, controller) => {\n      controller.enqueue(chunk)\n    }\n\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm\n    // and flushAlgorithm set to processResponseEndOfBody.\n    const transformStream = new TransformStream({\n      start () {},\n      transform: identityTransformAlgorithm,\n      flush: processResponseEndOfBody\n    }, {\n      size () {\n        return 1\n      }\n    }, {\n      size () {\n        return 1\n      }\n    })\n\n    // 4. Set response’s body to the result of piping response’s body through transformStream.\n    response.body = { stream: response.body.stream.pipeThrough(transformStream) }\n  }\n\n  // 6. If fetchParams’s process response consume body is non-null, then:\n  if (fetchParams.processResponseConsumeBody != null) {\n    // 1. Let processBody given nullOrBytes be this step: run fetchParams’s\n    // process response consume body given response and nullOrBytes.\n    const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes)\n\n    // 2. Let processBodyError be this step: run fetchParams’s process\n    // response consume body given response and failure.\n    const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure)\n\n    // 3. If response’s body is null, then queue a fetch task to run processBody\n    // given null, with fetchParams’s task destination.\n    if (response.body == null) {\n      queueMicrotask(() => processBody(null))\n    } else {\n      // 4. Otherwise, fully read response’s body given processBody, processBodyError,\n      // and fetchParams’s task destination.\n      return fullyReadBody(response.body, processBody, processBodyError)\n    }\n    return Promise.resolve()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy()\n    }\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If request’s redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase request’s redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !GET_OR_HEAD.includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s current URL’s origin is not same origin with locationURL’s\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from request’s header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization')\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true)\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie')\n    request.headersList.delete('host')\n  }\n\n  // 14. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = makeRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href))\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.contains('user-agent')) {\n    httpRequest.headersList.append('user-agent', typeof esbuildDetection === 'undefined' ? 'undici' : 'node')\n  }\n\n  //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since') ||\n      httpRequest.headersList.contains('if-none-match') ||\n      httpRequest.headersList.contains('if-unmodified-since') ||\n      httpRequest.headersList.contains('if-match') ||\n      httpRequest.headersList.contains('if-range'))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control')\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0')\n  }\n\n  //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('pragma')) {\n      httpRequest.headersList.append('pragma', 'no-cache')\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('cache-control')) {\n      httpRequest.headersList.append('cache-control', 'no-cache')\n    }\n  }\n\n  //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.contains('range')) {\n    httpRequest.headersList.append('accept-encoding', 'identity')\n  }\n\n  //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding')) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate')\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate')\n    }\n  }\n\n  httpRequest.headersList.delete('host')\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.mode === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethodsSet.has(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range')) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set response’s request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n      }\n    }\n  }\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on request’s mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit request’s body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = () => {\n    fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    fetchParams.controller.abort(reason)\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with pullAlgorithm set to pullAlgorithm,\n  // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n  // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      async pull (controller) {\n        await pullAlgorithm(controller)\n      },\n      async cancel (reason) {\n        await cancelAlgorithm(reason)\n      }\n    },\n    {\n      highWaterMark: 0,\n      size () {\n        return 1\n      }\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set response’s body to a new body whose stream is stream.\n  response.body = { stream }\n\n  //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  fetchParams.controller.on('terminated', onAborted)\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfo’s decoded body size by bytes’s length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParams’s controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      fetchParams.controller.controller.enqueue(new Uint8Array(bytes))\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (!fetchParams.controller.controller.desiredSize) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParams’s\n      //    controller’s serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  async function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n        },\n\n        onHeaders (status, headersList, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          let codings = []\n          let location = ''\n\n          const headers = new Headers()\n\n          // For H2, the headers are a plain JS object\n          // We distinguish between them and iterate accordingly\n          if (Array.isArray(headersList)) {\n            for (let n = 0; n < headersList.length; n += 2) {\n              const key = headersList[n + 0].toString('latin1')\n              const val = headersList[n + 1].toString('latin1')\n              if (key.toLowerCase() === 'content-encoding') {\n                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                // \"All content-coding values are case-insensitive...\"\n                codings = val.toLowerCase().split(',').map((x) => x.trim())\n              } else if (key.toLowerCase() === 'location') {\n                location = val\n              }\n\n              headers[kHeadersList].append(key, val)\n            }\n          } else {\n            const keys = Object.keys(headersList)\n            for (const key of keys) {\n              const val = headersList[key]\n              if (key.toLowerCase() === 'content-encoding') {\n                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                // \"All content-coding values are case-insensitive...\"\n                codings = val.toLowerCase().split(',').map((x) => x.trim()).reverse()\n              } else if (key.toLowerCase() === 'location') {\n                location = val\n              }\n\n              headers[kHeadersList].append(key, val)\n            }\n          }\n\n          this.body = new Readable({ read: resume })\n\n          const decoders = []\n\n          const willFollow = request.redirect === 'follow' &&\n            location &&\n            redirectStatusSet.has(status)\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            for (const coding of codings) {\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(zlib.createInflate())\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress())\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          resolve({\n            status,\n            statusText,\n            headersList: headers[kHeadersList],\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, () => { })\n              : this.body.on('error', () => {})\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from response’s\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and response’s header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, headersList, socket) {\n          if (status !== 101) {\n            return\n          }\n\n          const headers = new Headers()\n\n          for (let n = 0; n < headersList.length; n += 2) {\n            const key = headersList[n + 0].toString('latin1')\n            const val = headersList[n + 1].toString('latin1')\n\n            headers[kHeadersList].append(key, val)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList: headers[kHeadersList],\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n"],"names":["$jEVl2$pythonversioncheckc211052ejs4","$jEVl2$pythonversioncheck5597d583js","$jEVl2$pythonversioncheckff3942bajs1","$jEVl2$pythonversioncheck3f48d3eejs27","$jEVl2$pythonversioncheck92c00e26js3","$jEVl2$pythonversioncheck152f8bbajs","$jEVl2$pythonversioncheck863e006ejs5","$jEVl2$pythonversioncheckebf2a848js","$jEVl2$pythonversioncheck7ed1514ejs4","$jEVl2$pythonversioncheck685b5bb2js1","$jEVl2$pythonversioncheck2f8c5fadjs","$jEVl2$pythonversioncheck801bb0f1js","createGunzip","$jEVl2$createGunzip","constants","$jEVl2$constants","createInflate","$jEVl2$createInflate","createBrotliDecompress","$jEVl2$createBrotliDecompress","$jEVl2$assert","$jEVl2$events","Readable","$jEVl2$Readable","pipeline","$jEVl2$pipeline","TransformStream","$jEVl2$TransformStream","ReadableStream","$jEVl2$ReadableStream","STATUS_CODES","$jEVl2$STATUS_CODES","resolveObjectURL","$jEVl2$resolveObjectURL","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$16c52dcde4886f4d$var$resolveObjectURL","$16c52dcde4886f4d$require$Response","Response","$16c52dcde4886f4d$require$makeNetworkError","$jEVl2$pythonversioncheckc211052ejs2","makeNetworkError","$16c52dcde4886f4d$require$makeAppropriateNetworkError","$jEVl2$pythonversioncheckc211052ejs1","makeAppropriateNetworkError","$16c52dcde4886f4d$require$filterResponse","$jEVl2$pythonversioncheckc211052ejs","filterResponse","$16c52dcde4886f4d$require$makeResponse","$jEVl2$pythonversioncheckc211052ejs3","makeResponse","$16c52dcde4886f4d$require$Headers","Headers","$16c52dcde4886f4d$require$Request","Request","$16c52dcde4886f4d$require$makeRequest","$jEVl2$pythonversioncheckff3942bajs","makeRequest","$16c52dcde4886f4d$require$bytesMatch","$jEVl2$pythonversioncheck3f48d3eejs2","bytesMatch","$16c52dcde4886f4d$require$makePolicyContainer","$jEVl2$pythonversioncheck3f48d3eejs16","makePolicyContainer","$16c52dcde4886f4d$require$clonePolicyContainer","$jEVl2$pythonversioncheck3f48d3eejs3","clonePolicyContainer","$16c52dcde4886f4d$require$requestBadPort","$jEVl2$pythonversioncheck3f48d3eejs18","requestBadPort","$16c52dcde4886f4d$require$TAOCheck","$jEVl2$pythonversioncheck3f48d3eejs23","TAOCheck","$16c52dcde4886f4d$require$appendRequestOriginHeader","$jEVl2$pythonversioncheck3f48d3eejs1","appendRequestOriginHeader","$16c52dcde4886f4d$require$responseLocationURL","$jEVl2$pythonversioncheck3f48d3eejs20","responseLocationURL","$16c52dcde4886f4d$require$requestCurrentURL","$jEVl2$pythonversioncheck3f48d3eejs19","requestCurrentURL","$16c52dcde4886f4d$require$setRequestReferrerPolicyOnRedirect","$jEVl2$pythonversioncheck3f48d3eejs22","setRequestReferrerPolicyOnRedirect","$16c52dcde4886f4d$require$tryUpgradeRequestToAPotentiallyTrustworthyURL","$jEVl2$pythonversioncheck3f48d3eejs24","tryUpgradeRequestToAPotentiallyTrustworthyURL","$16c52dcde4886f4d$require$createOpaqueTimingInfo","$jEVl2$pythonversioncheck3f48d3eejs7","createOpaqueTimingInfo","$16c52dcde4886f4d$require$appendFetchMetadata","$jEVl2$pythonversioncheck3f48d3eejs","appendFetchMetadata","$16c52dcde4886f4d$require$corsCheck","$jEVl2$pythonversioncheck3f48d3eejs5","corsCheck","$16c52dcde4886f4d$require$crossOriginResourcePolicyCheck","$jEVl2$pythonversioncheck3f48d3eejs8","crossOriginResourcePolicyCheck","$16c52dcde4886f4d$require$determineRequestsReferrer","$jEVl2$pythonversioncheck3f48d3eejs9","determineRequestsReferrer","$16c52dcde4886f4d$require$coarsenedSharedCurrentTime","$jEVl2$pythonversioncheck3f48d3eejs4","coarsenedSharedCurrentTime","$16c52dcde4886f4d$require$createDeferredPromise","$jEVl2$pythonversioncheck3f48d3eejs6","createDeferredPromise","$16c52dcde4886f4d$require$isBlobLike","$jEVl2$pythonversioncheck3f48d3eejs12","isBlobLike","$16c52dcde4886f4d$require$sameOrigin","$jEVl2$pythonversioncheck3f48d3eejs21","sameOrigin","$16c52dcde4886f4d$require$isCancelled","$jEVl2$pythonversioncheck3f48d3eejs13","isCancelled","$16c52dcde4886f4d$require$isAborted","$jEVl2$pythonversioncheck3f48d3eejs11","isAborted","$16c52dcde4886f4d$require$isErrorLike","$jEVl2$pythonversioncheck3f48d3eejs14","isErrorLike","$16c52dcde4886f4d$require$fullyReadBody","$jEVl2$pythonversioncheck3f48d3eejs10","fullyReadBody","$16c52dcde4886f4d$require$readableStreamClose","$jEVl2$pythonversioncheck3f48d3eejs17","readableStreamClose","$16c52dcde4886f4d$require$isomorphicEncode","$jEVl2$pythonversioncheck3f48d3eejs15","isomorphicEncode","$16c52dcde4886f4d$require$urlIsLocal","urlIsLocal","$16c52dcde4886f4d$require$urlIsHttpHttpsScheme","$jEVl2$pythonversioncheck3f48d3eejs26","urlIsHttpHttpsScheme","$16c52dcde4886f4d$require$urlHasHttpsScheme","$jEVl2$pythonversioncheck3f48d3eejs25","urlHasHttpsScheme","$16c52dcde4886f4d$require$kState","kState","$16c52dcde4886f4d$require$kHeaders","$jEVl2$pythonversioncheck92c00e26js1","kHeaders","$16c52dcde4886f4d$require$kGuard","$jEVl2$pythonversioncheck92c00e26js","kGuard","$16c52dcde4886f4d$require$kRealm","$jEVl2$pythonversioncheck92c00e26js2","kRealm","$16c52dcde4886f4d$require$safelyExtractBody","safelyExtractBody","$16c52dcde4886f4d$require$redirectStatusSet","$jEVl2$pythonversioncheck863e006ejs2","redirectStatusSet","$16c52dcde4886f4d$require$nullBodyStatus","$jEVl2$pythonversioncheck863e006ejs1","nullBodyStatus","$16c52dcde4886f4d$require$safeMethodsSet","$jEVl2$pythonversioncheck863e006ejs4","safeMethodsSet","$16c52dcde4886f4d$require$requestBodyHeader","$jEVl2$pythonversioncheck863e006ejs3","requestBodyHeader","$16c52dcde4886f4d$require$subresourceSet","subresourceSet","$16c52dcde4886f4d$require$DOMException","$jEVl2$pythonversioncheck863e006ejs","DOMException","$16c52dcde4886f4d$require$kHeadersList","kHeadersList","$16c52dcde4886f4d$require$addAbortListener","$jEVl2$pythonversioncheck7ed1514ejs","addAbortListener","$16c52dcde4886f4d$require$isErrored","$jEVl2$pythonversioncheck7ed1514ejs1","isErrored","$16c52dcde4886f4d$require$isReadable","$jEVl2$pythonversioncheck7ed1514ejs2","isReadable","$16c52dcde4886f4d$require$nodeMajor","$jEVl2$pythonversioncheck7ed1514ejs3","nodeMajor","$16c52dcde4886f4d$require$nodeMinor","nodeMinor","$16c52dcde4886f4d$require$dataURLProcessor","$jEVl2$pythonversioncheck685b5bb2js","dataURLProcessor","$16c52dcde4886f4d$require$serializeAMimeType","serializeAMimeType","$16c52dcde4886f4d$require$getGlobalDispatcher","getGlobalDispatcher","$16c52dcde4886f4d$require$webidl","webidl","$16c52dcde4886f4d$var$GET_OR_HEAD","$16c52dcde4886f4d$var$ReadableStream","$16c52dcde4886f4d$var$Fetch","dispatcher","connection","dump","state","setMaxListeners","terminate","reason","destroy","emit","abort","error","serializedAbortReason","$16c52dcde4886f4d$var$finalizeAndReportTiming","response","initiatorType","type","aborted","urlList","length","originalURL","timingInfo","cacheState","globalThis1","timingAllowPassed","startTime","endTime","performance","markResourceTiming","href","$16c52dcde4886f4d$var$abortFetch","p","request","responseObject","reject","body","stream","cancel","catch","$16c52dcde4886f4d$var$fetching","processRequestBodyChunkLength","processRequestEndOfBody","processResponse","processResponseEndOfBody","processResponseConsumeBody","useParallelQueue","taskDestination","crossOriginIsolatedCapability","client","globalObject","fetchParams","controller","window","name","origin","policyContainer","headersList","contains","append","priority","has","destination","$16c52dcde4886f4d$var$mainFetch","recursive","localURLsOnly","referrerPolicy","referrer","currentURL","url","responseTainting","protocol","mode","$16c52dcde4886f4d$var$schemeFetch","redirect","$16c52dcde4886f4d$var$httpFetch","status","internalResponse","push","timingAllowFailed","rangeRequested","headers","method","includes","integrity","processBodyError","$16c52dcde4886f4d$var$fetchFinale","bytes","redirectCount","Promise","resolve","scheme","blobURLEntry","search","blobURLEntryObject","toString","bodyWithType","statusText","value","dataURLStruct","mimeType","done","queueMicrotask","transformStream","start","transform","chunk","enqueue","flush","size","pipeThrough","processBody","nullOrBytes","failure","actualResponse","serviceWorkers","$16c52dcde4886f4d$var$httpNetworkOrCacheFetch","$16c52dcde4886f4d$var$httpRedirectFetch","locationURL","hash","username","password","source","headerName","delete","redirectEndTime","postRedirectStartTime","redirectStartTime","isAuthenticationFetch","isNewConnectionFetch","httpFetchParams","httpRequest","includeCredentials","credentials","contentLength","contentLengthHeaderValue","keepalive","URL","esbuildDetection","cache","preventNoCacheCacheControlHeaderModification","forwardResponse","$16c52dcde4886f4d$var$httpNetworkFetch","requestIncludesCredentials","forceNewConnection","destroyed","requestBody","processBodyChunk","byteLength","e","socket","dispatch","iterator","Symbol","asyncIterator","next","pull","resume","highWaterMark","on","TypeError","cause","undefined","isFailure","ended","encodedBodySize","$16c52dcde4886f4d$var$finalizeResponse","processResponseDone","decodedBodySize","Uint8Array","desiredSize","agent","path","pathname","isMockActive","entries","maxRedirections","upgrade","onConnect","onHeaders","codings","location","Array","isArray","n","key","val","toLowerCase","split","map","x","trim","Object","keys","reverse","read","decoders","willFollow","coding","Z_SYNC_FLUSH","finishFlush","$16c52dcde4886f4d$require$pipeline","onData","onComplete","off","onError","onUpgrade","$16c52dcde4886f4d$require$STATUS_CODES","fetch","input","requestObject","argumentLengthCheck","arguments","header","promise","signal","locallyAborted","assign","Fetch","fetching","finalizeAndReportTiming"],"version":3,"file":"python-version-check.db834fc6.js.map","sourceRoot":"../"}