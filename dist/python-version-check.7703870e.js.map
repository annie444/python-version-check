{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/connection.js"],"sourcesContent":["import $eVhPF$pythonversioncheck64bbae24js1 from \"./python-version-check.64bbae24.js\";\nimport $eVhPF$pythonversioncheckf95b0f32js3 from \"./python-version-check.f95b0f32.js\";\nimport $eVhPF$pythonversioncheck92967d43js1 from \"./python-version-check.92967d43.js\";\nimport $eVhPF$pythonversioncheck13770064js from \"./python-version-check.13770064.js\";\nimport $eVhPF$pythonversioncheckff3942bajs from \"./python-version-check.ff3942ba.js\";\nimport $eVhPF$pythonversioncheckdb834fc6js from \"./python-version-check.db834fc6.js\";\nimport $eVhPF$pythonversioncheck5597d583js from \"./python-version-check.5597d583.js\";\nimport $eVhPF$pythonversioncheck2f8c5fadjs from \"./python-version-check.2f8c5fad.js\";\nimport $eVhPF$pythonversioncheckebf2a848js from \"./python-version-check.ebf2a848.js\";\nimport {channel as $eVhPF$channel} from \"diagnostics_channel\";\n\nvar $5dced762bb978606$exports = {};\n'use strict';\n\n\nvar $5dced762bb978606$require$uid = $eVhPF$pythonversioncheck64bbae24js1.uid;\nvar $5dced762bb978606$require$states = $eVhPF$pythonversioncheck64bbae24js.states;\n\nvar $5dced762bb978606$require$kReadyState = $eVhPF$pythonversioncheckf95b0f32js1.kReadyState;\nvar $5dced762bb978606$require$kSentClose = $eVhPF$pythonversioncheckf95b0f32js3.kSentClose;\nvar $5dced762bb978606$require$kByteParser = $eVhPF$pythonversioncheckf95b0f32js.kByteParser;\nvar $5dced762bb978606$require$kReceivedClose = $eVhPF$pythonversioncheckf95b0f32js2.kReceivedClose;\n\nvar $5dced762bb978606$require$fireEvent = $eVhPF$pythonversioncheck92967d43js1.fireEvent;\nvar $5dced762bb978606$require$failWebsocketConnection = $eVhPF$pythonversioncheck92967d43js.failWebsocketConnection;\n\nvar $5dced762bb978606$require$CloseEvent = $eVhPF$pythonversioncheck13770064js.CloseEvent;\n\nvar $5dced762bb978606$require$makeRequest = $eVhPF$pythonversioncheckff3942bajs.makeRequest;\n\nvar $5dced762bb978606$require$fetching = $eVhPF$pythonversioncheckdb834fc6js.fetching;\n\nvar $5dced762bb978606$require$Headers = $eVhPF$pythonversioncheck5597d583js.Headers;\n\nvar $5dced762bb978606$require$getGlobalDispatcher = $eVhPF$pythonversioncheck2f8c5fadjs.getGlobalDispatcher;\n\nvar $5dced762bb978606$require$kHeadersList = $eVhPF$pythonversioncheckebf2a848js.kHeadersList;\nconst $5dced762bb978606$var$channels = {};\n$5dced762bb978606$var$channels.open = $eVhPF$channel('undici:websocket:open');\n$5dced762bb978606$var$channels.close = $eVhPF$channel('undici:websocket:close');\n$5dced762bb978606$var$channels.socketError = $eVhPF$channel('undici:websocket:socket_error');\n/** @type {import('crypto')} */ let $5dced762bb978606$var$crypto;\n\ntry {\n    $5dced762bb978606$var$crypto = $5dced762bb978606$import$4e090cd3d9dfb5ec;\n} catch  {}\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */ function $5dced762bb978606$var$establishWebSocketConnection(url, protocols, ws, onEstablish, options) {\n    // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n    //    scheme is \"ws\", and to \"https\" otherwise.\n    const requestURL = url;\n    requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';\n    // 2. Let request be a new request, whose URL is requestURL, client is client,\n    //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n    //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n    //    and redirect mode is \"error\".\n    const request = $5dced762bb978606$require$makeRequest({\n        urlList: [\n            requestURL\n        ],\n        serviceWorkers: 'none',\n        referrer: 'no-referrer',\n        mode: 'websocket',\n        credentials: 'include',\n        cache: 'no-store',\n        redirect: 'error'\n    });\n    // Note: undici extension, allow setting custom headers.\n    if (options.headers) {\n        const headersList = new $5dced762bb978606$require$Headers(options.headers)[$5dced762bb978606$require$kHeadersList];\n        request.headersList = headersList;\n    }\n    // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n    // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n    // Note: both of these are handled by undici currently.\n    // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n    // 5. Let keyValue be a nonce consisting of a randomly selected\n    //    16-byte value that has been forgiving-base64-encoded and\n    //    isomorphic encoded.\n    const keyValue = $5dced762bb978606$var$crypto.randomBytes(16).toString('base64');\n    // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n    //    header list.\n    request.headersList.append('sec-websocket-key', keyValue);\n    // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n    //    header list.\n    request.headersList.append('sec-websocket-version', '13');\n    // 8. For each protocol in protocols, combine\n    //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n    //    list.\n    for (const protocol of protocols)request.headersList.append('sec-websocket-protocol', protocol);\n    // 9. Let permessageDeflate be a user-agent defined\n    //    \"permessage-deflate\" extension header value.\n    // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n    // TODO: enable once permessage-deflate is supported\n    const permessageDeflate = '' // 'permessage-deflate; 15'\n    ;\n    // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n    //     request’s header list.\n    // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n    // 11. Fetch request with useParallelQueue set to true, and\n    //     processResponse given response being these steps:\n    const controller = $5dced762bb978606$require$fetching({\n        request: request,\n        useParallelQueue: true,\n        dispatcher: options.dispatcher ?? $5dced762bb978606$require$getGlobalDispatcher(),\n        processResponse (response) {\n            // 1. If response is a network error or its status is not 101,\n            //    fail the WebSocket connection.\n            if (response.type === 'error' || response.status !== 101) {\n                $5dced762bb978606$require$failWebsocketConnection(ws, 'Received network error or non-101 status code.');\n                return;\n            }\n            // 2. If protocols is not the empty list and extracting header\n            //    list values given `Sec-WebSocket-Protocol` and response’s\n            //    header list results in null, failure, or the empty byte\n            //    sequence, then fail the WebSocket connection.\n            if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n                $5dced762bb978606$require$failWebsocketConnection(ws, 'Server did not respond with sent protocols.');\n                return;\n            }\n            // 3. Follow the requirements stated step 2 to step 6, inclusive,\n            //    of the last set of steps in section 4.1 of The WebSocket\n            //    Protocol to validate response. This either results in fail\n            //    the WebSocket connection or the WebSocket connection is\n            //    established.\n            // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n            //    header field contains a value that is not an ASCII case-\n            //    insensitive match for the value \"websocket\", the client MUST\n            //    _Fail the WebSocket Connection_.\n            if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n                $5dced762bb978606$require$failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n                return;\n            }\n            // 3. If the response lacks a |Connection| header field or the\n            //    |Connection| header field doesn't contain a token that is an\n            //    ASCII case-insensitive match for the value \"Upgrade\", the client\n            //    MUST _Fail the WebSocket Connection_.\n            if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n                $5dced762bb978606$require$failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n                return;\n            }\n            // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n            //    the |Sec-WebSocket-Accept| contains a value other than the\n            //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n            //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n            //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n            //    trailing whitespace, the client MUST _Fail the WebSocket\n            //    Connection_.\n            const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');\n            const digest = $5dced762bb978606$var$crypto.createHash('sha1').update(keyValue + $5dced762bb978606$require$uid).digest('base64');\n            if (secWSAccept !== digest) {\n                $5dced762bb978606$require$failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');\n                return;\n            }\n            // 5. If the response includes a |Sec-WebSocket-Extensions| header\n            //    field and this header field indicates the use of an extension\n            //    that was not present in the client's handshake (the server has\n            //    indicated an extension not requested by the client), the client\n            //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n            //    header field to determine which extensions are requested is\n            //    discussed in Section 9.1.)\n            const secExtension = response.headersList.get('Sec-WebSocket-Extensions');\n            if (secExtension !== null && secExtension !== permessageDeflate) {\n                $5dced762bb978606$require$failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.');\n                return;\n            }\n            // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n            //    and this header field indicates the use of a subprotocol that was\n            //    not present in the client's handshake (the server has indicated a\n            //    subprotocol not requested by the client), the client MUST _Fail\n            //    the WebSocket Connection_.\n            const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');\n            if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {\n                $5dced762bb978606$require$failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');\n                return;\n            }\n            response.socket.on('data', $5dced762bb978606$var$onSocketData);\n            response.socket.on('close', $5dced762bb978606$var$onSocketClose);\n            response.socket.on('error', $5dced762bb978606$var$onSocketError);\n            if ($5dced762bb978606$var$channels.open.hasSubscribers) $5dced762bb978606$var$channels.open.publish({\n                address: response.socket.address(),\n                protocol: secProtocol,\n                extensions: secExtension\n            });\n            onEstablish(response);\n        }\n    });\n    return controller;\n}\n/**\n * @param {Buffer} chunk\n */ function $5dced762bb978606$var$onSocketData(chunk) {\n    if (!this.ws[$5dced762bb978606$require$kByteParser].write(chunk)) this.pause();\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */ function $5dced762bb978606$var$onSocketClose() {\n    const { ws: ws } = this;\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean = ws[$5dced762bb978606$require$kSentClose] && ws[$5dced762bb978606$require$kReceivedClose];\n    let code = 1005;\n    let reason = '';\n    const result = ws[$5dced762bb978606$require$kByteParser].closingInfo;\n    if (result) {\n        code = result.code ?? 1005;\n        reason = result.reason;\n    } else if (!ws[$5dced762bb978606$require$kSentClose]) // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006;\n    // 1. Change the ready state to CLOSED (3).\n    ws[$5dced762bb978606$require$kReadyState] = $5dced762bb978606$require$states.CLOSED;\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    // TODO\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    $5dced762bb978606$require$fireEvent('close', ws, $5dced762bb978606$require$CloseEvent, {\n        wasClean: wasClean,\n        code: code,\n        reason: reason\n    });\n    if ($5dced762bb978606$var$channels.close.hasSubscribers) $5dced762bb978606$var$channels.close.publish({\n        websocket: ws,\n        code: code,\n        reason: reason\n    });\n}\nfunction $5dced762bb978606$var$onSocketError(error) {\n    const { ws: ws } = this;\n    ws[$5dced762bb978606$require$kReadyState] = $5dced762bb978606$require$states.CLOSING;\n    if ($5dced762bb978606$var$channels.socketError.hasSubscribers) $5dced762bb978606$var$channels.socketError.publish(error);\n    this.destroy();\n}\n$5dced762bb978606$exports = {\n    establishWebSocketConnection: $5dced762bb978606$var$establishWebSocketConnection\n};\n\n\nexport {$5dced762bb978606$exports as default};\n//# sourceMappingURL=python-version-check.7703870e.js.map\n","'use strict'\n\nconst diagnosticsChannel = require('diagnostics_channel')\nconst { uid, states } = require('./constants')\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose\n} = require('./symbols')\nconst { fireEvent, failWebsocketConnection } = require('./util')\nconst { CloseEvent } = require('./events')\nconst { makeRequest } = require('../fetch/request')\nconst { fetching } = require('../fetch/index')\nconst { Headers } = require('../fetch/headers')\nconst { getGlobalDispatcher } = require('../global')\nconst { kHeadersList } = require('../core/symbols')\n\nconst channels = {}\nchannels.open = diagnosticsChannel.channel('undici:websocket:open')\nchannels.close = diagnosticsChannel.channel('undici:websocket:close')\nchannels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error')\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = new Headers(options.headers)[kHeadersList]\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13')\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  // TODO: enable once permessage-deflate is supported\n  const permessageDeflate = '' // 'permessage-deflate; 15'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher ?? getGlobalDispatcher(),\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.')\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n\n      if (secExtension !== null && secExtension !== permessageDeflate) {\n        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.')\n        return\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')\n        return\n      }\n\n      response.socket.on('data', onSocketData)\n      response.socket.on('close', onSocketClose)\n      response.socket.on('error', onSocketError)\n\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        })\n      }\n\n      onEstablish(response)\n    }\n  })\n\n  return controller\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData (chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause()\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose () {\n  const { ws } = this\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] && ws[kReceivedClose]\n\n  let code = 1005\n  let reason = ''\n\n  const result = ws[kByteParser].closingInfo\n\n  if (result) {\n    code = result.code ?? 1005\n    reason = result.reason\n  } else if (!ws[kSentClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  fireEvent('close', ws, CloseEvent, {\n    wasClean, code, reason\n  })\n\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    })\n  }\n}\n\nfunction onSocketError (error) {\n  const { ws } = this\n\n  ws[kReadyState] = states.CLOSING\n\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error)\n  }\n\n  this.destroy()\n}\n\nmodule.exports = {\n  establishWebSocketConnection\n}\n"],"names":["$5dced762bb978606$var$crypto","$eVhPF$pythonversioncheck64bbae24js1","$eVhPF$pythonversioncheckf95b0f32js3","$eVhPF$pythonversioncheck92967d43js1","$eVhPF$pythonversioncheck13770064js","$eVhPF$pythonversioncheckff3942bajs","$eVhPF$pythonversioncheckdb834fc6js","$eVhPF$pythonversioncheck5597d583js","$eVhPF$pythonversioncheck2f8c5fadjs","$eVhPF$pythonversioncheckebf2a848js","channel","$eVhPF$channel","$5dced762bb978606$exports","$5dced762bb978606$require$uid","uid","$5dced762bb978606$require$states","$eVhPF$pythonversioncheck64bbae24js","states","$5dced762bb978606$require$kReadyState","$eVhPF$pythonversioncheckf95b0f32js1","kReadyState","$5dced762bb978606$require$kSentClose","kSentClose","$5dced762bb978606$require$kByteParser","$eVhPF$pythonversioncheckf95b0f32js","kByteParser","$5dced762bb978606$require$kReceivedClose","$eVhPF$pythonversioncheckf95b0f32js2","kReceivedClose","$5dced762bb978606$require$fireEvent","fireEvent","$5dced762bb978606$require$failWebsocketConnection","$eVhPF$pythonversioncheck92967d43js","failWebsocketConnection","$5dced762bb978606$require$CloseEvent","CloseEvent","$5dced762bb978606$require$makeRequest","makeRequest","$5dced762bb978606$require$fetching","fetching","$5dced762bb978606$require$Headers","Headers","$5dced762bb978606$require$getGlobalDispatcher","getGlobalDispatcher","$5dced762bb978606$require$kHeadersList","kHeadersList","$5dced762bb978606$var$channels","open","close","socketError","$5dced762bb978606$import$4e090cd3d9dfb5ec","$5dced762bb978606$var$onSocketData","chunk","ws","write","pause","$5dced762bb978606$var$onSocketClose","wasClean","code","reason","result","closingInfo","CLOSED","hasSubscribers","publish","websocket","$5dced762bb978606$var$onSocketError","error","CLOSING","destroy","establishWebSocketConnection","url","protocols","onEstablish","options","requestURL","protocol","request","urlList","serviceWorkers","referrer","mode","credentials","cache","redirect","headers","headersList","keyValue","randomBytes","toString","append","useParallelQueue","dispatcher","processResponse","response","type","status","length","get","toLowerCase","secWSAccept","createHash","update","digest","secExtension","secProtocol","socket","on","address","extensions","default"],"version":3,"file":"python-version-check.7703870e.js.map","sourceRoot":"../"}