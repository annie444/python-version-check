{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/parse.js"],"sourcesContent":["import $h8W1F$pythonversioncheck9a2fa160js1 from \"./python-version-check.9a2fa160.js\";\nimport $h8W1F$pythonversioncheckec4d8064js from \"./python-version-check.ec4d8064.js\";\nimport $h8W1F$pythonversioncheck685b5bb2js from \"./python-version-check.685b5bb2.js\";\nimport * as $h8W1F$assert from \"assert\";\n\nvar $a29ef03192201f14$exports = {};\n'use strict';\n\nvar $a29ef03192201f14$require$maxNameValuePairSize = $h8W1F$pythonversioncheck9a2fa160js1.maxNameValuePairSize;\nvar $a29ef03192201f14$require$maxAttributeValueSize = $h8W1F$pythonversioncheck9a2fa160js.maxAttributeValueSize;\n\nvar $a29ef03192201f14$require$isCTLExcludingHtab = $h8W1F$pythonversioncheckec4d8064js.isCTLExcludingHtab;\n\nvar $a29ef03192201f14$require$collectASequenceOfCodePointsFast = $h8W1F$pythonversioncheck685b5bb2js.collectASequenceOfCodePointsFast;\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */ function $a29ef03192201f14$var$parseSetCookie(header) {\n    // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n    //    character (CTL characters excluding HTAB): Abort these steps and\n    //    ignore the set-cookie-string entirely.\n    if ($a29ef03192201f14$require$isCTLExcludingHtab(header)) return null;\n    let nameValuePair = '';\n    let unparsedAttributes = '';\n    let name = '';\n    let value = '';\n    // 2. If the set-cookie-string contains a %x3B (\";\") character:\n    if (header.includes(';')) {\n        // 1. The name-value-pair string consists of the characters up to,\n        //    but not including, the first %x3B (\";\"), and the unparsed-\n        //    attributes consist of the remainder of the set-cookie-string\n        //    (including the %x3B (\";\") in question).\n        const position = {\n            position: 0\n        };\n        nameValuePair = $a29ef03192201f14$require$collectASequenceOfCodePointsFast(';', header, position);\n        unparsedAttributes = header.slice(position.position);\n    } else // Otherwise:\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header;\n    // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n    //    the name string is empty, and the value string is the value of\n    //    name-value-pair.\n    if (!nameValuePair.includes('=')) value = nameValuePair;\n    else {\n        //    Otherwise, the name string consists of the characters up to, but\n        //    not including, the first %x3D (\"=\") character, and the (possibly\n        //    empty) value string consists of the characters after the first\n        //    %x3D (\"=\") character.\n        const position = {\n            position: 0\n        };\n        name = $a29ef03192201f14$require$collectASequenceOfCodePointsFast('=', nameValuePair, position);\n        value = nameValuePair.slice(position.position + 1);\n    }\n    // 4. Remove any leading or trailing WSP characters from the name\n    //    string and the value string.\n    name = name.trim();\n    value = value.trim();\n    // 5. If the sum of the lengths of the name string and the value string\n    //    is more than 4096 octets, abort these steps and ignore the set-\n    //    cookie-string entirely.\n    if (name.length + value.length > $a29ef03192201f14$require$maxNameValuePairSize) return null;\n    // 6. The cookie-name is the name string, and the cookie-value is the\n    //    value string.\n    return {\n        name: name,\n        value: value,\n        ...$a29ef03192201f14$var$parseUnparsedAttributes(unparsedAttributes)\n    };\n}\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */ function $a29ef03192201f14$var$parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {\n    // 1. If the unparsed-attributes string is empty, skip the rest of\n    //    these steps.\n    if (unparsedAttributes.length === 0) return cookieAttributeList;\n    // 2. Discard the first character of the unparsed-attributes (which\n    //    will be a %x3B (\";\") character).\n    $h8W1F$assert(unparsedAttributes[0] === ';');\n    unparsedAttributes = unparsedAttributes.slice(1);\n    let cookieAv = '';\n    // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n    //    character:\n    if (unparsedAttributes.includes(';')) {\n        // 1. Consume the characters of the unparsed-attributes up to, but\n        //    not including, the first %x3B (\";\") character.\n        cookieAv = $a29ef03192201f14$require$collectASequenceOfCodePointsFast(';', unparsedAttributes, {\n            position: 0\n        });\n        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);\n    } else {\n        // Otherwise:\n        // 1. Consume the remainder of the unparsed-attributes.\n        cookieAv = unparsedAttributes;\n        unparsedAttributes = '';\n    }\n    // Let the cookie-av string be the characters consumed in this step.\n    let attributeName = '';\n    let attributeValue = '';\n    // 4. If the cookie-av string contains a %x3D (\"=\") character:\n    if (cookieAv.includes('=')) {\n        // 1. The (possibly empty) attribute-name string consists of the\n        //    characters up to, but not including, the first %x3D (\"=\")\n        //    character, and the (possibly empty) attribute-value string\n        //    consists of the characters after the first %x3D (\"=\")\n        //    character.\n        const position = {\n            position: 0\n        };\n        attributeName = $a29ef03192201f14$require$collectASequenceOfCodePointsFast('=', cookieAv, position);\n        attributeValue = cookieAv.slice(position.position + 1);\n    } else // Otherwise:\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv;\n    // 5. Remove any leading or trailing WSP characters from the attribute-\n    //    name string and the attribute-value string.\n    attributeName = attributeName.trim();\n    attributeValue = attributeValue.trim();\n    // 6. If the attribute-value is longer than 1024 octets, ignore the\n    //    cookie-av string and return to Step 1 of this algorithm.\n    if (attributeValue.length > $a29ef03192201f14$require$maxAttributeValueSize) return $a29ef03192201f14$var$parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n    // 7. Process the attribute-name and attribute-value according to the\n    //    requirements in the following subsections.  (Notice that\n    //    attributes with unrecognized attribute-names are ignored.)\n    const attributeNameLowercase = attributeName.toLowerCase();\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n    // If the attribute-name case-insensitively matches the string\n    // \"Expires\", the user agent MUST process the cookie-av as follows.\n    if (attributeNameLowercase === 'expires') {\n        // 1. Let the expiry-time be the result of parsing the attribute-value\n        //    as cookie-date (see Section 5.1.1).\n        const expiryTime = new Date(attributeValue);\n        // 2. If the attribute-value failed to parse as a cookie date, ignore\n        //    the cookie-av.\n        cookieAttributeList.expires = expiryTime;\n    } else if (attributeNameLowercase === 'max-age') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n        // If the attribute-name case-insensitively matches the string \"Max-\n        // Age\", the user agent MUST process the cookie-av as follows.\n        // 1. If the first character of the attribute-value is not a DIGIT or a\n        //    \"-\" character, ignore the cookie-av.\n        const charCode = attributeValue.charCodeAt(0);\n        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') return $a29ef03192201f14$var$parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        // 2. If the remainder of attribute-value contains a non-DIGIT\n        //    character, ignore the cookie-av.\n        if (!/^\\d+$/.test(attributeValue)) return $a29ef03192201f14$var$parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        // 3. Let delta-seconds be the attribute-value converted to an integer.\n        const deltaSeconds = Number(attributeValue);\n        // 4. Let cookie-age-limit be the maximum age of the cookie (which\n        //    SHOULD be 400 days or less, see Section 4.1.2.2).\n        // 5. Set delta-seconds to the smaller of its present value and cookie-\n        //    age-limit.\n        // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n        // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n        //    time be the earliest representable date and time.  Otherwise, let\n        //    the expiry-time be the current date and time plus delta-seconds\n        //    seconds.\n        // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n        // 7. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Max-Age and an attribute-value of expiry-time.\n        cookieAttributeList.maxAge = deltaSeconds;\n    } else if (attributeNameLowercase === 'domain') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n        // If the attribute-name case-insensitively matches the string \"Domain\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. Let cookie-domain be the attribute-value.\n        let cookieDomain = attributeValue;\n        // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n        //    cookie-domain without its leading %x2E (\".\").\n        if (cookieDomain[0] === '.') cookieDomain = cookieDomain.slice(1);\n        // 3. Convert the cookie-domain to lower case.\n        cookieDomain = cookieDomain.toLowerCase();\n        // 4. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Domain and an attribute-value of cookie-domain.\n        cookieAttributeList.domain = cookieDomain;\n    } else if (attributeNameLowercase === 'path') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n        // If the attribute-name case-insensitively matches the string \"Path\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. If the attribute-value is empty or if the first character of the\n        //    attribute-value is not %x2F (\"/\"):\n        let cookiePath = '';\n        if (attributeValue.length === 0 || attributeValue[0] !== '/') // 1. Let cookie-path be the default-path.\n        cookiePath = '/';\n        else // Otherwise:\n        // 1. Let cookie-path be the attribute-value.\n        cookiePath = attributeValue;\n        // 2. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Path and an attribute-value of cookie-path.\n        cookieAttributeList.path = cookiePath;\n    } else if (attributeNameLowercase === 'secure') // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n    cookieAttributeList.secure = true;\n    else if (attributeNameLowercase === 'httponly') // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n    cookieAttributeList.httpOnly = true;\n    else if (attributeNameLowercase === 'samesite') {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n        // If the attribute-name case-insensitively matches the string\n        // \"SameSite\", the user agent MUST process the cookie-av as follows:\n        // 1. Let enforcement be \"Default\".\n        let enforcement = 'Default';\n        const attributeValueLowercase = attributeValue.toLowerCase();\n        // 2. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"None\", set enforcement to \"None\".\n        if (attributeValueLowercase.includes('none')) enforcement = 'None';\n        // 3. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Strict\", set enforcement to \"Strict\".\n        if (attributeValueLowercase.includes('strict')) enforcement = 'Strict';\n        // 4. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Lax\", set enforcement to \"Lax\".\n        if (attributeValueLowercase.includes('lax')) enforcement = 'Lax';\n        // 5. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of \"SameSite\" and an attribute-value of\n        //    enforcement.\n        cookieAttributeList.sameSite = enforcement;\n    } else {\n        cookieAttributeList.unparsed ??= [];\n        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);\n    }\n    // 8. Return to Step 1 of this algorithm.\n    return $a29ef03192201f14$var$parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n}\n$a29ef03192201f14$exports = {\n    parseSetCookie: $a29ef03192201f14$var$parseSetCookie,\n    parseUnparsedAttributes: $a29ef03192201f14$var$parseUnparsedAttributes\n};\n\n\nexport {$a29ef03192201f14$exports as default};\n//# sourceMappingURL=python-version-check.8907a7bc.js.map\n","'use strict'\n\nconst { maxNameValuePairSize, maxAttributeValueSize } = require('./constants')\nconst { isCTLExcludingHtab } = require('./util')\nconst { collectASequenceOfCodePointsFast } = require('../fetch/dataURL')\nconst assert = require('assert')\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  return {\n    name, value, ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n"],"names":["$h8W1F$pythonversioncheck9a2fa160js1","$h8W1F$pythonversioncheckec4d8064js","$h8W1F$pythonversioncheck685b5bb2js","$h8W1F$assert","$a29ef03192201f14$exports","$a29ef03192201f14$require$maxNameValuePairSize","maxNameValuePairSize","$a29ef03192201f14$require$maxAttributeValueSize","$h8W1F$pythonversioncheck9a2fa160js","maxAttributeValueSize","$a29ef03192201f14$require$isCTLExcludingHtab","isCTLExcludingHtab","$a29ef03192201f14$require$collectASequenceOfCodePointsFast","collectASequenceOfCodePointsFast","$a29ef03192201f14$var$parseUnparsedAttributes","unparsedAttributes","cookieAttributeList","length","cookieAv","slice","includes","position","attributeName","attributeValue","trim","attributeNameLowercase","toLowerCase","expires","Date","charCode","charCodeAt","test","maxAge","Number","cookieDomain","domain","path","secure","httpOnly","enforcement","attributeValueLowercase","sameSite","unparsed","push","parseSetCookie","header","nameValuePair","name","value","parseUnparsedAttributes","default"],"version":3,"file":"python-version-check.8907a7bc.js.map","sourceRoot":"../"}