{"mappings":"A,M,K,A,Q,W,C,K,K,A,Q,W,C,C,S,C,K,M,A,Q,W,C,K,O,A,Q,gB,C,K,Q,A,O,Q,A,Q,Y,C,K,M,C,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,MCWA,EACA,EACA,EACA,EAyPA,EAdI,EA3MJ,SAAS,EAAe,CAAO,EAC7B,IAAI,EAAO,IAAI,AACf,CAAA,EAAK,OAAO,CAAG,GAAW,CAAC,EAC3B,EAAK,YAAY,CAAG,EAAK,OAAO,CAAC,KAAK,EAAI,CAAC,EAC3C,EAAK,UAAU,CAAG,EAAK,OAAO,CAAC,UAAU,EAAI,EAAW,iBAAiB,CACzE,EAAK,QAAQ,CAAG,EAAE,CAClB,EAAK,OAAO,CAAG,EAAE,CAEjB,EAAK,EAAE,CAAC,OAAQ,SAAgB,CAAM,CAAE,CAAI,CAAE,CAAI,CAAE,CAAY,EAE9D,IAAK,IADD,EAAU,EAAU,EAAM,EAAM,GAC3B,EAAI,EAAG,EAAM,EAAK,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAK,EAAE,EAAG,CACxD,IAAI,EAAU,EAAK,QAAQ,CAAC,EAAE,CAC9B,GAAI,EAAQ,IAAI,GAAK,EAAQ,IAAI,EAAI,EAAQ,IAAI,GAAK,EAAQ,IAAI,CAAE,CAGlE,EAAK,QAAQ,CAAC,MAAM,CAAC,EAAG,GACxB,EAAQ,OAAO,CAAC,QAAQ,CAAC,GACzB,MACF,CACF,CACA,EAAO,OAAO,GACd,EAAK,YAAY,CAAC,EACpB,EACF,CAuIA,SAAS,EAAmB,CAAO,CAAE,CAAE,EACrC,IAAI,EAAO,IAAI,CACf,EAAe,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,EAAM,EAAS,SAAS,CAAM,EACvE,IAAI,EAAa,EAAQ,OAAO,CAAC,SAAS,CAAC,QAOvC,EAAe,EAAY,EANd,EAAa,CAAC,EAAG,EAAK,OAAO,CAAE,CAC9C,OAAQ,EACR,WAAY,EAAa,EAAW,OAAO,CAAC,OAAQ,IAAM,EAAQ,IAAI,AACxE,GAIA,CAAA,EAAK,OAAO,CAAC,EAAK,OAAO,CAAC,OAAO,CAAC,GAAQ,CAAG,EAC7C,EAAG,EACL,EACF,CAGA,SAAS,EAAU,CAAI,CAAE,CAAI,CAAE,CAAY,QACzC,AAAI,AAAgB,UAAhB,OAAO,EACF,CACL,KAAM,EACN,KAAM,EACN,aAAc,CAChB,EAEK,CACT,CAEA,SAAS,EAAa,CAAM,EAC1B,IAAK,IAAI,EAAI,EAAG,EAAM,UAAU,MAAM,CAAE,EAAI,EAAK,EAAE,EAAG,CACpD,IAAI,EAAY,SAAS,CAAC,EAAE,CAC5B,GAAI,AAAqB,UAArB,OAAO,EAET,IAAK,IADD,EAAO,OAAO,IAAI,CAAC,GACd,EAAI,EAAG,EAAS,EAAK,MAAM,CAAE,EAAI,EAAQ,EAAE,EAAG,CACrD,IAAI,EAAI,CAAI,CAAC,EAAE,AACX,AAAiB,MAAA,IAAjB,CAAS,CAAC,EAAE,EACd,CAAA,CAAM,CAAC,EAAE,CAAG,CAAS,CAAC,EAAE,AAAF,CAE1B,CAEJ,CACA,OAAO,CACT,C,E,E,O,C,e,I,E,A,G,E,G,E,E,O,C,gB,I,E,A,G,E,G,E,E,O,C,gB,I,E,A,G,E,G,E,E,O,C,iB,I,E,A,G,E,G,E,E,O,C,Q,I,E,A,G,E,GA3OA,EAMA,SAAsB,CAAO,EAC3B,IAAI,EAAQ,IAAI,EAAe,GAE/B,OADA,EAAM,OAAO,CAAG,EACT,CACT,EATA,EAWA,SAAuB,CAAO,EAC5B,IAAI,EAAQ,IAAI,EAAe,GAI/B,OAHA,EAAM,OAAO,CAAG,EAChB,EAAM,YAAY,CAAG,EACrB,EAAM,WAAW,CAAG,IACb,CACT,EAhBA,EAkBA,SAAuB,CAAO,EAC5B,IAAI,EAAQ,IAAI,EAAe,GAE/B,OADA,EAAM,OAAO,CAAG,EACT,CACT,EArBA,EAuBA,SAAwB,CAAO,EAC7B,IAAI,EAAQ,IAAI,EAAe,GAI/B,OAHA,EAAM,OAAO,CAAG,EAChB,EAAM,YAAY,CAAG,EACrB,EAAM,WAAW,CAAG,IACb,CACT,EA2BA,EAAc,EAAgB,GAE9B,EAAe,SAAS,CAAC,UAAU,CAAG,SAAoB,CAAG,CAAE,CAAI,CAAE,CAAI,CAAE,CAAY,EACrF,IAAI,EAAO,IAAI,CACX,EAAU,EAAa,CAAC,QAAS,CAAG,EAAG,EAAK,OAAO,CAAE,EAAU,EAAM,EAAM,IAE/E,GAAI,EAAK,OAAO,CAAC,MAAM,EAAI,IAAI,CAAC,UAAU,CAAE,YAE1C,EAAK,QAAQ,CAAC,IAAI,CAAC,GAKrB,EAAK,YAAY,CAAC,EAAS,SAAS,CAAM,EAMxC,SAAS,IACP,EAAK,IAAI,CAAC,OAAQ,EAAQ,EAC5B,CAEA,SAAS,EAAgB,CAAG,EAC1B,EAAK,YAAY,CAAC,GAClB,EAAO,cAAc,CAAC,OAAQ,GAC9B,EAAO,cAAc,CAAC,QAAS,GAC/B,EAAO,cAAc,CAAC,cAAe,EACvC,CAdA,EAAO,EAAE,CAAC,OAAQ,GAClB,EAAO,EAAE,CAAC,QAAS,GACnB,EAAO,EAAE,CAAC,cAAe,GACzB,EAAI,QAAQ,CAAC,EAYf,EACF,EAEA,EAAe,SAAS,CAAC,YAAY,CAAG,SAAsB,CAAO,CAAE,CAAE,EACvE,IAAI,EAAO,IAAI,CACX,EAAc,CAAC,EACnB,EAAK,OAAO,CAAC,IAAI,CAAC,GAElB,IAAI,EAAiB,EAAa,CAAC,EAAG,EAAK,YAAY,CAAE,CACvD,OAAQ,UACR,KAAM,EAAQ,IAAI,CAAG,IAAM,EAAQ,IAAI,CACvC,MAAO,CAAA,EACP,QAAS,CACP,KAAM,EAAQ,IAAI,CAAG,IAAM,EAAQ,IAAI,AACzC,CACF,EACI,CAAA,EAAQ,YAAY,EACtB,CAAA,EAAe,YAAY,CAAG,EAAQ,YAAY,AAAZ,EAEpC,EAAe,SAAS,GAC1B,EAAe,OAAO,CAAG,EAAe,OAAO,EAAI,CAAC,EACpD,EAAe,OAAO,CAAC,sBAAsB,CAAG,SAC5C,IAAI,OAAO,EAAe,SAAS,EAAE,QAAQ,CAAC,WAGpD,EAAM,0BACN,IAAI,EAAa,EAAK,OAAO,CAAC,GAoB9B,SAAS,EAAU,CAAG,CAAE,CAAM,CAAE,CAAI,EAIlC,GAHA,EAAW,kBAAkB,GAC7B,EAAO,kBAAkB,GAErB,AAAmB,MAAnB,EAAI,UAAU,CAAU,CAC1B,EAAM,2DACJ,EAAI,UAAU,EAChB,EAAO,OAAO,GACd,IAAI,EAAQ,AAAI,MAAM,yDACJ,EAAI,UAAU,CAChC,CAAA,EAAM,IAAI,CAAG,aACb,EAAQ,OAAO,CAAC,IAAI,CAAC,QAAS,GAC9B,EAAK,YAAY,CAAC,GAClB,MACF,CACA,GAAI,EAAK,MAAM,CAAG,EAAG,CACnB,EAAM,wCACN,EAAO,OAAO,GACd,IAAI,EAAQ,AAAI,MAAM,uCACtB,CAAA,EAAM,IAAI,CAAG,aACb,EAAQ,OAAO,CAAC,IAAI,CAAC,QAAS,GAC9B,EAAK,YAAY,CAAC,GAClB,MACF,CAGA,OAFA,EAAM,wCACN,EAAK,OAAO,CAAC,EAAK,OAAO,CAAC,OAAO,CAAC,GAAa,CAAG,EAC3C,EAAG,EACZ,CA9CA,EAAW,2BAA2B,CAAG,CAAA,EACzC,EAAW,IAAI,CAAC,WAMhB,SAAoB,CAAG,EAErB,EAAI,OAAO,CAAG,CAAA,CAChB,GARA,EAAW,IAAI,CAAC,UAUhB,SAAmB,CAAG,CAAE,CAAM,CAAE,CAAI,EAElC,QAAQ,QAAQ,CAAC,WACf,EAAU,EAAK,EAAQ,EACzB,EACF,GAdA,EAAW,IAAI,CAAC,UAAW,GAC3B,EAAW,IAAI,CAAC,QA4ChB,SAAiB,CAAK,EACpB,EAAW,kBAAkB,GAE7B,EAAM,wDACA,EAAM,OAAO,CAAE,EAAM,KAAK,EAChC,IAAI,EAAQ,AAAI,MAAM,oDACW,EAAM,OAAO,CAC9C,CAAA,EAAM,IAAI,CAAG,aACb,EAAQ,OAAO,CAAC,IAAI,CAAC,QAAS,GAC9B,EAAK,YAAY,CAAC,EACpB,GArDA,EAAW,GAAG,EAsDhB,EAEA,EAAe,SAAS,CAAC,YAAY,CAAG,SAAsB,CAAM,EAClE,IAAI,EAAM,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAC/B,GAAI,AAAQ,KAAR,GAGJ,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAK,GAEzB,IAAI,EAAU,IAAI,CAAC,QAAQ,CAAC,KAAK,EAC7B,CAAA,GAGF,IAAI,CAAC,YAAY,CAAC,EAAS,SAAS,CAAM,EACxC,EAAQ,OAAO,CAAC,QAAQ,CAAC,EAC3B,GAEJ,EA6DA,EAZE,EADE,QAAQ,GAAG,CAAC,UAAU,EAAI,aAAa,IAAI,CAAC,QAAQ,GAAG,CAAC,UAAU,EAC5D,WACN,IAAI,EAAO,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,UAClC,AAAmB,CAAA,UAAnB,OAAO,CAAI,CAAC,EAAE,CAChB,CAAI,CAAC,EAAE,CAAG,WAAa,CAAI,CAAC,EAAE,CAE9B,EAAK,OAAO,CAAC,WAEf,QAAQ,KAAK,CAAC,KAAK,CAAC,QAAS,EAC/B,EAEQ,WAAY,C,G,E","sources":["<anon>","node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js"],"sourcesContent":["import \"net\";\nimport {connect as $5qno9$connect} from \"tls\";\nimport {request as $5qno9$request, Agent as $5qno9$Agent} from \"http\";\nimport {request as $5qno9$request1} from \"https\";\nimport {EventEmitter as $5qno9$EventEmitter} from \"events\";\nimport \"assert\";\nimport {inherits as $5qno9$inherits} from \"util\";\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5a65\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5a65\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"fi4VQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"httpOverHttp\", () => $b21c5cd64305014d$export$25cbd437c61a3835, (v) => $b21c5cd64305014d$export$25cbd437c61a3835 = v);\n$parcel$export(module.exports, \"httpsOverHttp\", () => $b21c5cd64305014d$export$c06e3df7111bae43, (v) => $b21c5cd64305014d$export$c06e3df7111bae43 = v);\n$parcel$export(module.exports, \"httpOverHttps\", () => $b21c5cd64305014d$export$5d50e36ef656139f, (v) => $b21c5cd64305014d$export$5d50e36ef656139f = v);\n$parcel$export(module.exports, \"httpsOverHttps\", () => $b21c5cd64305014d$export$212d6605025321cc, (v) => $b21c5cd64305014d$export$212d6605025321cc = v);\n$parcel$export(module.exports, \"debug\", () => $b21c5cd64305014d$export$1c9f709888824e05, (v) => $b21c5cd64305014d$export$1c9f709888824e05 = v);\nvar $b21c5cd64305014d$export$25cbd437c61a3835;\nvar $b21c5cd64305014d$export$c06e3df7111bae43;\nvar $b21c5cd64305014d$export$5d50e36ef656139f;\nvar $b21c5cd64305014d$export$212d6605025321cc;\nvar $b21c5cd64305014d$export$1c9f709888824e05;\n'use strict';\n\n\n\n\n\n\n\n$b21c5cd64305014d$export$25cbd437c61a3835 = $b21c5cd64305014d$var$httpOverHttp;\n$b21c5cd64305014d$export$c06e3df7111bae43 = $b21c5cd64305014d$var$httpsOverHttp;\n$b21c5cd64305014d$export$5d50e36ef656139f = $b21c5cd64305014d$var$httpOverHttps;\n$b21c5cd64305014d$export$212d6605025321cc = $b21c5cd64305014d$var$httpsOverHttps;\nfunction $b21c5cd64305014d$var$httpOverHttp(options) {\n    var agent = new $b21c5cd64305014d$var$TunnelingAgent(options);\n    agent.request = $5qno9$request;\n    return agent;\n}\nfunction $b21c5cd64305014d$var$httpsOverHttp(options) {\n    var agent = new $b21c5cd64305014d$var$TunnelingAgent(options);\n    agent.request = $5qno9$request;\n    agent.createSocket = $b21c5cd64305014d$var$createSecureSocket;\n    agent.defaultPort = 443;\n    return agent;\n}\nfunction $b21c5cd64305014d$var$httpOverHttps(options) {\n    var agent = new $b21c5cd64305014d$var$TunnelingAgent(options);\n    agent.request = $5qno9$request1;\n    return agent;\n}\nfunction $b21c5cd64305014d$var$httpsOverHttps(options) {\n    var agent = new $b21c5cd64305014d$var$TunnelingAgent(options);\n    agent.request = $5qno9$request1;\n    agent.createSocket = $b21c5cd64305014d$var$createSecureSocket;\n    agent.defaultPort = 443;\n    return agent;\n}\nfunction $b21c5cd64305014d$var$TunnelingAgent(options) {\n    var self = this;\n    self.options = options || {};\n    self.proxyOptions = self.options.proxy || {};\n    self.maxSockets = self.options.maxSockets || $5qno9$Agent.defaultMaxSockets;\n    self.requests = [];\n    self.sockets = [];\n    self.on('free', function onFree(socket, host, port, localAddress) {\n        var options = $b21c5cd64305014d$var$toOptions(host, port, localAddress);\n        for(var i = 0, len = self.requests.length; i < len; ++i){\n            var pending = self.requests[i];\n            if (pending.host === options.host && pending.port === options.port) {\n                // Detect the request to connect same origin server,\n                // reuse the connection.\n                self.requests.splice(i, 1);\n                pending.request.onSocket(socket);\n                return;\n            }\n        }\n        socket.destroy();\n        self.removeSocket(socket);\n    });\n}\n$5qno9$inherits($b21c5cd64305014d$var$TunnelingAgent, $5qno9$EventEmitter);\n$b21c5cd64305014d$var$TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n    var self = this;\n    var options = $b21c5cd64305014d$var$mergeOptions({\n        request: req\n    }, self.options, $b21c5cd64305014d$var$toOptions(host, port, localAddress));\n    if (self.sockets.length >= this.maxSockets) {\n        // We are over limit so we'll add it to the queue.\n        self.requests.push(options);\n        return;\n    }\n    // If we are under maxSockets create a new one.\n    self.createSocket(options, function(socket) {\n        socket.on('free', onFree);\n        socket.on('close', onCloseOrRemove);\n        socket.on('agentRemove', onCloseOrRemove);\n        req.onSocket(socket);\n        function onFree() {\n            self.emit('free', socket, options);\n        }\n        function onCloseOrRemove(err) {\n            self.removeSocket(socket);\n            socket.removeListener('free', onFree);\n            socket.removeListener('close', onCloseOrRemove);\n            socket.removeListener('agentRemove', onCloseOrRemove);\n        }\n    });\n};\n$b21c5cd64305014d$var$TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n    var self = this;\n    var placeholder = {};\n    self.sockets.push(placeholder);\n    var connectOptions = $b21c5cd64305014d$var$mergeOptions({}, self.proxyOptions, {\n        method: 'CONNECT',\n        path: options.host + ':' + options.port,\n        agent: false,\n        headers: {\n            host: options.host + ':' + options.port\n        }\n    });\n    if (options.localAddress) connectOptions.localAddress = options.localAddress;\n    if (connectOptions.proxyAuth) {\n        connectOptions.headers = connectOptions.headers || {};\n        connectOptions.headers['Proxy-Authorization'] = 'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64');\n    }\n    $b21c5cd64305014d$var$debug('making CONNECT request');\n    var connectReq = self.request(connectOptions);\n    connectReq.useChunkedEncodingByDefault = false; // for v0.6\n    connectReq.once('response', onResponse); // for v0.6\n    connectReq.once('upgrade', onUpgrade); // for v0.6\n    connectReq.once('connect', onConnect); // for v0.7 or later\n    connectReq.once('error', onError);\n    connectReq.end();\n    function onResponse(res) {\n        // Very hacky. This is necessary to avoid http-parser leaks.\n        res.upgrade = true;\n    }\n    function onUpgrade(res, socket, head) {\n        // Hacky.\n        process.nextTick(function() {\n            onConnect(res, socket, head);\n        });\n    }\n    function onConnect(res, socket, head) {\n        connectReq.removeAllListeners();\n        socket.removeAllListeners();\n        if (res.statusCode !== 200) {\n            $b21c5cd64305014d$var$debug('tunneling socket could not be established, statusCode=%d', res.statusCode);\n            socket.destroy();\n            var error = new Error(\"tunneling socket could not be established, statusCode=\" + res.statusCode);\n            error.code = 'ECONNRESET';\n            options.request.emit('error', error);\n            self.removeSocket(placeholder);\n            return;\n        }\n        if (head.length > 0) {\n            $b21c5cd64305014d$var$debug('got illegal response body from proxy');\n            socket.destroy();\n            var error = new Error('got illegal response body from proxy');\n            error.code = 'ECONNRESET';\n            options.request.emit('error', error);\n            self.removeSocket(placeholder);\n            return;\n        }\n        $b21c5cd64305014d$var$debug('tunneling connection has established');\n        self.sockets[self.sockets.indexOf(placeholder)] = socket;\n        return cb(socket);\n    }\n    function onError(cause) {\n        connectReq.removeAllListeners();\n        $b21c5cd64305014d$var$debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack);\n        var error = new Error(\"tunneling socket could not be established, cause=\" + cause.message);\n        error.code = 'ECONNRESET';\n        options.request.emit('error', error);\n        self.removeSocket(placeholder);\n    }\n};\n$b21c5cd64305014d$var$TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n    var pos = this.sockets.indexOf(socket);\n    if (pos === -1) return;\n    this.sockets.splice(pos, 1);\n    var pending = this.requests.shift();\n    if (pending) // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n        pending.request.onSocket(socket);\n    });\n};\nfunction $b21c5cd64305014d$var$createSecureSocket(options, cb) {\n    var self = this;\n    $b21c5cd64305014d$var$TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n        var hostHeader = options.request.getHeader('host');\n        var tlsOptions = $b21c5cd64305014d$var$mergeOptions({}, self.options, {\n            socket: socket,\n            servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n        });\n        // 0 is dummy port for v0.6\n        var secureSocket = $5qno9$connect(0, tlsOptions);\n        self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n        cb(secureSocket);\n    });\n}\nfunction $b21c5cd64305014d$var$toOptions(host, port, localAddress) {\n    if (typeof host === 'string') return {\n        host: host,\n        port: port,\n        localAddress: localAddress\n    };\n    return host; // for v0.11 or later\n}\nfunction $b21c5cd64305014d$var$mergeOptions(target) {\n    for(var i = 1, len = arguments.length; i < len; ++i){\n        var overrides = arguments[i];\n        if (typeof overrides === 'object') {\n            var keys = Object.keys(overrides);\n            for(var j = 0, keyLen = keys.length; j < keyLen; ++j){\n                var k = keys[j];\n                if (overrides[k] !== undefined) target[k] = overrides[k];\n            }\n        }\n    }\n    return target;\n}\nvar $b21c5cd64305014d$var$debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) $b21c5cd64305014d$var$debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') args[0] = 'TUNNEL: ' + args[0];\n    else args.unshift('TUNNEL:');\n    console.error.apply(console, args);\n};\nelse $b21c5cd64305014d$var$debug = function() {};\n$b21c5cd64305014d$export$1c9f709888824e05 = $b21c5cd64305014d$var$debug; // for test\n\n});\n\n\nparcelRequire(\"fi4VQ\");\n\n//# sourceMappingURL=python-version-check.929971c1.js.map\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n"],"names":["connect","$5qno9$connect","request","$5qno9$request","Agent","$5qno9$Agent","$5qno9$request1","EventEmitter","$5qno9$EventEmitter","inherits","$5qno9$inherits","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$b21c5cd64305014d$export$25cbd437c61a3835","$b21c5cd64305014d$export$c06e3df7111bae43","$b21c5cd64305014d$export$5d50e36ef656139f","$b21c5cd64305014d$export$212d6605025321cc","$b21c5cd64305014d$export$1c9f709888824e05","$b21c5cd64305014d$var$debug","$b21c5cd64305014d$var$TunnelingAgent","options","self","proxyOptions","proxy","maxSockets","defaultMaxSockets","requests","sockets","on","socket","host","port","localAddress","$b21c5cd64305014d$var$toOptions","i","len","length","pending","splice","onSocket","destroy","removeSocket","$b21c5cd64305014d$var$createSecureSocket","cb","prototype","createSocket","hostHeader","getHeader","secureSocket","$b21c5cd64305014d$var$mergeOptions","servername","replace","indexOf","target","arguments","overrides","keys","j","keyLen","k","undefined","agent","defaultPort","addRequest","req","push","onFree","emit","onCloseOrRemove","removeListener","placeholder","connectOptions","method","path","headers","proxyAuth","Buffer","toString","connectReq","onConnect","res","head","removeAllListeners","statusCode","error","useChunkedEncodingByDefault","once","upgrade","process","nextTick","cause","message","stack","end","pos","shift","env","NODE_DEBUG","test","args","Array","slice","unshift","console","apply"],"version":3,"file":"python-version-check.929971c1.js.map","sourceRoot":"../"}