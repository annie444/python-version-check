{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js"],"sourcesContent":["import $b58ul$pythonversioncheck3f48d3eejs from \"./python-version-check.3f48d3ee.js\";\nimport * as $b58ul$assert from \"assert\";\nimport {atob as $b58ul$atob} from \"buffer\";\n\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5a65\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5a65\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"igijf\", function(module, exports) {\n\n\nvar $036e52440850c9fd$require$atob = $b58ul$atob;\n\nvar $036e52440850c9fd$require$isomorphicDecode = $b58ul$pythonversioncheck3f48d3eejs.isomorphicDecode;\nconst $036e52440850c9fd$var$encoder = new TextEncoder();\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */ const $036e52440850c9fd$var$HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;\nconst $036e52440850c9fd$var$HTTP_WHITESPACE_REGEX = /(\\u000A|\\u000D|\\u0009|\\u0020)/ // eslint-disable-line\n;\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */ const $036e52440850c9fd$var$HTTP_QUOTED_STRING_TOKENS = /[\\u0009|\\u0020-\\u007E|\\u0080-\\u00FF]/ // eslint-disable-line\n;\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */ function $036e52440850c9fd$var$dataURLProcessor(dataURL) {\n    // 1. Assert: dataURLâ€™s scheme is \"data\".\n    $b58ul$assert(dataURL.protocol === 'data:');\n    // 2. Let input be the result of running the URL\n    // serializer on dataURL with exclude fragment\n    // set to true.\n    let input = $036e52440850c9fd$var$URLSerializer(dataURL, true);\n    // 3. Remove the leading \"data:\" string from input.\n    input = input.slice(5);\n    // 4. Let position point at the start of input.\n    const position = {\n        position: 0\n    };\n    // 5. Let mimeType be the result of collecting a\n    // sequence of code points that are not equal\n    // to U+002C (,), given position.\n    let mimeType = $036e52440850c9fd$var$collectASequenceOfCodePointsFast(',', input, position);\n    // 6. Strip leading and trailing ASCII whitespace\n    // from mimeType.\n    // Undici implementation note: we need to store the\n    // length because if the mimetype has spaces removed,\n    // the wrong amount will be sliced from the input in\n    // step #9\n    const mimeTypeLength = mimeType.length;\n    mimeType = $036e52440850c9fd$var$removeASCIIWhitespace(mimeType, true, true);\n    // 7. If position is past the end of input, then\n    // return failure\n    if (position.position >= input.length) return 'failure';\n    // 8. Advance position by 1.\n    position.position++;\n    // 9. Let encodedBody be the remainder of input.\n    const encodedBody = input.slice(mimeTypeLength + 1);\n    // 10. Let body be the percent-decoding of encodedBody.\n    let body = $036e52440850c9fd$var$stringPercentDecode(encodedBody);\n    // 11. If mimeType ends with U+003B (;), followed by\n    // zero or more U+0020 SPACE, followed by an ASCII\n    // case-insensitive match for \"base64\", then:\n    if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n        // 1. Let stringBody be the isomorphic decode of body.\n        const stringBody = $036e52440850c9fd$require$isomorphicDecode(body);\n        // 2. Set body to the forgiving-base64 decode of\n        // stringBody.\n        body = $036e52440850c9fd$var$forgivingBase64(stringBody);\n        // 3. If body is failure, then return failure.\n        if (body === 'failure') return 'failure';\n        // 4. Remove the last 6 code points from mimeType.\n        mimeType = mimeType.slice(0, -6);\n        // 5. Remove trailing U+0020 SPACE code points from mimeType,\n        // if any.\n        mimeType = mimeType.replace(/(\\u0020)+$/, '');\n        // 6. Remove the last U+003B (;) code point from mimeType.\n        mimeType = mimeType.slice(0, -1);\n    }\n    // 12. If mimeType starts with U+003B (;), then prepend\n    // \"text/plain\" to mimeType.\n    if (mimeType.startsWith(';')) mimeType = 'text/plain' + mimeType;\n    // 13. Let mimeTypeRecord be the result of parsing\n    // mimeType.\n    let mimeTypeRecord = $036e52440850c9fd$var$parseMIMEType(mimeType);\n    // 14. If mimeTypeRecord is failure, then set\n    // mimeTypeRecord to text/plain;charset=US-ASCII.\n    if (mimeTypeRecord === 'failure') mimeTypeRecord = $036e52440850c9fd$var$parseMIMEType('text/plain;charset=US-ASCII');\n    // 15. Return a new data: URL struct whose MIME\n    // type is mimeTypeRecord and body is body.\n    // https://fetch.spec.whatwg.org/#data-url-struct\n    return {\n        mimeType: mimeTypeRecord,\n        body: body\n    };\n}\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */ function $036e52440850c9fd$var$URLSerializer(url, excludeFragment = false) {\n    if (!excludeFragment) return url.href;\n    const href = url.href;\n    const hashLength = url.hash.length;\n    return hashLength === 0 ? href : href.substring(0, href.length - hashLength);\n}\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */ function $036e52440850c9fd$var$collectASequenceOfCodePoints(condition, input, position) {\n    // 1. Let result be the empty string.\n    let result = '';\n    // 2. While position doesnâ€™t point past the end of input and the\n    // code point at position within input meets the condition condition:\n    while(position.position < input.length && condition(input[position.position])){\n        // 1. Append that code point to the end of result.\n        result += input[position.position];\n        // 2. Advance position by 1.\n        position.position++;\n    }\n    // 3. Return result.\n    return result;\n}\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */ function $036e52440850c9fd$var$collectASequenceOfCodePointsFast(char, input, position) {\n    const idx = input.indexOf(char, position.position);\n    const start = position.position;\n    if (idx === -1) {\n        position.position = input.length;\n        return input.slice(start);\n    }\n    position.position = idx;\n    return input.slice(start, position.position);\n}\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */ function $036e52440850c9fd$var$stringPercentDecode(input) {\n    // 1. Let bytes be the UTF-8 encoding of input.\n    const bytes = $036e52440850c9fd$var$encoder.encode(input);\n    // 2. Return the percent-decoding of bytes.\n    return $036e52440850c9fd$var$percentDecode(bytes);\n}\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */ function $036e52440850c9fd$var$percentDecode(input) {\n    // 1. Let output be an empty byte sequence.\n    /** @type {number[]} */ const output = [];\n    // 2. For each byte byte in input:\n    for(let i = 0; i < input.length; i++){\n        const byte = input[i];\n        // 1. If byte is not 0x25 (%), then append byte to output.\n        if (byte !== 0x25) output.push(byte);\n        else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) output.push(0x25);\n        else {\n            // 1. Let bytePoint be the two bytes after byte in input,\n            // decoded, and then interpreted as hexadecimal number.\n            const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n            const bytePoint = Number.parseInt(nextTwoBytes, 16);\n            // 2. Append a byte whose value is bytePoint to output.\n            output.push(bytePoint);\n            // 3. Skip the next two bytes in input.\n            i += 2;\n        }\n    }\n    // 3. Return output.\n    return Uint8Array.from(output);\n}\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */ function $036e52440850c9fd$var$parseMIMEType(input) {\n    // 1. Remove any leading and trailing HTTP whitespace\n    // from input.\n    input = $036e52440850c9fd$var$removeHTTPWhitespace(input, true, true);\n    // 2. Let position be a position variable for input,\n    // initially pointing at the start of input.\n    const position = {\n        position: 0\n    };\n    // 3. Let type be the result of collecting a sequence\n    // of code points that are not U+002F (/) from\n    // input, given position.\n    const type = $036e52440850c9fd$var$collectASequenceOfCodePointsFast('/', input, position);\n    // 4. If type is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    // https://mimesniff.spec.whatwg.org/#http-token-code-point\n    if (type.length === 0 || !$036e52440850c9fd$var$HTTP_TOKEN_CODEPOINTS.test(type)) return 'failure';\n    // 5. If position is past the end of input, then return\n    // failure\n    if (position.position > input.length) return 'failure';\n    // 6. Advance position by 1. (This skips past U+002F (/).)\n    position.position++;\n    // 7. Let subtype be the result of collecting a sequence of\n    // code points that are not U+003B (;) from input, given\n    // position.\n    let subtype = $036e52440850c9fd$var$collectASequenceOfCodePointsFast(';', input, position);\n    // 8. Remove any trailing HTTP whitespace from subtype.\n    subtype = $036e52440850c9fd$var$removeHTTPWhitespace(subtype, false, true);\n    // 9. If subtype is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    if (subtype.length === 0 || !$036e52440850c9fd$var$HTTP_TOKEN_CODEPOINTS.test(subtype)) return 'failure';\n    const typeLowercase = type.toLowerCase();\n    const subtypeLowercase = subtype.toLowerCase();\n    // 10. Let mimeType be a new MIME type record whose type\n    // is type, in ASCII lowercase, and subtype is subtype,\n    // in ASCII lowercase.\n    // https://mimesniff.spec.whatwg.org/#mime-type\n    const mimeType = {\n        type: typeLowercase,\n        subtype: subtypeLowercase,\n        /** @type {Map<string, string>} */ parameters: new Map(),\n        // https://mimesniff.spec.whatwg.org/#mime-type-essence\n        essence: `${typeLowercase}/${subtypeLowercase}`\n    };\n    // 11. While position is not past the end of input:\n    while(position.position < input.length){\n        // 1. Advance position by 1. (This skips past U+003B (;).)\n        position.position++;\n        // 2. Collect a sequence of code points that are HTTP\n        // whitespace from input given position.\n        $036e52440850c9fd$var$collectASequenceOfCodePoints(// https://fetch.spec.whatwg.org/#http-whitespace\n        (char)=>$036e52440850c9fd$var$HTTP_WHITESPACE_REGEX.test(char), input, position);\n        // 3. Let parameterName be the result of collecting a\n        // sequence of code points that are not U+003B (;)\n        // or U+003D (=) from input, given position.\n        let parameterName = $036e52440850c9fd$var$collectASequenceOfCodePoints((char)=>char !== ';' && char !== '=', input, position);\n        // 4. Set parameterName to parameterName, in ASCII\n        // lowercase.\n        parameterName = parameterName.toLowerCase();\n        // 5. If position is not past the end of input, then:\n        if (position.position < input.length) {\n            // 1. If the code point at position within input is\n            // U+003B (;), then continue.\n            if (input[position.position] === ';') continue;\n            // 2. Advance position by 1. (This skips past U+003D (=).)\n            position.position++;\n        }\n        // 6. If position is past the end of input, then break.\n        if (position.position > input.length) break;\n        // 7. Let parameterValue be null.\n        let parameterValue = null;\n        // 8. If the code point at position within input is\n        // U+0022 (\"), then:\n        if (input[position.position] === '\"') {\n            // 1. Set parameterValue to the result of collecting\n            // an HTTP quoted string from input, given position\n            // and the extract-value flag.\n            parameterValue = $036e52440850c9fd$var$collectAnHTTPQuotedString(input, position, true);\n            // 2. Collect a sequence of code points that are not\n            // U+003B (;) from input, given position.\n            $036e52440850c9fd$var$collectASequenceOfCodePointsFast(';', input, position);\n        // 9. Otherwise:\n        } else {\n            // 1. Set parameterValue to the result of collecting\n            // a sequence of code points that are not U+003B (;)\n            // from input, given position.\n            parameterValue = $036e52440850c9fd$var$collectASequenceOfCodePointsFast(';', input, position);\n            // 2. Remove any trailing HTTP whitespace from parameterValue.\n            parameterValue = $036e52440850c9fd$var$removeHTTPWhitespace(parameterValue, false, true);\n            // 3. If parameterValue is the empty string, then continue.\n            if (parameterValue.length === 0) continue;\n        }\n        // 10. If all of the following are true\n        // - parameterName is not the empty string\n        // - parameterName solely contains HTTP token code points\n        // - parameterValue solely contains HTTP quoted-string token code points\n        // - mimeTypeâ€™s parameters[parameterName] does not exist\n        // then set mimeTypeâ€™s parameters[parameterName] to parameterValue.\n        if (parameterName.length !== 0 && $036e52440850c9fd$var$HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || $036e52440850c9fd$var$HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);\n    }\n    // 12. Return mimeType.\n    return mimeType;\n}\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */ function $036e52440850c9fd$var$forgivingBase64(data) {\n    // 1. Remove all ASCII whitespace from data.\n    data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '') // eslint-disable-line\n    ;\n    // 2. If dataâ€™s code point length divides by 4 leaving\n    // no remainder, then:\n    if (data.length % 4 === 0) // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '');\n    // 3. If dataâ€™s code point length divides by 4 leaving\n    // a remainder of 1, then return failure.\n    if (data.length % 4 === 1) return 'failure';\n    // 4. If data contains a code point that is not one of\n    //  U+002B (+)\n    //  U+002F (/)\n    //  ASCII alphanumeric\n    // then return failure.\n    if (/[^+/0-9A-Za-z]/.test(data)) return 'failure';\n    const binary = $036e52440850c9fd$require$atob(data);\n    const bytes = new Uint8Array(binary.length);\n    for(let byte = 0; byte < binary.length; byte++)bytes[byte] = binary.charCodeAt(byte);\n    return bytes;\n}\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */ function $036e52440850c9fd$var$collectAnHTTPQuotedString(input, position, extractValue) {\n    // 1. Let positionStart be position.\n    const positionStart = position.position;\n    // 2. Let value be the empty string.\n    let value = '';\n    // 3. Assert: the code point at position within input\n    // is U+0022 (\").\n    $b58ul$assert(input[position.position] === '\"');\n    // 4. Advance position by 1.\n    position.position++;\n    // 5. While true:\n    while(true){\n        // 1. Append the result of collecting a sequence of code points\n        // that are not U+0022 (\") or U+005C (\\) from input, given\n        // position, to value.\n        value += $036e52440850c9fd$var$collectASequenceOfCodePoints((char)=>char !== '\"' && char !== '\\\\', input, position);\n        // 2. If position is past the end of input, then break.\n        if (position.position >= input.length) break;\n        // 3. Let quoteOrBackslash be the code point at position within\n        // input.\n        const quoteOrBackslash = input[position.position];\n        // 4. Advance position by 1.\n        position.position++;\n        // 5. If quoteOrBackslash is U+005C (\\), then:\n        if (quoteOrBackslash === '\\\\') {\n            // 1. If position is past the end of input, then append\n            // U+005C (\\) to value and break.\n            if (position.position >= input.length) {\n                value += '\\\\';\n                break;\n            }\n            // 2. Append the code point at position within input to value.\n            value += input[position.position];\n            // 3. Advance position by 1.\n            position.position++;\n        // 6. Otherwise:\n        } else {\n            // 1. Assert: quoteOrBackslash is U+0022 (\").\n            $b58ul$assert(quoteOrBackslash === '\"');\n            break;\n        }\n    }\n    // 6. If the extract-value flag is set, then return value.\n    if (extractValue) return value;\n    // 7. Return the code points from positionStart to position,\n    // inclusive, within input.\n    return input.slice(positionStart, position.position);\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */ function $036e52440850c9fd$var$serializeAMimeType(mimeType) {\n    $b58ul$assert(mimeType !== 'failure');\n    const { parameters: parameters, essence: essence } = mimeType;\n    // 1. Let serialization be the concatenation of mimeTypeâ€™s\n    //    type, U+002F (/), and mimeTypeâ€™s subtype.\n    let serialization = essence;\n    // 2. For each name â†’ value of mimeTypeâ€™s parameters:\n    for (let [name, value] of parameters.entries()){\n        // 1. Append U+003B (;) to serialization.\n        serialization += ';';\n        // 2. Append name to serialization.\n        serialization += name;\n        // 3. Append U+003D (=) to serialization.\n        serialization += '=';\n        // 4. If value does not solely contain HTTP token code\n        //    points or value is the empty string, then:\n        if (!$036e52440850c9fd$var$HTTP_TOKEN_CODEPOINTS.test(value)) {\n            // 1. Precede each occurence of U+0022 (\") or\n            //    U+005C (\\) in value with U+005C (\\).\n            value = value.replace(/(\\\\|\")/g, '\\\\$1');\n            // 2. Prepend U+0022 (\") to value.\n            value = '\"' + value;\n            // 3. Append U+0022 (\") to value.\n            value += '\"';\n        }\n        // 5. Append value to serialization.\n        serialization += value;\n    }\n    // 3. Return serialization.\n    return serialization;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} char\n */ function $036e52440850c9fd$var$isHTTPWhiteSpace(char) {\n    return char === '\\r' || char === '\\n' || char === '\\t' || char === ' ';\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n */ function $036e52440850c9fd$var$removeHTTPWhitespace(str, leading = true, trailing = true) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        for(; lead < str.length && $036e52440850c9fd$var$isHTTPWhiteSpace(str[lead]); lead++);\n    }\n    if (trailing) {\n        for(; trail > 0 && $036e52440850c9fd$var$isHTTPWhiteSpace(str[trail]); trail--);\n    }\n    return str.slice(lead, trail + 1);\n}\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {string} char\n */ function $036e52440850c9fd$var$isASCIIWhitespace(char) {\n    return char === '\\r' || char === '\\n' || char === '\\t' || char === '\\f' || char === ' ';\n}\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */ function $036e52440850c9fd$var$removeASCIIWhitespace(str, leading = true, trailing = true) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        for(; lead < str.length && $036e52440850c9fd$var$isASCIIWhitespace(str[lead]); lead++);\n    }\n    if (trailing) {\n        for(; trail > 0 && $036e52440850c9fd$var$isASCIIWhitespace(str[trail]); trail--);\n    }\n    return str.slice(lead, trail + 1);\n}\nmodule.exports = {\n    dataURLProcessor: $036e52440850c9fd$var$dataURLProcessor,\n    URLSerializer: $036e52440850c9fd$var$URLSerializer,\n    collectASequenceOfCodePoints: $036e52440850c9fd$var$collectASequenceOfCodePoints,\n    collectASequenceOfCodePointsFast: $036e52440850c9fd$var$collectASequenceOfCodePointsFast,\n    stringPercentDecode: $036e52440850c9fd$var$stringPercentDecode,\n    parseMIMEType: $036e52440850c9fd$var$parseMIMEType,\n    collectAnHTTPQuotedString: $036e52440850c9fd$var$collectAnHTTPQuotedString,\n    serializeAMimeType: $036e52440850c9fd$var$serializeAMimeType\n};\n\n});\n\n\nparcelRequire(\"igijf\");\n\n//# sourceMappingURL=python-version-check.685b5bb2.js.map\n","const assert = require('assert')\nconst { atob } = require('buffer')\nconst { isomorphicDecode } = require('./util')\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/\nconst HTTP_WHITESPACE_REGEX = /(\\u000A|\\u000D|\\u0009|\\u0020)/ // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /[\\u0009|\\u0020-\\u007E|\\u0080-\\u00FF]/ // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURLâ€™s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href\n  }\n\n  const href = url.href\n  const hashLength = url.hash.length\n\n  return hashLength === 0 ? href : href.substring(0, href.length - hashLength)\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesnâ€™t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = []\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte)\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))\n    ) {\n      output.push(0x25)\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])\n      const bytePoint = Number.parseInt(nextTwoBytes, 16)\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint)\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeTypeâ€™s parameters[parameterName] does not exist\n    // then set mimeTypeâ€™s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '')  // eslint-disable-line\n\n  // 2. If dataâ€™s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '')\n  }\n\n  // 3. If dataâ€™s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure'\n  }\n\n  const binary = atob(data)\n  const bytes = new Uint8Array(binary.length)\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte)\n  }\n\n  return bytes\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeTypeâ€™s\n  //    type, U+002F (/), and mimeTypeâ€™s subtype.\n  let serialization = essence\n\n  // 2. For each name â†’ value of mimeTypeâ€™s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} char\n */\nfunction isHTTPWhiteSpace (char) {\n  return char === '\\r' || char === '\\n' || char === '\\t' || char === ' '\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);\n  }\n\n  if (trailing) {\n    for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);\n  }\n\n  return str.slice(lead, trail + 1)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {string} char\n */\nfunction isASCIIWhitespace (char) {\n  return char === '\\r' || char === '\\n' || char === '\\t' || char === '\\f' || char === ' '\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);\n  }\n\n  if (trailing) {\n    for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);\n  }\n\n  return str.slice(lead, trail + 1)\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n}\n"],"names":["$b58ul$pythonversioncheck3f48d3eejs","$b58ul$assert","atob","$b58ul$atob","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$036e52440850c9fd$require$isomorphicDecode","isomorphicDecode","$036e52440850c9fd$var$encoder","TextEncoder","$036e52440850c9fd$var$HTTP_TOKEN_CODEPOINTS","$036e52440850c9fd$var$HTTP_WHITESPACE_REGEX","$036e52440850c9fd$var$HTTP_QUOTED_STRING_TOKENS","$036e52440850c9fd$var$URLSerializer","url","excludeFragment","href","hashLength","hash","length","substring","$036e52440850c9fd$var$collectASequenceOfCodePoints","condition","input","position","result","$036e52440850c9fd$var$collectASequenceOfCodePointsFast","char","idx","indexOf","start","slice","$036e52440850c9fd$var$stringPercentDecode","$036e52440850c9fd$var$percentDecode","output","i","byte","push","test","String","fromCharCode","bytePoint","Number","parseInt","Uint8Array","from","encode","$036e52440850c9fd$var$parseMIMEType","$036e52440850c9fd$var$removeHTTPWhitespace","type","subtype","typeLowercase","toLowerCase","subtypeLowercase","mimeType","parameters","Map","essence","parameterName","parameterValue","$036e52440850c9fd$var$collectAnHTTPQuotedString","has","set","extractValue","positionStart","value","quoteOrBackslash","$036e52440850c9fd$var$isHTTPWhiteSpace","str","leading","trailing","lead","trail","$036e52440850c9fd$var$isASCIIWhitespace","dataURLProcessor","dataURL","protocol","mimeTypeLength","$036e52440850c9fd$var$removeASCIIWhitespace","body","$036e52440850c9fd$var$forgivingBase64","data","replace","binary","$036e52440850c9fd$require$atob","bytes","charCodeAt","startsWith","mimeTypeRecord","URLSerializer","collectASequenceOfCodePoints","collectASequenceOfCodePointsFast","stringPercentDecode","parseMIMEType","collectAnHTTPQuotedString","serializeAMimeType","serialization","name","entries"],"version":3,"file":"python-version-check.685b5bb2.js.map","sourceRoot":"../"}