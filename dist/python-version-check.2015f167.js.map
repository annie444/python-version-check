{"mappings":"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","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RetryHandler.js"],"sourcesContent":["import $5gDXy$pythonversioncheckebf2a848js from \"./python-version-check.ebf2a848.js\";\nimport $5gDXy$pythonversioncheckdba5a2d4js from \"./python-version-check.dba5a2d4.js\";\nimport $5gDXy$pythonversioncheck7ed1514ejs2 from \"./python-version-check.7ed1514e.js\";\nimport * as $5gDXy$assert from \"assert\";\n\nvar $c1f8b319e1f96510$exports = {};\n\n\nvar $c1f8b319e1f96510$require$kRetryHandlerDefaultRetry = $5gDXy$pythonversioncheckebf2a848js.kRetryHandlerDefaultRetry;\n\nvar $c1f8b319e1f96510$require$RequestRetryError = $5gDXy$pythonversioncheckdba5a2d4js.RequestRetryError;\n\nvar $c1f8b319e1f96510$require$isDisturbed = $5gDXy$pythonversioncheck7ed1514ejs.isDisturbed;\nvar $c1f8b319e1f96510$require$parseHeaders = $5gDXy$pythonversioncheck7ed1514ejs1.parseHeaders;\nvar $c1f8b319e1f96510$require$parseRangeHeader = $5gDXy$pythonversioncheck7ed1514ejs2.parseRangeHeader;\nfunction $c1f8b319e1f96510$var$calculateRetryAfterHeader(retryAfter) {\n    const current = Date.now();\n    const diff = new Date(retryAfter).getTime() - current;\n    return diff;\n}\nclass $c1f8b319e1f96510$var$RetryHandler {\n    constructor(opts, handlers){\n        const { retryOptions: retryOptions, ...dispatchOpts } = opts;\n        const { // Retry scoped\n        retry: retryFn, maxRetries: maxRetries, maxTimeout: maxTimeout, minTimeout: minTimeout, timeoutFactor: timeoutFactor, methods: // Response scoped\n        methods, errorCodes: errorCodes, retryAfter: retryAfter, statusCodes: statusCodes } = retryOptions ?? {};\n        this.dispatch = handlers.dispatch;\n        this.handler = handlers.handler;\n        this.opts = dispatchOpts;\n        this.abort = null;\n        this.aborted = false;\n        this.retryOpts = {\n            retry: retryFn ?? $c1f8b319e1f96510$var$RetryHandler[$c1f8b319e1f96510$require$kRetryHandlerDefaultRetry],\n            retryAfter: retryAfter ?? true,\n            maxTimeout: maxTimeout ?? 30000,\n            timeout: minTimeout ?? 500,\n            timeoutFactor: timeoutFactor ?? 2,\n            maxRetries: maxRetries ?? 5,\n            // What errors we should retry\n            methods: methods ?? [\n                'GET',\n                'HEAD',\n                'OPTIONS',\n                'PUT',\n                'DELETE',\n                'TRACE'\n            ],\n            // Indicates which errors to retry\n            statusCodes: statusCodes ?? [\n                500,\n                502,\n                503,\n                504,\n                429\n            ],\n            // List of errors to retry\n            errorCodes: errorCodes ?? [\n                'ECONNRESET',\n                'ECONNREFUSED',\n                'ENOTFOUND',\n                'ENETDOWN',\n                'ENETUNREACH',\n                'EHOSTDOWN',\n                'EHOSTUNREACH',\n                'EPIPE'\n            ]\n        };\n        this.retryCount = 0;\n        this.start = 0;\n        this.end = null;\n        this.etag = null;\n        this.resume = null;\n        // Handle possible onConnect duplication\n        this.handler.onConnect((reason)=>{\n            this.aborted = true;\n            if (this.abort) this.abort(reason);\n            else this.reason = reason;\n        });\n    }\n    onRequestSent() {\n        if (this.handler.onRequestSent) this.handler.onRequestSent();\n    }\n    onUpgrade(statusCode, headers, socket) {\n        if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers, socket);\n    }\n    onConnect(abort) {\n        if (this.aborted) abort(this.reason);\n        else this.abort = abort;\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);\n    }\n    static [$c1f8b319e1f96510$require$kRetryHandlerDefaultRetry](err, { state: state, opts: opts }, cb) {\n        const { statusCode: statusCode, code: code, headers: headers } = err;\n        const { method: method, retryOptions: retryOptions } = opts;\n        const { maxRetries: maxRetries, timeout: timeout, maxTimeout: maxTimeout, timeoutFactor: timeoutFactor, statusCodes: statusCodes, errorCodes: errorCodes, methods: methods } = retryOptions;\n        let { counter: counter, currentTimeout: currentTimeout } = state;\n        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;\n        // Any code that is not a Undici's originated and allowed to retry\n        if (code && code !== 'UND_ERR_REQ_RETRY' && code !== 'UND_ERR_SOCKET' && !errorCodes.includes(code)) {\n            cb(err);\n            return;\n        }\n        // If a set of method are provided and the current method is not in the list\n        if (Array.isArray(methods) && !methods.includes(method)) {\n            cb(err);\n            return;\n        }\n        // If a set of status code are provided and the current status code is not in the list\n        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {\n            cb(err);\n            return;\n        }\n        // If we reached the max number of retries\n        if (counter > maxRetries) {\n            cb(err);\n            return;\n        }\n        let retryAfterHeader = headers != null && headers['retry-after'];\n        if (retryAfterHeader) {\n            retryAfterHeader = Number(retryAfterHeader);\n            retryAfterHeader = isNaN(retryAfterHeader) ? $c1f8b319e1f96510$var$calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3 // Retry-After is in seconds\n            ;\n        }\n        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);\n        state.currentTimeout = retryTimeout;\n        setTimeout(()=>cb(null), retryTimeout);\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const headers = $c1f8b319e1f96510$require$parseHeaders(rawHeaders);\n        this.retryCount += 1;\n        if (statusCode >= 300) {\n            this.abort(new $c1f8b319e1f96510$require$RequestRetryError('Request failed', statusCode, {\n                headers: headers,\n                count: this.retryCount\n            }));\n            return false;\n        }\n        // Checkpoint for resume from where we left it\n        if (this.resume != null) {\n            this.resume = null;\n            if (statusCode !== 206) return true;\n            const contentRange = $c1f8b319e1f96510$require$parseRangeHeader(headers['content-range']);\n            // If no content range\n            if (!contentRange) {\n                this.abort(new $c1f8b319e1f96510$require$RequestRetryError('Content-Range mismatch', statusCode, {\n                    headers: headers,\n                    count: this.retryCount\n                }));\n                return false;\n            }\n            // Let's start with a weak etag check\n            if (this.etag != null && this.etag !== headers.etag) {\n                this.abort(new $c1f8b319e1f96510$require$RequestRetryError('ETag mismatch', statusCode, {\n                    headers: headers,\n                    count: this.retryCount\n                }));\n                return false;\n            }\n            const { start: start, size: size, end: end = size } = contentRange;\n            $5gDXy$assert(this.start === start, 'content-range mismatch');\n            $5gDXy$assert(this.end == null || this.end === end, 'content-range mismatch');\n            this.resume = resume;\n            return true;\n        }\n        if (this.end == null) {\n            if (statusCode === 206) {\n                // First time we receive 206\n                const range = $c1f8b319e1f96510$require$parseRangeHeader(headers['content-range']);\n                if (range == null) return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n                const { start: start, size: size, end: end = size } = range;\n                $5gDXy$assert(start != null && Number.isFinite(start) && this.start !== start, 'content-range mismatch');\n                $5gDXy$assert(Number.isFinite(start));\n                $5gDXy$assert(end != null && Number.isFinite(end) && this.end !== end, 'invalid content-length');\n                this.start = start;\n                this.end = end;\n            }\n            // We make our best to checkpoint the body for further range headers\n            if (this.end == null) {\n                const contentLength = headers['content-length'];\n                this.end = contentLength != null ? Number(contentLength) : null;\n            }\n            $5gDXy$assert(Number.isFinite(this.start));\n            $5gDXy$assert(this.end == null || Number.isFinite(this.end), 'invalid content-length');\n            this.resume = resume;\n            this.etag = headers.etag != null ? headers.etag : null;\n            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n        }\n        const err = new $c1f8b319e1f96510$require$RequestRetryError('Request failed', statusCode, {\n            headers: headers,\n            count: this.retryCount\n        });\n        this.abort(err);\n        return false;\n    }\n    onData(chunk) {\n        this.start += chunk.length;\n        return this.handler.onData(chunk);\n    }\n    onComplete(rawTrailers) {\n        this.retryCount = 0;\n        return this.handler.onComplete(rawTrailers);\n    }\n    onError(err) {\n        if (this.aborted || $c1f8b319e1f96510$require$isDisturbed(this.opts.body)) return this.handler.onError(err);\n        this.retryOpts.retry(err, {\n            state: {\n                counter: this.retryCount++,\n                currentTimeout: this.retryAfter\n            },\n            opts: {\n                retryOptions: this.retryOpts,\n                ...this.opts\n            }\n        }, onRetry.bind(this));\n        function onRetry(err) {\n            if (err != null || this.aborted || $c1f8b319e1f96510$require$isDisturbed(this.opts.body)) return this.handler.onError(err);\n            if (this.start !== 0) this.opts = {\n                ...this.opts,\n                headers: {\n                    ...this.opts.headers,\n                    range: `bytes=${this.start}-${this.end ?? ''}`\n                }\n            };\n            try {\n                this.dispatch(this.opts, this);\n            } catch (err) {\n                this.handler.onError(err);\n            }\n        }\n    }\n}\n$c1f8b319e1f96510$exports = $c1f8b319e1f96510$var$RetryHandler;\n\n\nexport {$c1f8b319e1f96510$exports as default};\n//# sourceMappingURL=python-version-check.2015f167.js.map\n","const assert = require('assert')\n\nconst { kRetryHandlerDefaultRetry } = require('../core/symbols')\nconst { RequestRetryError } = require('../core/errors')\nconst { isDisturbed, parseHeaders, parseRangeHeader } = require('../core/util')\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const current = Date.now()\n  const diff = new Date(retryAfter).getTime() - current\n\n  return diff\n}\n\nclass RetryHandler {\n  constructor (opts, handlers) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes\n    } = retryOptions ?? {}\n\n    this.dispatch = handlers.dispatch\n    this.handler = handlers.handler\n    this.opts = dispatchOpts\n    this.abort = null\n    this.aborted = false\n    this.retryOpts = {\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      timeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE'\n      ]\n    }\n\n    this.retryCount = 0\n    this.start = 0\n    this.end = null\n    this.etag = null\n    this.resume = null\n\n    // Handle possible onConnect duplication\n    this.handler.onConnect(reason => {\n      this.aborted = true\n      if (this.abort) {\n        this.abort(reason)\n      } else {\n        this.reason = reason\n      }\n    })\n  }\n\n  onRequestSent () {\n    if (this.handler.onRequestSent) {\n      this.handler.onRequestSent()\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    if (this.handler.onUpgrade) {\n      this.handler.onUpgrade(statusCode, headers, socket)\n    }\n  }\n\n  onConnect (abort) {\n    if (this.aborted) {\n      abort(this.reason)\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      timeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    let { counter, currentTimeout } = state\n\n    currentTimeout =\n      currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (\n      code &&\n      code !== 'UND_ERR_REQ_RETRY' &&\n      code !== 'UND_ERR_SOCKET' &&\n      !errorCodes.includes(code)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers != null && headers['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(retryAfterHeader)\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout)\n\n    state.currentTimeout = retryTimeout\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const headers = parseHeaders(rawHeaders)\n\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      this.abort(\n        new RequestRetryError('Request failed', statusCode, {\n          headers,\n          count: this.retryCount\n        })\n      )\n      return false\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.resume != null) {\n      this.resume = null\n\n      if (statusCode !== 206) {\n        return true\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        this.abort(\n          new RequestRetryError('Content-Range mismatch', statusCode, {\n            headers,\n            count: this.retryCount\n          })\n        )\n        return false\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        this.abort(\n          new RequestRetryError('ETag mismatch', statusCode, {\n            headers,\n            count: this.retryCount\n          })\n        )\n        return false\n      }\n\n      const { start, size, end = size } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      this.resume = resume\n      return true\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          return this.handler.onHeaders(\n            statusCode,\n            rawHeaders,\n            resume,\n            statusMessage\n          )\n        }\n\n        const { start, size, end = size } = range\n\n        assert(\n          start != null && Number.isFinite(start) && this.start !== start,\n          'content-range mismatch'\n        )\n        assert(Number.isFinite(start))\n        assert(\n          end != null && Number.isFinite(end) && this.end !== end,\n          'invalid content-length'\n        )\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = resume\n      this.etag = headers.etag != null ? headers.etag : null\n\n      return this.handler.onHeaders(\n        statusCode,\n        rawHeaders,\n        resume,\n        statusMessage\n      )\n    }\n\n    const err = new RequestRetryError('Request failed', statusCode, {\n      headers,\n      count: this.retryCount\n    })\n\n    this.abort(err)\n\n    return false\n  }\n\n  onData (chunk) {\n    this.start += chunk.length\n\n    return this.handler.onData(chunk)\n  }\n\n  onComplete (rawTrailers) {\n    this.retryCount = 0\n    return this.handler.onComplete(rawTrailers)\n  }\n\n  onError (err) {\n    if (this.aborted || isDisturbed(this.opts.body)) {\n      return this.handler.onError(err)\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      onRetry.bind(this)\n    )\n\n    function onRetry (err) {\n      if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n        return this.handler.onError(err)\n      }\n\n      if (this.start !== 0) {\n        this.opts = {\n          ...this.opts,\n          headers: {\n            ...this.opts.headers,\n            range: `bytes=${this.start}-${this.end ?? ''}`\n          }\n        }\n      }\n\n      try {\n        this.dispatch(this.opts, this)\n      } catch (err) {\n        this.handler.onError(err)\n      }\n    }\n  }\n}\n\nmodule.exports = RetryHandler\n"],"names":["$5gDXy$pythonversioncheckebf2a848js","$5gDXy$pythonversioncheckdba5a2d4js","$5gDXy$pythonversioncheck7ed1514ejs2","$5gDXy$assert","$c1f8b319e1f96510$exports","$c1f8b319e1f96510$require$kRetryHandlerDefaultRetry","kRetryHandlerDefaultRetry","$c1f8b319e1f96510$require$RequestRetryError","RequestRetryError","$c1f8b319e1f96510$require$isDisturbed","$5gDXy$pythonversioncheck7ed1514ejs","isDisturbed","$c1f8b319e1f96510$require$parseHeaders","$5gDXy$pythonversioncheck7ed1514ejs1","parseHeaders","$c1f8b319e1f96510$require$parseRangeHeader","parseRangeHeader","$c1f8b319e1f96510$var$RetryHandler","opts","handlers","retryOptions","dispatchOpts","retry","retryFn","maxRetries","maxTimeout","minTimeout","timeoutFactor","methods","errorCodes","retryAfter","statusCodes","dispatch","handler","abort","aborted","retryOpts","timeout","retryCount","start","end","etag","resume","onConnect","reason","onRequestSent","onUpgrade","statusCode","headers","socket","onBodySent","chunk","err","state","cb","code","method","counter","currentTimeout","includes","Array","isArray","retryAfterHeader","isNaN","Number","$c1f8b319e1f96510$var$calculateRetryAfterHeader","current","Date","now","getTime","retryTimeout","Math","min","setTimeout","onHeaders","rawHeaders","statusMessage","count","contentRange","size","range","isFinite","contentLength","onData","length","onComplete","rawTrailers","onError","body","onRetry","bind","default"],"version":3,"file":"python-version-check.2015f167.js.map","sourceRoot":"../"}