{"mappings":"ICKI,C,Q,M,qD,C,I,E,C,EAHE,EAAA,EAAA,gBAAA,CAIN,GAAI,CACF,EAAS,wCACX,CAAE,KAAM,CAER,CA4DA,EAAiB,CACf,mBA3DF,MAIE,YAAa,CAAI,CAAE,CACjB,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,OAAO,CAAG,EAAO,WAAW,CAAC,EACpC,CAEA,YAAa,CAAM,CAAE,CACnB,IAAM,EAAa,IAAI,CAAC,SAAS,EAAE,YAAc,EAG7C,EAAgB,EAChB,EAAS,CAET,CAAA,EAAA,GACF,GAAU,EACV,EAAgB,KACP,EAAa,MACtB,GAAU,EACV,EAAgB,KAGlB,IAAM,EAAS,OAAO,WAAW,CAAC,EAAa,EAG/C,CAAA,CAAM,CAAC,EAAE,CAAG,CAAM,CAAC,EAAE,CAAG,EACxB,CAAM,CAAC,EAAE,EAAI,IACb,CAAM,CAAC,EAAE,CAAI,AAAA,CAAA,AAAY,IAAZ,CAAM,CAAC,EAAE,AAAG,EAAQ,EAGjC,CAAM,CAAC,EAAS,EAAE,CAAG,IAAI,CAAC,OAAO,CAAC,EAAE,CACpC,CAAM,CAAC,EAAS,EAAE,CAAG,IAAI,CAAC,OAAO,CAAC,EAAE,CACpC,CAAM,CAAC,EAAS,EAAE,CAAG,IAAI,CAAC,OAAO,CAAC,EAAE,CACpC,CAAM,CAAC,EAAS,EAAE,CAAG,IAAI,CAAC,OAAO,CAAC,EAAE,CAEpC,CAAM,CAAC,EAAE,CAAG,EAER,AAAkB,MAAlB,EACF,EAAO,aAAa,CAAC,EAAY,GACN,MAAlB,IAET,CAAM,CAAC,EAAE,CAAG,CAAM,CAAC,EAAE,CAAG,EACxB,EAAO,WAAW,CAAC,EAAY,EAAG,IAGpC,CAAM,CAAC,EAAE,EAAI,IAGb,IAAK,IAAI,EAAI,EAAG,EAAI,EAAY,IAC9B,CAAM,CAAC,EAAS,EAAE,CAAG,IAAI,CAAC,SAAS,CAAC,EAAE,CAAG,IAAI,CAAC,OAAO,CAAC,EAAI,EAAE,CAG9D,OAAO,CACT,CACF,CAIA,S,K,O","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/frame.js"],"sourcesContent":["import $bjK76$pythonversioncheck64bbae24js from \"./python-version-check.64bbae24.js\";\n\nvar $20e29c8a560f4180$exports = {};\n'use strict';\n\nvar $20e29c8a560f4180$require$maxUnsigned16Bit = $bjK76$pythonversioncheck64bbae24js.maxUnsigned16Bit;\n/** @type {import('crypto')} */ let $20e29c8a560f4180$var$crypto;\n\ntry {\n    $20e29c8a560f4180$var$crypto = $20e29c8a560f4180$import$575846564481007;\n} catch  {}\nclass $20e29c8a560f4180$var$WebsocketFrameSend {\n    /**\n   * @param {Buffer|undefined} data\n   */ constructor(data){\n        this.frameData = data;\n        this.maskKey = $20e29c8a560f4180$var$crypto.randomBytes(4);\n    }\n    createFrame(opcode) {\n        const bodyLength = this.frameData?.byteLength ?? 0;\n        /** @type {number} */ let payloadLength = bodyLength // 0-125\n        ;\n        let offset = 6;\n        if (bodyLength > $20e29c8a560f4180$require$maxUnsigned16Bit) {\n            offset += 8 // payload length is next 8 bytes\n            ;\n            payloadLength = 127;\n        } else if (bodyLength > 125) {\n            offset += 2 // payload length is next 2 bytes\n            ;\n            payloadLength = 126;\n        }\n        const buffer = Buffer.allocUnsafe(bodyLength + offset);\n        // Clear first 2 bytes, everything else is overwritten\n        buffer[0] = buffer[1] = 0;\n        buffer[0] |= 0x80 // FIN\n        ;\n        buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n        ;\n        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ buffer[offset - 4] = this.maskKey[0];\n        buffer[offset - 3] = this.maskKey[1];\n        buffer[offset - 2] = this.maskKey[2];\n        buffer[offset - 1] = this.maskKey[3];\n        buffer[1] = payloadLength;\n        if (payloadLength === 126) buffer.writeUInt16BE(bodyLength, 2);\n        else if (payloadLength === 127) {\n            // Clear extended payload length\n            buffer[2] = buffer[3] = 0;\n            buffer.writeUIntBE(bodyLength, 4, 6);\n        }\n        buffer[1] |= 0x80 // MASK\n        ;\n        // mask body\n        for(let i = 0; i < bodyLength; i++)buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];\n        return buffer;\n    }\n}\n$20e29c8a560f4180$exports = {\n    WebsocketFrameSend: $20e29c8a560f4180$var$WebsocketFrameSend\n};\n\n\nexport {$20e29c8a560f4180$exports as default};\n//# sourceMappingURL=python-version-check.1bc0acd6.js.map\n","'use strict'\n\nconst { maxUnsigned16Bit } = require('./constants')\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n    this.maskKey = crypto.randomBytes(4)\n  }\n\n  createFrame (opcode) {\n    const bodyLength = this.frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = this.maskKey[0]\n    buffer[offset - 3] = this.maskKey[1]\n    buffer[offset - 2] = this.maskKey[2]\n    buffer[offset - 1] = this.maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; i++) {\n      buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4]\n    }\n\n    return buffer\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend\n}\n"],"names":["$20e29c8a560f4180$var$crypto","$bjK76$pythonversioncheck64bbae24js","$20e29c8a560f4180$exports","$20e29c8a560f4180$require$maxUnsigned16Bit","maxUnsigned16Bit","$20e29c8a560f4180$import$575846564481007","WebsocketFrameSend","data","frameData","maskKey","randomBytes","createFrame","opcode","bodyLength","byteLength","payloadLength","offset","buffer","Buffer","allocUnsafe","writeUInt16BE","writeUIntBE","i","default"],"version":3,"file":"python-version-check.1bc0acd6.js.map","sourceRoot":"../"}