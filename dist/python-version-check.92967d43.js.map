{"mappings":"A,O,M,qD,A,Q,M,qD,A,Q,M,qD,C,I,E,C,ECEM,EAAA,sDAAA,WAAA,CAAA,EAAA,sDAAA,WAAA,CAAA,EAAA,sDAAA,SAAA,CAAA,EAAA,qDAAA,WAAA,CAAA,EAAA,EAAA,aAAA,CACA,EAAA,EAAA,MAAA,CAAA,EAAA,qDAAA,OAAA,CACA,EAAA,EAAA,YAAA,CAAA,EAAA,qDAAA,UAAA,CAqCN,SAAS,EAAW,CAAC,CAAE,CAAM,CAAE,EAAmB,KAAK,CAAE,CAAa,EAMpE,IAAM,EAAQ,IAAI,EAAiB,EAAG,GAOtC,EAAO,aAAa,CAAC,EACvB,CAuHA,SAAS,EAAyB,CAAE,CAAE,CAAM,EAC1C,GAAM,CAAE,CAAA,EAAa,CAAE,CAAU,CAAE,CAAA,EAAW,CAAE,CAAQ,CAAE,CAAG,EAE7D,EAAW,KAAK,GAEZ,GAAU,QAAU,CAAC,EAAS,MAAM,CAAC,SAAS,EAChD,EAAS,MAAM,CAAC,OAAO,GAGrB,GACF,EAAU,QAAS,EAAA,EAAgB,CACjC,MAAO,AAAI,MAAM,EACnB,EAEJ,CAEA,EAAiB,CACf,cApLF,SAAwB,CAAE,EAIxB,OAAO,CAAE,CAAA,EAAa,GAAK,EAAO,IAAI,AACxC,EAgLE,UA3KF,SAAoB,CAAE,EAIpB,OAAO,CAAE,CAAA,EAAa,GAAK,EAAO,OAAO,AAC3C,EAuKE,SAlKF,SAAmB,CAAE,EACnB,OAAO,CAAE,CAAA,EAAa,GAAK,EAAO,MAAM,AAC1C,EAiKE,UAAA,EACA,mBArFF,SAA6B,CAAQ,EAOnC,GAAI,AAAoB,IAApB,EAAS,MAAM,CACjB,MAAO,CAAA,EAGT,IAAK,IAAM,KAAQ,EAAU,CAC3B,IAAM,EAAO,EAAK,UAAU,CAAC,GAE7B,GACE,EAAO,IACP,EAAO,KACP,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,OAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,MAAT,GACA,AAAS,KAAT,GACA,AAAS,IAAT,EAEA,MAAO,CAAA,CAEX,CAEA,MAAO,CAAA,CACT,EA4CE,kBAtCF,SAA4B,CAAI,SAC9B,AAAI,GAAQ,KAAQ,EAAO,KAEvB,AAAS,OAAT,GACA,AAAS,OAAT,GACA,AAAS,OAAT,EAIG,GAAQ,KAAQ,GAAQ,IACjC,EA6BE,wBAAA,EACA,yBAvIF,SAAmC,CAAE,CAAE,CAAI,CAAE,CAAI,MAO3C,EALJ,GAAI,CAAE,CAAA,EAAa,GAAK,EAAO,IAAI,EAOnC,GAAI,IAAS,EAAQ,IAAI,CAGvB,GAAI,CACF,EAAe,IAAI,YAAY,QAAS,CAAE,MAAO,CAAA,CAAK,GAAG,MAAM,CAAC,EAClE,CAAE,KAAM,CACN,EAAwB,EAAI,yCAC5B,MACF,MACS,IAAS,EAAQ,MAAM,GAK9B,EAJE,AAAoB,SAApB,CAAE,CAAA,EAAa,CAIF,IAAI,KAAK,CAAC,EAAK,EAKf,IAAI,WAAW,GAAM,MAAM,EAO9C,EAAU,UAAW,EAAA,EAAkB,CACrC,OAAQ,CAAE,CAAA,EAAe,CAAC,MAAM,CAChC,KAAM,CACR,GACF,CAiGA,S,K,O","sources":["<anon>","node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js"],"sourcesContent":["import $ckTHP$pythonversioncheckf95b0f32js4 from \"./python-version-check.f95b0f32.js\";\nimport $ckTHP$pythonversioncheck64bbae24js1 from \"./python-version-check.64bbae24.js\";\nimport $ckTHP$pythonversioncheck13770064js1 from \"./python-version-check.13770064.js\";\n\nvar $38716392a359e964$exports = {};\n'use strict';\n\nvar $38716392a359e964$require$kReadyState = $ckTHP$pythonversioncheckf95b0f32js2.kReadyState;\nvar $38716392a359e964$require$kController = $ckTHP$pythonversioncheckf95b0f32js1.kController;\nvar $38716392a359e964$require$kResponse = $ckTHP$pythonversioncheckf95b0f32js3.kResponse;\nvar $38716392a359e964$require$kBinaryType = $ckTHP$pythonversioncheckf95b0f32js.kBinaryType;\nvar $38716392a359e964$require$kWebSocketURL = $ckTHP$pythonversioncheckf95b0f32js4.kWebSocketURL;\n\nvar $38716392a359e964$require$states = $ckTHP$pythonversioncheck64bbae24js1.states;\nvar $38716392a359e964$require$opcodes = $ckTHP$pythonversioncheck64bbae24js.opcodes;\n\nvar $38716392a359e964$require$MessageEvent = $ckTHP$pythonversioncheck13770064js1.MessageEvent;\nvar $38716392a359e964$require$ErrorEvent = $ckTHP$pythonversioncheck13770064js.ErrorEvent;\n/* globals Blob */ /**\n * @param {import('./websocket').WebSocket} ws\n */ function $38716392a359e964$var$isEstablished(ws) {\n    // If the server's response is validated as provided for above, it is\n    // said that _The WebSocket Connection is Established_ and that the\n    // WebSocket Connection is in the OPEN state.\n    return ws[$38716392a359e964$require$kReadyState] === $38716392a359e964$require$states.OPEN;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n */ function $38716392a359e964$var$isClosing(ws) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    return ws[$38716392a359e964$require$kReadyState] === $38716392a359e964$require$states.CLOSING;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n */ function $38716392a359e964$var$isClosed(ws) {\n    return ws[$38716392a359e964$require$kReadyState] === $38716392a359e964$require$states.CLOSED;\n}\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {EventInit | undefined} eventInitDict\n */ function $38716392a359e964$var$fireEvent(e, target, eventConstructor = Event, eventInitDict) {\n    // 1. If eventConstructor is not given, then let eventConstructor be Event.\n    // 2. Let event be the result of creating an event given eventConstructor,\n    //    in the relevant realm of target.\n    // 3. Initialize event’s type attribute to e.\n    const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap\n    ;\n    // 4. Initialize any other IDL attributes of event as described in the\n    //    invocation of this algorithm.\n    // 5. Return the result of dispatching event at target, with legacy target\n    //    override flag set if set.\n    target.dispatchEvent(event);\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */ function $38716392a359e964$var$websocketMessageReceived(ws, type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (ws[$38716392a359e964$require$kReadyState] !== $38716392a359e964$require$states.OPEN) return;\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent;\n    if (type === $38716392a359e964$require$opcodes.TEXT) // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n        dataForEvent = new TextDecoder('utf-8', {\n            fatal: true\n        }).decode(data);\n    } catch  {\n        $38716392a359e964$var$failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');\n        return;\n    }\n    else if (type === $38716392a359e964$require$opcodes.BINARY) {\n        if (ws[$38716392a359e964$require$kBinaryType] === 'blob') // -> type indicates that the data is Binary and binary type is \"blob\"\n        //      a new Blob object, created in the relevant Realm of the WebSocket\n        //      object, that represents data as its raw data\n        dataForEvent = new Blob([\n            data\n        ]);\n        else // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n        //      a new ArrayBuffer object, created in the relevant Realm of the\n        //      WebSocket object, whose contents are data\n        dataForEvent = new Uint8Array(data).buffer;\n    }\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    object’s url's origin, and the data attribute initialized to dataForEvent.\n    $38716392a359e964$var$fireEvent('message', ws, $38716392a359e964$require$MessageEvent, {\n        origin: ws[$38716392a359e964$require$kWebSocketURL].origin,\n        data: dataForEvent\n    });\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */ function $38716392a359e964$var$isValidSubprotocol(protocol) {\n    // If present, this value indicates one\n    // or more comma-separated subprotocol the client wishes to speak,\n    // ordered by preference.  The elements that comprise this value\n    // MUST be non-empty strings with characters in the range U+0021 to\n    // U+007E not including separator characters as defined in\n    // [RFC2616] and MUST all be unique strings.\n    if (protocol.length === 0) return false;\n    for (const char of protocol){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || code > 0x7E || char === '(' || char === ')' || char === '<' || char === '>' || char === '@' || char === ',' || char === ';' || char === ':' || char === '\\\\' || char === '\"' || char === '/' || char === '[' || char === ']' || char === '?' || char === '=' || char === '{' || char === '}' || code === 32 || // SP\n        code === 9 // HT\n        ) return false;\n    }\n    return true;\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */ function $38716392a359e964$var$isValidStatusCode(code) {\n    if (code >= 1000 && code < 1015) return code !== 1004 && // reserved\n    code !== 1005 && // \"MUST NOT be set as a status code\"\n    code !== 1006 // \"MUST NOT be set as a status code\"\n    ;\n    return code >= 3000 && code <= 4999;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */ function $38716392a359e964$var$failWebsocketConnection(ws, reason) {\n    const { [$38716392a359e964$require$kController]: controller, [$38716392a359e964$require$kResponse]: response } = ws;\n    controller.abort();\n    if (response?.socket && !response.socket.destroyed) response.socket.destroy();\n    if (reason) $38716392a359e964$var$fireEvent('error', ws, $38716392a359e964$require$ErrorEvent, {\n        error: new Error(reason)\n    });\n}\n$38716392a359e964$exports = {\n    isEstablished: $38716392a359e964$var$isEstablished,\n    isClosing: $38716392a359e964$var$isClosing,\n    isClosed: $38716392a359e964$var$isClosed,\n    fireEvent: $38716392a359e964$var$fireEvent,\n    isValidSubprotocol: $38716392a359e964$var$isValidSubprotocol,\n    isValidStatusCode: $38716392a359e964$var$isValidStatusCode,\n    failWebsocketConnection: $38716392a359e964$var$failWebsocketConnection,\n    websocketMessageReceived: $38716392a359e964$var$websocketMessageReceived\n};\n\n\nexport {$38716392a359e964$exports as default};\n//# sourceMappingURL=python-version-check.92967d43.js.map\n","'use strict'\n\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require('./symbols')\nconst { states, opcodes } = require('./constants')\nconst { MessageEvent, ErrorEvent } = require('./events')\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isEstablished (ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isClosing (ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n */\nfunction isClosed (ws) {\n  return ws[kReadyState] === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent (e, target, eventConstructor = Event, eventInitDict) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived (ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent\n\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = new TextDecoder('utf-8', { fatal: true }).decode(data)\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')\n      return\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data])\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = new Uint8Array(data).buffer\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    object’s url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, MessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  })\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (const char of protocol) {\n    const code = char.charCodeAt(0)\n\n    if (\n      code < 0x21 ||\n      code > 0x7E ||\n      char === '(' ||\n      char === ')' ||\n      char === '<' ||\n      char === '>' ||\n      char === '@' ||\n      char === ',' ||\n      char === ';' ||\n      char === ':' ||\n      char === '\\\\' ||\n      char === '\"' ||\n      char === '/' ||\n      char === '[' ||\n      char === ']' ||\n      char === '?' ||\n      char === '=' ||\n      char === '{' ||\n      char === '}' ||\n      code === 32 || // SP\n      code === 9 // HT\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection (ws, reason) {\n  const { [kController]: controller, [kResponse]: response } = ws\n\n  controller.abort()\n\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy()\n  }\n\n  if (reason) {\n    fireEvent('error', ws, ErrorEvent, {\n      error: new Error(reason)\n    })\n  }\n}\n\nmodule.exports = {\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived\n}\n"],"names":["$ckTHP$pythonversioncheckf95b0f32js4","$ckTHP$pythonversioncheck64bbae24js1","$ckTHP$pythonversioncheck13770064js1","$38716392a359e964$exports","$38716392a359e964$require$kReadyState","$ckTHP$pythonversioncheckf95b0f32js2","kReadyState","$38716392a359e964$require$kController","$ckTHP$pythonversioncheckf95b0f32js1","kController","$38716392a359e964$require$kResponse","$ckTHP$pythonversioncheckf95b0f32js3","kResponse","$38716392a359e964$require$kBinaryType","$ckTHP$pythonversioncheckf95b0f32js","kBinaryType","$38716392a359e964$require$kWebSocketURL","kWebSocketURL","$38716392a359e964$require$states","states","$38716392a359e964$require$opcodes","$ckTHP$pythonversioncheck64bbae24js","opcodes","$38716392a359e964$require$MessageEvent","MessageEvent","$38716392a359e964$require$ErrorEvent","$ckTHP$pythonversioncheck13770064js","ErrorEvent","$38716392a359e964$var$fireEvent","e","target","eventConstructor","Event","eventInitDict","event","dispatchEvent","$38716392a359e964$var$failWebsocketConnection","ws","reason","controller","response","abort","socket","destroyed","destroy","error","Error","isEstablished","OPEN","isClosing","CLOSING","isClosed","CLOSED","fireEvent","isValidSubprotocol","protocol","length","char","code","charCodeAt","isValidStatusCode","failWebsocketConnection","websocketMessageReceived","type","data","dataForEvent","TEXT","TextDecoder","fatal","decode","BINARY","Blob","Uint8Array","buffer","origin","default"],"version":3,"file":"python-version-check.92967d43.js.map","sourceRoot":"../"}